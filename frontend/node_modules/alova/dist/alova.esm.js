/**
  * alova 3.0.17 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2024 Scott Hu. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
*/

import { getTime, buildNamespacedCacheKey, instanceOf, newInstance, getContext, objAssign, getMethodInternalKey, getLocalCacheConfigParam, isFn, getConfig, getOptions, isPlainObject, sloughFunction, noop, $self, isSpecialRequestBody, getContextOptions, key, isString } from '@alova/shared/function';
import { defaultIsSSR, STORAGE_RESTORE, len, filterItem as filterItem$1, undefinedValue, forEach, RegExpCls, pushItem as pushItem$1, mapItem as mapItem$1, objectKeys, PromiseCls, deleteAttr, isArray, MEMORY, promiseThen, trueValue, falseValue, promiseFinally, promiseReject, promiseCatch, JSONStringify, JSONParse } from '@alova/shared/vars';
import { createAssert } from '@alova/shared/assert';

let globalConfigMap = {
    autoHitCache: 'global',
    ssr: defaultIsSSR
};
/**
 * Set global configuration
 * @param config
 */
var globalConfig = (config) => {
    globalConfigMap = {
        ...globalConfigMap,
        ...config
    };
};

const titleStyle = 'color: black; font-size: 12px; font-weight: bolder';
/**
 * 默认cacheLogger函数
 */
var defaultCacheLogger = (response, methodInstance, cacheMode, tag) => {
    const cole = console;
    // eslint-disable-next-line
    const log = (...args) => console.log(...args);
    const { url } = methodInstance;
    const isRestoreMode = cacheMode === STORAGE_RESTORE;
    const hdStyle = '\x1B[42m%s\x1B[49m';
    const labelStyle = '\x1B[32m%s\x1B[39m';
    const startSep = ` [HitCache]${url} `;
    const endSepFn = () => Array(len(startSep) + 1).join('^');
    if (globalConfigMap.ssr) {
        log(hdStyle, startSep);
        log(labelStyle, ' Cache ', response);
        log(labelStyle, ' Mode  ', cacheMode);
        isRestoreMode && log(labelStyle, ' Tag   ', tag);
        log(labelStyle, endSepFn());
    }
    else {
        cole.groupCollapsed
            ? cole.groupCollapsed('%cHitCache', 'padding: 2px 6px; background: #c4fcd3; color: #53b56d;', url)
            : log(hdStyle, startSep);
        log('%c[Cache]', titleStyle, response);
        log('%c[Mode]', titleStyle, cacheMode);
        isRestoreMode && log('%c[Tag]', titleStyle, tag);
        log('%c[Method]', titleStyle, methodInstance);
        cole.groupEnd ? cole.groupEnd() : log(labelStyle, endSepFn());
    }
};

const hitSourceStringCacheKey = (key) => `hss.${key}`;
const hitSourceRegexpPrefix = 'hsr.';
const hitSourceRegexpCacheKey = (regexpStr) => hitSourceRegexpPrefix + regexpStr;
const unifiedHitSourceRegexpCacheKey = '$$hsrs';
const regexpSourceFlagSeparator = '__$<>$__';
const addItem = (obj, item) => {
    obj[item] = 0;
};
/**
 * set or update cache
 * @param namespace 命名空间
 * @param key 存储的key
 * @param response 存储的响应内容
 * @param expireTimestamp 过期时间点的时间戳表示
 * @param storage 存储对象
 * @param tag 存储标签，用于区分不同的存储标记
 */
const setWithCacheAdapter = async (namespace, key, data, expireTimestamp, cacheAdapter, hitSource, tag) => {
    // not to cache if expireTimestamp is less than current timestamp
    if (expireTimestamp > getTime() && data) {
        const methodCacheKey = buildNamespacedCacheKey(namespace, key);
        await cacheAdapter.set(methodCacheKey, filterItem$1([data, expireTimestamp === Infinity ? undefinedValue : expireTimestamp, tag], Boolean));
        // save the relationship between this method and its hitSources.
        // cache structure is like this:
        /*
          {
            "$a.[namespace][methodKey]": [cache data],
            ...
            "hss.[sourceMethodKey]": "{
              [targetMethodKey1]: 0,
              [targetMethodKey2]: 0,
              ...
            }",
            "hss.[sourceMethodName]": "{
              [targetMethodKey3]: 0,
              [targetMethodKey4]: 0,
              ...
            }",
            "hsr.[sourceMethodNameRegexpSource]": "{
              [targetMethodKey5]: 0,
              [targetMethodKey6]: 0,
              ...
            }",
            "hsr.regexp1": ["hss.key1", "hss.key2"],
            "hsr.regexp2": ["hss.key1", "hss.key2"]
          }
        */
        if (hitSource) {
            // filter repeat items and categorize the regexp, to prevent unnecessary cost of IO
            const hitSourceKeys = {};
            const hitSourceRegexpSources = [];
            forEach(hitSource, sourceItem => {
                const isRegexp = instanceOf(sourceItem, RegExpCls);
                const targetHitSourceKey = isRegexp
                    ? sourceItem.source + (sourceItem.flags ? regexpSourceFlagSeparator + sourceItem.flags : '')
                    : sourceItem;
                if (targetHitSourceKey) {
                    if (isRegexp && !hitSourceKeys[targetHitSourceKey]) {
                        pushItem$1(hitSourceRegexpSources, targetHitSourceKey);
                    }
                    addItem(hitSourceKeys, isRegexp ? hitSourceRegexpCacheKey(targetHitSourceKey) : hitSourceStringCacheKey(targetHitSourceKey));
                }
            });
            // save the relationship. Minimize IO as much as possible
            const promises = mapItem$1(objectKeys(hitSourceKeys), async (hitSourceKey) => {
                // filter the empty strings.
                const targetMethodKeys = (await cacheAdapter.get(hitSourceKey)) || {};
                addItem(targetMethodKeys, methodCacheKey);
                await cacheAdapter.set(hitSourceKey, targetMethodKeys);
            });
            const saveRegexp = async () => {
                // save the regexp source if regexp exists.
                if (len(hitSourceRegexpSources)) {
                    const regexpList = (await cacheAdapter.get(unifiedHitSourceRegexpCacheKey)) || [];
                    // TODO: hitSourceRegexpSources 需要去重
                    pushItem$1(regexpList, ...hitSourceRegexpSources);
                    await cacheAdapter.set(unifiedHitSourceRegexpCacheKey, regexpList);
                }
            };
            // parallel executing all async tasks.
            await PromiseCls.all([...promises, saveRegexp()]);
        }
    }
};
/**
 * 删除存储的响应数据
 * @param namespace 命名空间
 * @param key 存储的key
 * @param storage 存储对象
 */
const removeWithCacheAdapter = async (namespace, key, cacheAdapter) => {
    const methodStoreKey = buildNamespacedCacheKey(namespace, key);
    await cacheAdapter.remove(methodStoreKey);
};
/**
 * 获取存储的响应数据
 * @param namespace 命名空间
 * @param key 存储的key
 * @param storage 存储对象
 * @param tag 存储标签，标记改变了数据将会失效
 */
const getRawWithCacheAdapter = async (namespace, key, cacheAdapter, tag) => {
    const storagedData = await cacheAdapter.get(buildNamespacedCacheKey(namespace, key));
    if (storagedData) {
        // eslint-disable-next-line
        const [_, expireTimestamp, storedTag] = storagedData;
        // 如果没有过期时间则表示数据永不过期，否则需要判断是否过期
        if (storedTag === tag && (!expireTimestamp || expireTimestamp > getTime())) {
            return storagedData;
        }
        // 如果过期，则删除缓存
        await removeWithCacheAdapter(namespace, key, cacheAdapter);
    }
};
/**
 * 获取存储的响应数据
 * @param namespace 命名空间
 * @param key 存储的key
 * @param storage 存储对象
 * @param tag 存储标签，标记改变了数据将会失效
 */
const getWithCacheAdapter = async (namespace, key, cacheAdapter, tag) => {
    const rawData = await getRawWithCacheAdapter(namespace, key, cacheAdapter, tag);
    return rawData ? rawData[0] : undefinedValue;
};
/**
 * clear all cached data
 */
const clearWithCacheAdapter = async (cacheAdapters) => PromiseCls.all(cacheAdapters.map(cacheAdapter => cacheAdapter.clear()));
/**
 * query and delete target cache with key and name of source method instance.
 * @param sourceKey source method instance key
 * @param sourceName source method instance name
 * @param cacheAdapter cache adapter
 */
const hitTargetCacheWithCacheAdapter = async (sourceKey, sourceName, cacheAdapter) => {
    const sourceNameStr = `${sourceName}`;
    // map that recording the source key and target method keys.
    const sourceTargetKeyMap = {};
    // get hit key by method key.
    const hitSourceKey = hitSourceStringCacheKey(sourceKey);
    sourceTargetKeyMap[hitSourceKey] = await cacheAdapter.get(hitSourceKey);
    let unifiedHitSourceRegexpChannel;
    if (sourceName) {
        const hitSourceName = hitSourceStringCacheKey(sourceNameStr);
        // get hit key by method name if it is exists.
        sourceTargetKeyMap[hitSourceName] = await cacheAdapter.get(hitSourceName);
        // match regexped key by source method name and get hit key by method name.
        unifiedHitSourceRegexpChannel = await cacheAdapter.get(unifiedHitSourceRegexpCacheKey);
        const matchedRegexpStrings = [];
        if (unifiedHitSourceRegexpChannel && len(unifiedHitSourceRegexpChannel)) {
            forEach(unifiedHitSourceRegexpChannel, regexpStr => {
                const [source, flag] = regexpStr.split(regexpSourceFlagSeparator);
                if (newInstance(RegExpCls, source, flag).test(sourceNameStr)) {
                    pushItem$1(matchedRegexpStrings, regexpStr);
                }
            });
            // parallel get hit key by matched regexps.
            await PromiseCls.all(mapItem$1(matchedRegexpStrings, async (regexpString) => {
                const hitSourceRegexpString = hitSourceRegexpCacheKey(regexpString);
                sourceTargetKeyMap[hitSourceRegexpString] = await cacheAdapter.get(hitSourceRegexpString);
            }));
        }
    }
    const removeWithTargetKey = async (targetKey) => {
        try {
            await cacheAdapter.remove(targetKey);
            // loop sourceTargetKeyMap and remove this key to prevent unnecessary cost of IO.
            for (const sourceKey in sourceTargetKeyMap) {
                const targetKeys = sourceTargetKeyMap[sourceKey];
                if (targetKeys) {
                    deleteAttr(targetKeys, targetKey);
                }
            }
        }
        catch (error) {
            // the try-catch is used to prevent throwing error, cause throwing error in `Promise.all` below.
        }
    };
    // now let's start to delete target caches.
    // and filter the finished keys.
    const accessedKeys = {};
    await PromiseCls.all(mapItem$1(objectKeys(sourceTargetKeyMap), async (sourceKey) => {
        const targetKeys = sourceTargetKeyMap[sourceKey];
        if (targetKeys) {
            const removingPromises = [];
            for (const key in targetKeys) {
                if (!accessedKeys[key]) {
                    addItem(accessedKeys, key);
                    pushItem$1(removingPromises, removeWithTargetKey(key));
                }
            }
            await PromiseCls.all(removingPromises);
        }
    }));
    // update source key if there is still has keys.
    // remove source key if its keys is empty.
    const unifiedHitSourceRegexpChannelLen = len(unifiedHitSourceRegexpChannel || []);
    await PromiseCls.all(mapItem$1(objectKeys(sourceTargetKeyMap), async (sourceKey) => {
        const targetKeys = sourceTargetKeyMap[sourceKey];
        if (targetKeys) {
            if (len(objectKeys(targetKeys))) {
                await cacheAdapter.set(sourceKey, targetKeys);
            }
            else {
                await cacheAdapter.remove(sourceKey);
                // if this is a regexped key, need to remove it from unified regexp channel.
                if (sourceKey.includes(hitSourceRegexpPrefix) && unifiedHitSourceRegexpChannel) {
                    unifiedHitSourceRegexpChannel = filterItem$1(unifiedHitSourceRegexpChannel, rawRegexpStr => hitSourceRegexpCacheKey(rawRegexpStr) !== sourceKey);
                }
            }
        }
    }));
    // update unified hit source regexp channel if its length was changed.
    if (unifiedHitSourceRegexpChannelLen !== len(unifiedHitSourceRegexpChannel || [])) {
        await cacheAdapter.set(unifiedHitSourceRegexpCacheKey, unifiedHitSourceRegexpChannel);
    }
};

var cloneMethod = (methodInstance) => {
    const { data, config } = methodInstance;
    const newConfig = { ...config };
    const { headers = {}, params = {} } = newConfig;
    const ctx = getContext(methodInstance);
    newConfig.headers = { ...headers };
    newConfig.params = { ...params };
    const newMethod = newInstance((Method), methodInstance.type, ctx, methodInstance.url, newConfig, data);
    return objAssign(newMethod, {
        ...methodInstance,
        config: newConfig
    });
};

/*
 * 以下三个函数中的matcher为Method实例匹配器，它分为3种情况：
 * 1. 如果matcher为Method实例，则清空该Method实例缓存
 * 2. 如果matcher为字符串或正则，则清空所有符合条件的Method实例缓存
 * 3. 如果未传入matcher，则会清空所有缓存
 */
/**
 * 查询缓存
 * @param matcher Method实例匹配器
 * @returns 缓存数据，未查到时返回undefined
 */
const queryCache = async (matcher, { policy = 'all' } = {}) => {
    // if key exists, that means it's a method instance.
    if (matcher && matcher.key) {
        const { id, l1Cache, l2Cache } = getContext(matcher);
        const methodKey = getMethodInternalKey(matcher);
        const { f: cacheFor, c: controlled, s: store, e: expireMilliseconds, t: tag } = getLocalCacheConfigParam(matcher);
        // if it's controlled cache, it will return the result of cacheFor function.
        if (controlled) {
            return cacheFor();
        }
        let cachedData = policy !== 'l2' ? await getWithCacheAdapter(id, methodKey, l1Cache) : undefinedValue;
        if (policy === 'l2') {
            cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);
        }
        else if (policy === 'all' && !cachedData) {
            if (store && expireMilliseconds(STORAGE_RESTORE) > getTime()) {
                cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);
            }
        }
        return cachedData;
    }
};
/**
 * 手动设置缓存响应数据，如果对应的methodInstance设置了持久化存储，则还会去检出持久化存储中的缓存
 * @param matcher Method实例匹配器
 * @param data 缓存数据
 */
const setCache = async (matcher, dataOrUpdater, { policy = 'all' } = {}) => {
    const methodInstances = isArray(matcher) ? matcher : [matcher];
    const batchPromises = methodInstances.map(async (methodInstance) => {
        const { hitSource } = methodInstance;
        const { id, l1Cache, l2Cache } = getContext(methodInstance);
        const methodKey = getMethodInternalKey(methodInstance);
        const { e: expireMilliseconds, s: toStore, t: tag, c: controlled } = getLocalCacheConfigParam(methodInstance);
        // don't set cache when it's controlled cache.
        if (controlled) {
            return;
        }
        let data = dataOrUpdater;
        if (isFn(dataOrUpdater)) {
            let cachedData = policy !== 'l2' ? await getWithCacheAdapter(id, methodKey, l1Cache) : undefinedValue;
            if (policy === 'l2' ||
                (policy === 'all' && !cachedData && toStore && expireMilliseconds(STORAGE_RESTORE) > getTime())) {
                cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);
            }
            data = dataOrUpdater(cachedData);
            if (data === undefinedValue) {
                return;
            }
        }
        return PromiseCls.all([
            policy !== 'l2' && setWithCacheAdapter(id, methodKey, data, expireMilliseconds(MEMORY), l1Cache, hitSource),
            policy === 'l2' || (policy === 'all' && toStore)
                ? setWithCacheAdapter(id, methodKey, data, expireMilliseconds(STORAGE_RESTORE), l2Cache, hitSource, tag)
                : undefinedValue
        ]);
    });
    return PromiseCls.all(batchPromises);
};
/**
 * 失效缓存
 * @param matcher Method实例匹配器
 */
const invalidateCache = async (matcher) => {
    if (!matcher) {
        await PromiseCls.all([clearWithCacheAdapter(usingL1CacheAdapters), clearWithCacheAdapter(usingL2CacheAdapters)]);
        return;
    }
    const methodInstances = isArray(matcher) ? matcher : [matcher];
    const batchPromises = methodInstances.map(methodInstance => {
        const { id, l1Cache, l2Cache } = getContext(methodInstance);
        const { c: controlled } = getLocalCacheConfigParam(methodInstance);
        // don't invalidate cache when it's controlled cache.
        if (controlled) {
            return;
        }
        const methodKey = getMethodInternalKey(methodInstance);
        return PromiseCls.all([
            removeWithCacheAdapter(id, methodKey, l1Cache),
            removeWithCacheAdapter(id, methodKey, l2Cache)
        ]);
    });
    await PromiseCls.all(batchPromises);
};
/**
 * hit(invalidate) target caches by source method
 * this is the implementation of auto invalidate cache
 * @param sourceMethod source method instance
 */
const hitCacheBySource = async (sourceMethod) => {
    // 查找hit target cache，让它的缓存失效
    // 通过全局配置`autoHitCache`来控制自动缓存失效范围
    const { autoHitCache } = globalConfigMap;
    const { l1Cache, l2Cache } = getContext(sourceMethod);
    const sourceKey = getMethodInternalKey(sourceMethod);
    const { name: sourceName } = getConfig(sourceMethod);
    const cacheAdaptersInvolved = {
        global: [...usingL1CacheAdapters, ...usingL2CacheAdapters],
        self: [l1Cache, l2Cache],
        close: []
    }[autoHitCache];
    if (cacheAdaptersInvolved && len(cacheAdaptersInvolved)) {
        await PromiseCls.all(mapItem$1(cacheAdaptersInvolved, involvedCacheAdapter => hitTargetCacheWithCacheAdapter(sourceKey, sourceName, involvedCacheAdapter)));
    }
};

const adapterReturnMap = {};
/**
 * 构建完整的url
 * @param base baseURL
 * @param url 路径
 * @param params url参数
 * @returns 完整的url
 */
const buildCompletedURL = (baseURL, url, params) => {
    // baseURL如果以/结尾，则去掉/
    baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;
    // 如果不是/或http协议开头的，则需要添加/
    // Compatible with some RESTful usage
    // fix: https://github.com/alovajs/alova/issues/382
    if (url !== '') {
        url = url.match(/^(\/|https?:\/\/)/) ? url : `/${url}`;
    }
    const completeURL = baseURL + url;
    // 将params对象转换为get字符串
    // 过滤掉值为undefined的
    const paramsStr = mapItem$1(filterItem$1(objectKeys(params), key => params[key] !== undefinedValue), key => `${key}=${params[key]}`).join('&');
    // 将get参数拼接到url后面，注意url可能已存在参数
    return paramsStr
        ? +completeURL.includes('?')
            ? `${completeURL}&${paramsStr}`
            : `${completeURL}?${paramsStr}`
        : completeURL;
};
/**
 * 实际的请求函数
 * @param method 请求方法对象
 * @param forceRequest 忽略缓存
 * @returns 响应数据
 */
function sendRequest(methodInstance, forceRequest) {
    let fromCache = trueValue;
    let requestAdapterCtrlsPromiseResolveFn;
    const requestAdapterCtrlsPromise = newInstance(PromiseCls, resolve => {
        requestAdapterCtrlsPromiseResolveFn = resolve;
    });
    const response = async () => {
        const { beforeRequest = noop, responded, requestAdapter, cacheLogger } = getOptions(methodInstance);
        const methodKey = getMethodInternalKey(methodInstance);
        const { s: toStorage, t: tag, m: cacheMode, e: expireMilliseconds } = getLocalCacheConfigParam(methodInstance);
        const { id, l1Cache, l2Cache, snapshots } = getContext(methodInstance);
        // 获取受控缓存或非受控缓存
        const { cacheFor } = getConfig(methodInstance);
        const { hitSource: methodHitSource } = methodInstance;
        // 如果当前method设置了受控缓存，则看是否有自定义的数据
        let cachedResponse = await (isFn(cacheFor)
            ? cacheFor()
            : // 如果是强制请求的，则跳过从缓存中获取的步骤
                // 否则判断是否使用缓存数据
                forceRequest
                    ? undefinedValue
                    : getWithCacheAdapter(id, methodKey, l1Cache));
        // 如果是STORAGE_RESTORE模式，且缓存没有数据时，则需要将持久化数据恢复到缓存中，过期时间要使用缓存的
        if (cacheMode === STORAGE_RESTORE && !cachedResponse) {
            const rawL2CacheData = await getRawWithCacheAdapter(id, methodKey, l2Cache, tag);
            if (rawL2CacheData) {
                const [l2Response, l2ExpireMilliseconds] = rawL2CacheData;
                await setWithCacheAdapter(id, methodKey, l2Response, l2ExpireMilliseconds, l1Cache, methodHitSource);
                cachedResponse = l2Response;
            }
        }
        // 克隆method作为参数传给beforeRequest，防止多次使用原method实例请求时产生副作用
        // 放在` let cachedResponse = await ...`之后，解决在method.send中先赋值promise给method实例的问题，否则在clonedMethod中promise为undefined
        const clonedMethod = cloneMethod(methodInstance);
        // 发送请求前调用钩子函数
        // beforeRequest支持同步函数和异步函数
        await beforeRequest(clonedMethod);
        const { baseURL, url: newUrl, type, data } = clonedMethod;
        const { params = {}, headers = {}, transform = $self, shareRequest } = getConfig(clonedMethod);
        const namespacedAdapterReturnMap = (adapterReturnMap[id] = adapterReturnMap[id] || {});
        let requestAdapterCtrls = namespacedAdapterReturnMap[methodKey];
        let responseSuccessHandler = $self;
        let responseErrorHandler = undefinedValue;
        let responseCompleteHandler = noop;
        // uniform handler of onSuccess, onError, onComplete
        if (isFn(responded)) {
            responseSuccessHandler = responded;
        }
        else if (isPlainObject(responded)) {
            const { onSuccess: successHandler, onError: errorHandler, onComplete: completeHandler } = responded;
            responseSuccessHandler = isFn(successHandler) ? successHandler : responseSuccessHandler;
            responseErrorHandler = isFn(errorHandler) ? errorHandler : responseErrorHandler;
            responseCompleteHandler = isFn(completeHandler) ? completeHandler : responseCompleteHandler;
        }
        // 如果没有缓存则发起请求
        if (cachedResponse !== undefinedValue) {
            requestAdapterCtrlsPromiseResolveFn(); // 遇到缓存将不传入ctrls
            // 打印缓存日志
            sloughFunction(cacheLogger, defaultCacheLogger)(cachedResponse, clonedMethod, cacheMode, tag);
            responseCompleteHandler(clonedMethod);
            return cachedResponse;
        }
        fromCache = falseValue;
        if (!shareRequest || !requestAdapterCtrls) {
            // 请求数据
            const ctrls = requestAdapter({
                url: buildCompletedURL(baseURL, newUrl, params),
                type,
                data,
                headers
            }, clonedMethod);
            requestAdapterCtrls = namespacedAdapterReturnMap[methodKey] = ctrls;
        }
        // 将requestAdapterCtrls传到promise中供onDownload、onUpload及abort中使用
        requestAdapterCtrlsPromiseResolveFn(requestAdapterCtrls);
        /**
         * 处理响应任务，失败时不缓存数据
         * @param responsePromise 响应promise实例
         * @param responseHeaders 请求头
         * @param callInSuccess 是否在成功回调中调用
         * @returns 处理后的response
         */
        const handleResponseTask = async (handlerReturns, responseHeaders, callInSuccess = trueValue) => {
            const responseData = await handlerReturns;
            const transformedData = await transform(responseData, responseHeaders || {});
            snapshots.save(methodInstance);
            // 即使缓存操作失败，也正常返回响应结构，避免因缓存操作问题导致请求错误
            // 缓存操作结果，可通过`cacheAdapter.emitter.on('success' | 'fail', event => {})`监听获取
            try {
                // 自动失效缓存
                await hitCacheBySource(clonedMethod);
            }
            catch (error) { }
            // 当requestBody为特殊数据时不保存缓存
            // 原因1：特殊数据一般是提交特殊数据，需要和服务端交互
            // 原因2：特殊数据不便于生成缓存key
            const requestBody = clonedMethod.data;
            const toCache = !requestBody || !isSpecialRequestBody(requestBody);
            // 使用响应后最新的过期时间来缓存数据，避免因响应时间过长导致过期时间流失的问题
            if (toCache && callInSuccess) {
                try {
                    await PromiseCls.all([
                        setWithCacheAdapter(id, methodKey, transformedData, expireMilliseconds(MEMORY), l1Cache, methodHitSource),
                        toStorage &&
                            setWithCacheAdapter(id, methodKey, transformedData, expireMilliseconds(STORAGE_RESTORE), l2Cache, methodHitSource, tag)
                    ]);
                }
                catch (error) { }
            }
            return transformedData;
        };
        return promiseFinally(promiseThen(PromiseCls.all([requestAdapterCtrls.response(), requestAdapterCtrls.headers()]), ([rawResponse, rawHeaders]) => {
            // 无论请求成功、失败，都需要首先移除共享的请求
            deleteAttr(namespacedAdapterReturnMap, methodKey);
            return handleResponseTask(responseSuccessHandler(rawResponse, clonedMethod), rawHeaders);
        }, (error) => {
            // 无论请求成功、失败，都需要首先移除共享的请求
            deleteAttr(namespacedAdapterReturnMap, methodKey);
            return isFn(responseErrorHandler)
                ? // 响应错误时，如果未抛出错误也将会处理响应成功的流程，但不缓存数据
                    handleResponseTask(responseErrorHandler(error, clonedMethod), undefinedValue, falseValue)
                : promiseReject(error);
        }), () => {
            responseCompleteHandler(clonedMethod);
        });
    };
    return {
        // 请求中断函数
        abort: () => {
            promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.abort());
        },
        onDownload: (handler) => {
            promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.onDownload && requestAdapterCtrls.onDownload(handler));
        },
        onUpload: (handler) => {
            promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.onUpload && requestAdapterCtrls.onUpload(handler));
        },
        response,
        fromCache: () => fromCache
    };
}

const offEventCallback = (offHandler, handlers) => () => {
    const index = handlers.indexOf(offHandler);
    index >= 0 && handlers.splice(index, 1);
};
class Method {
    constructor(type, context, url, config, data) {
        this.dhs = [];
        this.uhs = [];
        this.fromCache = undefinedValue;
        const abortRequest = () => {
            abortRequest.a();
        };
        abortRequest.a = noop;
        const instance = this;
        const contextOptions = getContextOptions(context);
        instance.abort = abortRequest;
        instance.baseURL = contextOptions.baseURL || '';
        instance.url = url;
        instance.type = type;
        instance.context = context;
        // 将请求相关的全局配置合并到Method对象中
        const contextConcatConfig = {};
        const mergedLocalCacheKey = 'cacheFor';
        const globalLocalCache = isPlainObject(contextOptions[mergedLocalCacheKey])
            ? contextOptions[mergedLocalCacheKey][type]
            : undefinedValue;
        const hitSource = config && config.hitSource;
        // 合并参数
        forEach(['timeout', 'shareRequest'], mergedKey => {
            if (contextOptions[mergedKey] !== undefinedValue) {
                contextConcatConfig[mergedKey] = contextOptions[mergedKey];
            }
        });
        // 合并localCache
        if (globalLocalCache !== undefinedValue) {
            contextConcatConfig[mergedLocalCacheKey] = globalLocalCache;
        }
        // 将hitSource统一处理成数组，且当有method实例时将它们转换为methodKey
        if (hitSource) {
            instance.hitSource = mapItem$1(isArray(hitSource) ? hitSource : [hitSource], sourceItem => instanceOf(sourceItem, Method) ? getMethodInternalKey(sourceItem) : sourceItem);
            deleteAttr(config, 'hitSource');
        }
        instance.config = {
            ...contextConcatConfig,
            headers: {},
            params: {},
            ...(config || {})
        };
        instance.data = data;
        instance.meta = config ? config.meta : instance.meta;
        // 在外部需要使用原始的key，而不是实时生成key
        // 原因是，method的参数可能传入引用类型值，但引用类型值在外部改变时，实时生成的key也随之改变，因此使用最开始的key更准确
        instance.key = instance.generateKey();
    }
    /**
     * 绑定下载进度回调函数
     * @param progressHandler 下载进度回调函数
     * @version 2.17.0
     * @return 解绑函数
     */
    onDownload(downloadHandler) {
        pushItem$1(this.dhs, downloadHandler);
        return offEventCallback(downloadHandler, this.dhs);
    }
    /**
     * 绑定上传进度回调函数
     * @param progressHandler 上传进度回调函数
     * @version 2.17.0
     * @return 解绑函数
     */
    onUpload(uploadHandler) {
        pushItem$1(this.uhs, uploadHandler);
        return offEventCallback(uploadHandler, this.uhs);
    }
    /**
     * 通过method实例发送请求，返回promise对象
     */
    send(forceRequest = falseValue) {
        const instance = this;
        const { response, onDownload, onUpload, abort, fromCache } = sendRequest(instance, forceRequest);
        len(instance.dhs) > 0 &&
            onDownload((loaded, total) => forEach(instance.dhs, handler => handler({ loaded, total })));
        len(instance.uhs) > 0 && onUpload((loaded, total) => forEach(instance.uhs, handler => handler({ loaded, total })));
        // 每次请求时将中断函数绑定给method实例，使用者也可通过methodInstance.abort()来中断当前请求
        instance.abort.a = abort;
        instance.fromCache = undefinedValue;
        instance.promise = promiseThen(response(), r => {
            instance.fromCache = fromCache();
            return r;
        });
        return instance.promise;
    }
    /**
     * 设置方法名称，如果已有名称将被覆盖
     * @param name 方法名称
     */
    setName(name) {
        getConfig(this).name = name;
    }
    generateKey() {
        return key(this);
    }
    /**
     * 绑定resolve和/或reject Promise的callback
     * @param onfulfilled resolve Promise时要执行的回调
     * @param onrejected 当Promise被reject时要执行的回调
     * @returns 返回一个Promise，用于执行任何回调
     */
    then(onfulfilled, onrejected) {
        return promiseThen(this.send(), onfulfilled, onrejected);
    }
    /**
     * 绑定一个仅用于reject Promise的回调
     * @param onrejected 当Promise被reject时要执行的回调
     * @returns 返回一个完成回调的Promise
     */
    catch(onrejected) {
        return promiseCatch(this.send(), onrejected);
    }
    /**
     * 绑定一个回调，该回调在Promise结算（resolve或reject）时调用
     * @param onfinally Promise结算（resolve或reject）时执行的回调。
     * @return 返回一个完成回调的Promise。
     */
    finally(onfinally) {
        return promiseFinally(this.send(), onfinally);
    }
}

// import { get } from '@alova/shared';
/**
 * 自定义断言函数，表达式为false时抛出错误
 * @param expression 判断表达式，true或false
 * @param msg 断言消息
 */
const myAssert = createAssert();

/**
  * @alova/shared 1.0.5 (undefined)
  * Document undefined
  * Copyright 2024 Scott Hu. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
*/

const undefStr = 'undefined';
const pushItem = (ary, ...item) => ary.push(...item);
const mapItem = (ary, callbackfn) => ary.map(callbackfn);
const filterItem = (ary, predicate) => ary.filter(predicate);
// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
// 因此使用服务端独有的 process.cwd 函数作为判断依据
typeof window === undefStr &&
    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);

const createEventManager = () => {
    const eventMap = {};
    return {
        eventMap,
        on(type, handler) {
            const eventTypeItem = (eventMap[type] = eventMap[type] || []);
            pushItem(eventTypeItem, handler);
            // return the off function
            return () => {
                eventMap[type] = filterItem(eventTypeItem, item => item !== handler);
            };
        },
        off(type, handler) {
            const handlers = eventMap[type];
            if (!handlers) {
                return;
            }
            if (handler) {
                const index = handlers.indexOf(handler);
                index > -1 && handlers.splice(index, 1);
            }
            else {
                delete eventMap[type];
            }
        },
        emit(type, event) {
            const handlers = eventMap[type] || [];
            return mapItem(handlers, handler => handler(event));
        }
    };
};

// local storage will not fail the operation.
const EVENT_SUCCESS_KEY = 'success';
const memoryAdapter = () => {
    let l1Cache = {};
    const l1CacheEmitter = createEventManager();
    const adapter = {
        set(key, value) {
            l1Cache[key] = value;
            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'set', key, value, container: l1Cache });
        },
        get: key => {
            const value = l1Cache[key];
            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'get', key, value, container: l1Cache });
            return value;
        },
        remove(key) {
            deleteAttr(l1Cache, key);
            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'remove', key, container: l1Cache });
        },
        clear: () => {
            l1Cache = {};
            l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'clear', key: '', container: l1Cache });
        },
        emitter: l1CacheEmitter
    };
    return adapter;
};
const // delay get localStorage by function, and avoid erroring at initialization
storage = () => {
    myAssert(typeof localStorage !== 'undefined', 'l2Cache is not defined.');
    return localStorage;
};
const localStorageAdapter = () => {
    const l2CacheEmitter = createEventManager();
    const adapter = {
        set: (key, value) => {
            storage().setItem(key, JSONStringify(value));
            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'set', key, value, container: storage() });
        },
        get: key => {
            const data = storage().getItem(key);
            const value = data ? JSONParse(data) : data;
            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'get', key, value, container: storage() });
            return value;
        },
        remove: key => {
            storage().removeItem(key);
            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'remove', key, container: storage() });
        },
        clear: () => {
            storage().clear();
            l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'clear', key: '', container: storage() });
        },
        emitter: l2CacheEmitter
    };
    return adapter;
};

const SetCls = Set;
class MethodSnapshotContainer {
    constructor(capacity) {
        /**
         * method实例快照集合，发送过请求的method实例将会被保存
         */
        this.records = {};
        this.occupy = 0;
        myAssert(capacity >= 0, 'expected snapshots limit to be >= 0');
        this.capacity = capacity;
    }
    /**
     * 保存method实例快照
     * @param methodInstance method实例
     */
    save(methodInstance) {
        const { name } = getConfig(methodInstance);
        const { records, occupy, capacity } = this;
        if (name && occupy < capacity) {
            // 以method的name为key，将method实例保存到快照中
            const targetSnapshots = (records[name] = records[name] || newInstance(SetCls));
            targetSnapshots.add(methodInstance);
            // 统计数量
            this.occupy += 1;
        }
    }
    /**
     * 获取Method实例快照，它将根据matcher来筛选出对应的Method实例
     * @param matcher 匹配的快照名称，可以是字符串或正则表达式、或带过滤函数的对象
     * @returns 匹配到的Method实例快照数组
     */
    match(matcher, matchAll = true) {
        // 将filter参数统一解构为nameMatcher和matchHandler
        let nameString;
        let nameReg;
        let matchHandler;
        let nameMatcher = matcher;
        if (isPlainObject(matcher)) {
            nameMatcher = matcher.name;
            matchHandler = matcher.filter;
        }
        if (instanceOf(nameMatcher, RegExpCls)) {
            nameReg = nameMatcher;
        }
        else if (isString(nameMatcher)) {
            nameString = nameMatcher;
        }
        const { records } = this;
        // 通过解构的nameMatcher和filterHandler，获取对应的Method实例快照
        let matches = newInstance((SetCls));
        // 如果有提供namespace参数则只在这个namespace中查找，否则在所有缓存数据中查找
        if (nameString) {
            matches = records[nameString] || matches;
        }
        else if (nameReg) {
            forEach(filterItem$1(objectKeys(records), methodName => nameReg.test(methodName)), methodName => {
                records[methodName].forEach(method => matches.add(method));
            });
        }
        const fromMatchesArray = isFn(matchHandler) ? filterItem$1([...matches], matchHandler) : [...matches];
        return (matchAll ? fromMatchesArray : fromMatchesArray[0]);
    }
}

const typeGet = 'GET';
const typeHead = 'HEAD';
const typePost = 'POST';
const typePut = 'PUT';
const typePatch = 'PATCH';
const typeDelete = 'DELETE';
const typeOptions = 'OPTIONS';
const defaultAlovaOptions = {
    /**
     * GET请求默认缓存5分钟（300000毫秒），其他请求默认不缓存
     */
    cacheFor: {
        [typeGet]: 300000
    },
    /**
     * 共享请求默认为true
     */
    shareRequest: trueValue,
    /**
     * method快照数量，默认为1000
     */
    snapshots: 1000
};
let idCount = 0;
class Alova {
    constructor(options) {
        var _a, _b;
        const instance = this;
        instance.id = (options.id || (idCount += 1)).toString();
        // 如果storage未指定，则默认使用localStorage
        instance.l1Cache = options.l1Cache || memoryAdapter();
        instance.l2Cache = options.l2Cache || localStorageAdapter();
        // 合并默认options
        instance.options = {
            ...defaultAlovaOptions,
            ...options
        };
        instance.snapshots = newInstance((MethodSnapshotContainer), (_b = (_a = options.snapshots) !== null && _a !== void 0 ? _a : defaultAlovaOptions.snapshots) !== null && _b !== void 0 ? _b : 0);
    }
    Get(url, config) {
        return newInstance((Method), typeGet, this, url, config);
    }
    Post(url, data, config) {
        return newInstance((Method), typePost, this, url, config, data);
    }
    Delete(url, data, config) {
        return newInstance((Method), typeDelete, this, url, config, data);
    }
    Put(url, data, config) {
        return newInstance((Method), typePut, this, url, config, data);
    }
    Head(url, config) {
        return newInstance((Method), typeHead, this, url, config);
    }
    Patch(url, data, config) {
        return newInstance((Method), typePatch, this, url, config, data);
    }
    Options(url, config) {
        return newInstance((Method), typeOptions, this, url, config);
    }
}
let boundStatesHook = undefinedValue;
const usingL1CacheAdapters = [];
const usingL2CacheAdapters = [];
/**
 * create an alova instance.
 * @param options alova configuration.
 * @returns alova instance.
 */
const createAlova = (options) => {
    const alovaInstance = newInstance((Alova), options);
    const newStatesHook = alovaInstance.options.statesHook;
    if (boundStatesHook) {
        myAssert(boundStatesHook === newStatesHook, 'expected to use the same `statesHook`');
    }
    boundStatesHook = newStatesHook;
    const { l1Cache, l2Cache } = alovaInstance;
    !usingL1CacheAdapters.includes(l1Cache) && pushItem$1(usingL1CacheAdapters, l1Cache);
    !usingL2CacheAdapters.includes(l2Cache) && pushItem$1(usingL2CacheAdapters, l2Cache);
    return alovaInstance;
};

const promiseStatesHook = () => {
    myAssert(!!boundStatesHook, `\`statesHook\` is not set in alova instance`);
    return boundStatesHook;
};

export { Method, createAlova, globalConfig, globalConfigMap, hitCacheBySource, invalidateCache, promiseStatesHook, queryCache, setCache };
