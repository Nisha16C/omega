!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("alova")):"function"==typeof define&&define.amd?define(["exports","alova"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).AlovaClientHook={},e.alova)}(this,(function(e,t){"use strict";class r{constructor(e,t,r,n){this.s=e,this.k=t,this.$dhy=r,this.$exp=n}get v(){return this.$dhy(this.s)}get e(){return this.$exp(this.s)}}class n extends r{constructor(e,t,r,n,o){super(e,t,r,n),this.$upd=o}set v(e){this.$upd(this.s,e)}get v(){return super.v}}const o="undefined",s=Promise,a=Object,i=void 0,c=!0,u=!1,l=e=>a.keys(e),d=(e,t)=>e.forEach(t),f=(e,...t)=>e.push(...t),m=(e,t)=>e.map(t),h=e=>typeof e,v=(e,t)=>e.includes(t);typeof window===o&&typeof process!==o&&process.cwd;const p="memory",g=()=>{},y=e=>e,w=e=>"function"===h(e),b=e=>"number"===h(e)&&!Number.isNaN(e),S=e=>"string"===h(e),x=e=>null!==e&&"object"===h(e),E=e=>a.prototype.toString.call(e),k=e=>"[object Object]"===E(e),R=(e,t)=>e instanceof t,M=e=>e?e.getTime():Date.now(),_=e=>e.context,j=e=>e.config,P=()=>{const e=(new Date).getTime();return Math.floor(Math.random()*e).toString(36)},C=e=>e.key,O=(e,t,r=[])=>{const n=w(e)?e(...r):e;return t(!!n.key,"hook handler must be a method instance or a function that returns method instance"),n},q=(e,...t)=>a.assign(e,...t),T=(e,...t)=>{const r={};for(const n in e)t.includes(n)||(r[n]=e[n]);return r};function D(){let e,t;return{promise:new Promise(((r,n)=>{e=r,t=n})),resolve:e,reject:t}}const F=e=>{const{cacheFor:t}=j(e);let r=p,n=()=>0,o=u,s=i;const a=w(t);if(!a){let a=t;if(k(t)){const{mode:e=p,expire:n,tag:c}=t||{};r=e,o="restore"===e,s=c?c.toString():i,a=n}n=t=>{return r=w(a)?a({method:e,mode:t}):a,b(r)?M()+r:M(r||i);var r}}return{f:t,c:a,e:n,m:r,s:o,t:s}},H=(e,...t)=>new e(...t),$=(e,t=[])=>w(e)?e(...t):e,L=(e=u)=>{const t=[];let r=i,n=!1;return{addQueue:o=>H(s,((s,a)=>{f(t,(()=>{return t=o(),r=s,n=t=>{e?s(i):a(t)},t.then(r,n);var t,r,n})),n||(async()=>{for(n=!0;t.length>0;){const e=t.shift();e&&await e()}r&&r(),n=!1})()})),onComplete:e=>{r=e}}},Q=(e,t,r=c,n,o)=>{const s=()=>{o&&n&&(e=t(e,n,o))!==o[n]&&(o[n]=e)};if(r&&s(),x(e))for(const n in e)R(e,String)||Q(e[n],t,r,n,e);return!r&&s(),e};function A(e,t={trackedKeys:{},bindError:u}){const o=t=>e.ref?e.ref(t):{current:t};t=o(t).current;const s=r=>(e.export||y)(r,t),i=t=>{if(!w(e.memorize))return t;const r=e.memorize(t);return r.memorized=!0,r},{dehydrate:h}=e,p=(r,n,o)=>r!==h(n,o,t)&&t.trackedKeys[o]&&e.update(r,n,o,t),b=e=>m(e,(e=>R(e,r)?e.e:e)),S=[],x={};return{create:(r,o)=>(f(S,o),H(n,e.create(r,o,t),o,(e=>h(e,o,t)),s,((e,t)=>p(t,e,o)))),computed:(n,o,a)=>(d(o,(e=>{e.k&&(x[e.k]=!0)})),H(r,e.computed(n,b(o),a,t),a,(e=>h(e,a,t)),s)),effectRequest:r=>e.effectRequest(r,t),ref:o,watch:(r,n)=>e.watch(b(r),n,t),onMounted:r=>e.onMounted(r,t),onUnmounted:r=>e.onUnmounted(r,t),__referingObj:t,exposeProvider:e=>{const n={},o={};for(const s in e){const u=e[s];if(w(u))n[s]=s.startsWith("on")?(...e)=>(u(...e),m):u.memorized?u:i(u);else{const e=R(u,r);e&&(o[s]=u.s),a.defineProperty(n,s,{get:()=>(t.trackedKeys[s]=c,e?u.e:u),set:g,enumerable:c,configurable:c})}}const{update:s,__proxyState:d}=n;t.trackedKeys={...x},t.bindError=u;const f={__referingObj:t,update:i((e=>{l(e).forEach((t=>{v(S,t)?p(e[t],o[t],t):t in n&&w(s)&&s({[t]:e[t]})}))})),__proxyState:i((n=>v(S,n)&&R(e[n],r)?(t.trackedKeys[n]=c,e[n]):d(n)))},m=q(n,f);return m},objectify:(e,t)=>e.reduce(((e,r)=>(e[r.k]=t?r[t]:r,e)),{}),transformState2Proxy:(e,r)=>H(n,e,r,(e=>h(e,r,t)),s,((e,t)=>p(t,e,r)))}}const z=(e,t)=>"$a."+e+t,N=(e,t)=>{let{startQuiver:r,endQuiver:n}=e;const{delay:o,multiplier:s=1}=e;let a=(o||0)*s**(t-1);return(r||n)&&(r=r||0,n=n||1,a+=a*r+Math.random()*a*(n-r),a=Math.floor(a)),a},B="undefined",K=Promise,U=e=>K.resolve(e),G=Object,W=RegExp,V=void 0,I=null,J=!0,X=!1,Y=(e,t,r)=>e.then(t,r),Z=(e,t)=>e.catch(t),ee=(e,t=0)=>setTimeout(e,t),te=e=>G.keys(e),re=(e,t)=>e.forEach(t),ne=(e,...t)=>e.push(...t),oe=(e,t)=>e.map(t),se=(e,t)=>e.filter(t),ae=e=>e.shift(),ie=(e,t,r=0,...n)=>e.splice(t,r,...n),ce=e=>e.length,ue=e=>Array.isArray(e),le=(e,t)=>delete e[t],de=(e,t)=>e.test(t),fe=(e,t)=>e.includes(t),me=(e,t=X)=>({value:e,writable:t}),he=(e,t,r,n=X)=>G.defineProperty(e,t,n?r:me(r,X));typeof window===B&&typeof process!==B&&process.cwd;const ve={authRole:null},pe={authRole:"login"},ge={authRole:"logout"},ye={authRole:"refreshToken"},we=({meta:e},t)=>{if(k(e))for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r)){const n=t[r];if(R(n,RegExp)?n.test(e[r]):e[r]===n)return J}return X},be=(e,t)=>H(K,(r=>{ne(t,{method:e,resolve:r})})),Se=(e,t,r,n)=>{if(we(e,(null==t?void 0:t.metaMatches)||r)){return(w(t)?t:k(t)&&w(t.handler)?t.handler:g)(n,e)}},xe=async(e,t,r,n,o,s)=>{const a=ce(n)>=2;let i=null==o?void 0:o.isExpired(...n);if(R(i,K)&&(i=await i),i)try{let i=J;if(a&&s&&(i=X,await be(e,t)),i&&(r(J),await(null==o?void 0:o.handler(...n)),r(X),re(t,(({resolve:e})=>e()))),a){const{config:t}=e,r=t.transform;t.transform=V;const n=await e;return t.transform=r,n}}finally{r(X),ie(t,0,ce(t))}},Ee=e=>{let t=V,r=V,n=V;if(w(e))t=e;else if(k(e)){const{onSuccess:o,onError:s,onComplete:a}=e;t=w(o)?o:t,r=w(s)?s:r,n=w(a)?a:n}return{onSuccess:t,onError:r,onComplete:n}},ke="undefined";typeof window===ke&&typeof process!==ke&&process.cwd;class Re extends Error{constructor(e,t,r){super(t+(r?`\n\nFor detailed: https://alova.js.org/error#${r}`:"")),this.name=`[alova${e?`/${e}`:""}]`}}const Me=(e="")=>(t,r,n)=>{if(!t)throw((e,...t)=>new e(...t))(Re,e,r,n)},_e=Me(""),je=Me("useRequest"),Pe=Me("useWatcher"),Ce=Me("useFetcher"),Oe=e=>({1:je,2:Pe,3:Ce}[e]),qe=(e,r)=>e(R(r,t.Method),"expected a method instance."),Te=e=>{throw e};const De=(e,t)=>{let r=I;return function(...n){const o=e.bind(this,...n),s=b(t)?t:t(...n);r&&(e=>{clearTimeout(e)})(r),s>0?r=ee(o,s):o()}},Fe=(e,r=[])=>{const n=w(e)?e(...r):e;return Me("scene")(R(n,t.Method),"hook handler must be a method instance or a function that returns method instance"),n},He=(e,t)=>{const r={};for(const n in e)r[n]=t(e[n],n,e);return r},$e="undefined";typeof window===$e&&typeof process!==$e&&process.cwd;const Le=()=>{const e={};return{eventMap:e,on(t,r){const n=e[t]=e[t]||[];return((e,...t)=>{e.push(...t)})(n,r),()=>{var o;e[t]=(o=e=>e!==r,n.filter(o))}},off(t,r){const n=e[t];if(n)if(r){const e=n.indexOf(r);e>-1&&n.splice(e,1)}else delete e[t]},emit(t,r){const n=e[t]||[];return o=e=>e(r),n.map(o);var o}}},Qe=(e,t)=>{const r=Le(),n=(()=>{const e=(new Date).getTime();return Math.floor(Math.random()*e).toString(36)})(),o=e((e=>r.emit(n,e)));return e=>(r.on(n,(r=>{t(e,r)})),o)},Ae="success",ze="error",Ne="complete";var Be=(e,t,r,n)=>({m:V,sf:[],rf:[],fs:{},em:r,ht:e,c:t,ro:n,ms:{}});class Ke{constructor(e,t){this.method=e,this.args=t}clone(){return{...this}}static spawn(e,t){return new Ke(e,t)}}class Ue extends Ke{constructor(e,t,r){super(e.method,e.args),this.data=t,this.fromCache=r}}class Ge extends Ke{constructor(e,t){super(e.method,e.args),this.error=t}}class We extends Ke{constructor(e,t,r,n,o){super(e.method,e.args),this.status=t,this.data=r,this.fromCache="error"!==t&&n,this.error=o}}const Ve=(e,t)=>t(),Ie={},Je=(e,t)=>(Ie[e]||{})[t]||{},Xe=(e,t,r,n)=>{(Ie[e]=Ie[e]||{})[t]={s:r,h:n}},Ye=(e,t)=>{const r=Ie[e];r&&le(r,t)};function Ze(e,r,n=[]){const o=Oe(e.ht);let s=O(r,o,n);const{fs:a,ht:i,c:c,ms:u}=e,{loading:l,data:d,error:f}=a,m=3===i,{force:h=X,middleware:v=Ve}=c,p=_(s),{id:y}=p,w=C(s),{abortLast:b=J}=c;return e.m=s,(async()=>{let p=g,S=g,x=X,E=U(V),k=g,R=g;const M=await t.queryCache(s);let _=()=>!!M,j=X;m||(S=t=>Xe(y,w,t,e),S({...a,...u}),p=()=>Ye(y,w));const P=t=>{x=J;const{force:r=h,method:o=s}=t||{},i=$(r,[H(Ke,s,n)]),c=e=>({loaded:t,total:r})=>{a[e].v={loaded:t,total:r}};s=o,ne(e.sf,S),ne(e.rf,p),j||(l.v=!!i||!M);const{downloading:u,uploading:d}=e.ro.trackedKeys;return k=u?s.onDownload(c("downloading")):k,R=d?s.onUpload(c("uploading")):R,E=s.send(i),_=()=>s.fromCache||X,E},C={method:s,cachedResponse:M,config:c,abort:()=>s.abort()},O=()=>2!==i||!b||e.m===s,q=v(m?{...C,args:n,fetch:(t,...r)=>(qe(o,t),Ze(e,t,r)),proxyStates:T(a,"data"),controlFetching(e=J){j=e}}:{...C,args:n,send:(...t)=>Ze(e,r,t),proxyStates:a,controlLoading(e=J){j=e}},P);let D=V;const F=Ke.spawn(s,n);try{const t=await q,r=t=>{if(m){if(e.c.updateState!==X){const e=Je(y,w).s;e&&(e.data.v=t)}}else O()&&(d.v=t);return O()&&(f.v=V,!j&&(l.v=X),e.em.emit(Ae,H(Ue,F,t,_())),e.em.emit(Ne,H(We,F,Ae,t,_(),V))),t};D=t!==V?r(t):x?await Y(E,r,(()=>r(V))):V,!x&&!j&&(l.v=X)}catch(t){throw O()&&(f.v=t,!j&&(l.v=X),e.em.emit(ze,H(Ge,F,t)),e.em.emit(Ne,H(We,F,ze,V,_(),t))),t}return k(),R(),D})()}const et=e=>e.current;function tt(e,r,n,o,s=X,a,i=0){var c;n={...n};const{middleware:u,__referingObj:l={trackedKeys:{},bindError:X}}=n;let d=u?X:!!s;if(s&&!u)try{const t=O(r,Oe(e)),o=_(t),s=o.l1Cache.get(z(o.id,C(t)));let a=V;if(s&&!R(s,K)){const[e,t]=s;(!t||t>M())&&(a=e)}d=!!$(null!==(c=n.force)&&void 0!==c?c:X)||!a}catch(j){}const{create:f,effectRequest:m,ref:h,objectify:v,exposeProvider:p,transformState2Proxy:g}=A(t.promiseStatesHook(),l),y={total:0,loaded:0},{managedStates:S={}}=n,x=He(S,((e,t)=>g(e,t))),E=f(w(o)?o():o,"data"),k=f(d,"loading"),j=f(V,"error"),P=f({...y},"downloading"),q=f({...y},"uploading"),T=v([E,k,j,P,q]),D=Le(),F=et(h(Be(e,n,D,l)));F.fs=T,F.em=D,F.c=n,F.ms=x;const H=a!==V,L=(e=r,t)=>Ze(F,e,t),Q=(e=l,t)=>Z(L(t),(t=>{if(!e.bindError&&!e.trackedKeys.error)throw t})),N=h(De(((e,t,r)=>Q(t,r)),(e=>b(e)?ue(i)?i[e]:i:0)));return t.globalConfigMap.ssr||m({handler:H?e=>N.current(e,l,r):()=>Q(l),removeStates:()=>re(F.rf,(e=>e())),saveStates:e=>re(F.sf,(t=>t(e))),frontStates:{...T,...x},watchingStates:a,immediate:null!=s?s:J}),p({...v([E,k,j,P,q]),abort:()=>F.m&&F.m.abort(),send:(e,t)=>L(t,e),onSuccess(e){D.on(Ae,e)},onError(e){l.bindError=J,D.on(ze,e)},onComplete(e){D.on(Ne,e)}})}function rt(e={}){const t=tt(3,g,e),{send:r}=t;return le(t,"send"),q(t,{fetch:(e,...t)=>(qe(Ce,e),r(t,e))})}function nt(e,t={}){const{immediate:r=J,initialData:n}=t,o=tt(1,e,t,n,!!r),{send:s}=o;return q(o,{send:(...e)=>s(e)})}function ot(e,t,r={}){Pe(t&&ce(t)>0,"expected at least one watching state");const{immediate:n,debounce:o=0,initialData:s}=r,a=tt(2,e,r,s,!!n,t,o),{send:i}=a;return q(a,{send:(...e)=>i(e)})}const st=(e,t)=>Me(e)(ue(t)&&ce(t)>0,"please use an array to represent serial requests"),at=(e,t,r=[])=>(e.shift(),(n,o)=>{null==t||t(n,(()=>U(V))),n.controlLoading();const s=n.proxyStates.loading;s.v=J;let a=o();for(const t of e)a=Y(a,(e=>{const o=t(e,...n.args);return ne(r,o),o.send()}));return a.finally((()=>{s.v=X}))});const it="valueOf",ct="default",ut="silent";let lt;const dt=e=>{lt=e};let ft;let mt={};let ht=0;const vt=e=>{ht=e};let pt=[];const gt=Symbol("GlobalSQBoot"),yt=Symbol("GlobalSQBefore"),wt=Symbol("GlobalSQSuccess"),bt=Symbol("GlobalSQError"),St=Symbol("GlobalSQFail"),xt=Le(),Et=Me("useSQRequest");class kt extends Ke{constructor(e,t){super(e.method,e.args),this.eventSource=t}}class Rt extends kt{constructor(e,t){super(e,e.eventSource),this.error=t}}class Mt extends kt{constructor(e,t){super(e,e.eventSource),this.data=t}}class _t{constructor(e,t,r){this.behavior=e,this.method=t,this.silentMethod=r}}class jt extends _t{constructor(e,t,r,n,o){super(e,t,r),this.queueName=n,this.retryTimes=o}}class Pt extends jt{constructor(e,t,r,n,o,s,a){super(e,t,r,n,o),this.data=s,this.vDataResponse=a}}class Ct extends jt{constructor(e,t,r,n,o,s,a){super(e,t,r,n,o),this.error=s,this.retryDelay=a}}class Ot extends jt{constructor(e,t,r,n,o,s){super(e,t,r,n,o),this.error=s}}class qt extends _t{constructor(e,t,r,n){super(e,t,r),this.args=n}}class Tt extends qt{constructor(e,t,r,n,o){super(e,t,r,n),this.data=o}}class Dt extends qt{constructor(e,t,r,n,o){super(e,t,r,n),this.error=o}}class Ft extends qt{constructor(e,t,r,n,o,s){super(e,t,r,n),this.retryTimes=o,this.retryDelay=s}}class Ht extends qt{constructor(e,t,r,n,o,s,a){super(e,t,r,n),this.status=o,this.data=s,this.error=a}}class $t extends Ke{constructor(e,t,r){super(e.method,e.args),this.retryTimes=t,this.retryDelay=r}}class Lt extends Ge{constructor(e,t,r){super(e,t),this.retryTimes=r}}async function Qt(e,r){let n=X;if(e){const{update:o}=t.promiseStatesHook(),s=C(e),{id:a}=_(e),{s:i,h:c}=Je(a,s),u=w(r)?{data:r}:r;let l=V;i&&(re(te(u),(e=>{_e(e in i,`state named \`${e}\` is not found`);const t=i[e];let r=u[e](t.v);r=ue(r)?[...r]:x(r)?{...r}:r,"data"===e&&(l=r),o(r,i[e].s,e,c.ro)})),n=J),l!==V&&t.setCache(e,l)}return n}var At={forward:e=>R(e,Date)?e.getTime():V,backward:e=>H(Date,e)},zt={forward:e=>R(e,RegExp)?e.source:void 0,backward:e=>H(RegExp,e)};const Nt=(e={})=>{const t={date:At,regexp:zt,...e};return{serialize:e=>(x(e)&&(e=Q(ue(e)?[...e]:{...e},(e=>{let r=V;const n=te(t).reduce(((e,n)=>{if(!r){const o=t[n].forward(e);o!==V&&(r=n,e=o)}return e}),e);return"[object Object]"===G.prototype.toString.call(e)?e={...e}:ue(e)&&(e=[...e]),r!==V?[r,n]:e}))),e),deserialize:e=>x(e)?Q(e,(e=>{if(ue(e)&&2===ce(e)){const r=t[e[0]];e=r?r.backward(e[1]):e}return e}),X):e}},Bt=Symbol("vdid"),Kt=Symbol("original"),Ut=/\[vd:([0-9a-z]+)\]/,Gt=e=>{const t=null==e?void 0:e[Bt];t&&lt&&(lt[t]=V)},Wt=(e,t=J)=>{Gt(e);const r=null==e?void 0:e[Bt];return(r?`[vd:${r}]`:V)||(t?e:V)};function Vt(){return Wt(this)}const It=function(){};It.prototype=G.create(I,{[it]:me(Vt)});const Jt=function(){};Jt.prototype=G.create(I,{[it]:me(Vt)});var Xt=(e,t=P())=>{const r=(e,t=P())=>{if(e===I)e=H(It);else if(e===V)e=H(Jt);else{const t=G(e);he(t,it,Vt),he(t,Kt,e),e=t}return he(e,Bt,t),e},n=r(e,t);return(k(n)||ue(n))&&Q(n,(e=>r(e))),n};const Yt=(e,t=J)=>{const r=e=>(Gt(e),(null==e?void 0:e[Bt])&&(R(e,Jt)?e=V:R(e,It)?e=I:(R(e,Number)||R(e,String)||R(e,Boolean))&&(e=e[Kt])),e),n=r(e);return t&&(x(n)||ue(n))&&Q(n,(e=>r(e))),n};const Zt="__$k",er="__$v",tr=()=>(Et(!!ft,"alova instance is not found, Do you forget to set `alova` or call `bootSilentFactory`?"),ft.l2Cache);let rr=V;const nr="alova.SQ",or="alova.SM.",sr=async(e,t)=>{const r=tr();x(t)&&(t=Q(ue(t)?[...t]:{...t},((e,t,r)=>{var n;if(t===er&&r[Zt])return e;if("context"===t&&"Alova"===(null===(n=null==e?void 0:e.constructor)||void 0===n?void 0:n.name))return V;const o=null==e?void 0:e[Bt];let s=Yt(e,X);if("[object Object]"===E(s)?(e={...e},s={}):ue(e)&&(e=[...e],s=[]),o){const t={[Zt]:o,[er]:s,...e};if(R(e,String))for(let r=0;r<ce(e);r+=1)null==t||delete t[r];e=t}return e}))),rr=rr||Nt(mt),await r.set(e,rr.serialize(t))},ar=async e=>{const t=await tr().get(e);return rr=rr||Nt(mt),x(t)?Q(rr.deserialize(t),(e=>{if(x(e)&&(null==e?void 0:e[Zt])){const t=e[Zt],r=Xt(e[er],t);re(te(e),(t=>{fe([Zt,er],t)||(r[t]=e[t])})),e=r}return e}),X):t},ir=async e=>{await tr().remove(e)},cr=e=>sr(or+e.id,e),ur=async(e,t,r)=>{const n=await ar(nr)||{},o=n[e]||[],s=o.findIndex((e=>e===t));s>=0&&(r?(ie(o,s,1,r.id),await cr(r)):ie(o,s,1),await ir(or+t),ce(o)<=0&&delete n[e],ce(te(n))>0?await sr(nr,n):await ir(nr))};let lr={};const dr=(e,t)=>{const r=e=>{const r=Wt(e);return r in t?t[r]:S(e)?e.replace(H(W,Ut.source,"g"),(e=>e in t?t[e]:e)):e};return x(e)&&!Wt(e,X)?Q(e,r):e=r(e),e},fr=(e,t)=>{let r={};const n=Wt(e,X);if(n&&(r[n]=t),x(e))for(const n in e)r={...r,...fr(e[n],null==t?void 0:t[n])};return r},mr=(e,t)=>{t?e.active=t:delete e.active},hr=1e3,vr=(e,r)=>{const n=t=>{const r=e[0];if(r){const n=pt.find((({queue:e})=>R(e,W)?de(e,t):e===t)),s=()=>e[0]&&o(e[0]),a=(null==n?void 0:n.wait)?$(n.wait,[r,t]):0;a&&a>0?ee(s,a):s()}},o=(s,a=0)=>{mr(s,J);const{cache:i,id:c,behavior:u,entity:l,retryError:d=/.*/,maxRetryTimes:f=0,backoff:m={delay:hr},resolveHandler:h=g,rejectHandler:v=g,emitter:p,handlerArgs:y=[],virtualResponse:w,force:b}=s;xt.emit(yt,H(jt,u,l,s,r,a)),Y(l.send(b),(async o=>{if(ae(e),i&&await ur(r,c),h(o),u===ut){const n=fr(w,o),{targetRefMethod:i,updateStates:c}=s;if(R(i,t.Method)&&c&&ce(c)>0){const e={};re(c,(t=>{e[t]=e=>dr(e,n)}));Qt(i,e)||await t.setCache(i,(e=>dr(e,n)))}await((e,t)=>K.all(oe(t,(async t=>{dr(t.entity,e),t.cache&&await cr(t)}))))(n,e),xt.emit(wt,H(Pt,u,l,s,r,a,o,n))}mr(s,X),n(r)}),(t=>{if(u!==ut)ae(e),v(t);else{const e=e=>xt.emit(bt,H(Ct,u,l,s,r,a,t,e)),{name:n="",message:i=""}=t||{};let c,h;R(d,RegExp)?h=d:x(d)&&(c=d.name,h=d.message);const v=c&&de(c,n)||h&&de(h,i);if(a<f&&v){const t=N(m,a+1);e(t),ee((()=>{o(s,a+=1),p.emit("retry",H(Ft,u,l,s,y,a,t))}),t)}else vt(2),e(),p.emit("fallback",H(Dt,u,l,s,y,t)),xt.emit(St,H(Ot,u,l,s,r,a,t))}mr(s,X)}))};n(r)},pr=async(e,t,r=ct,n=()=>[])=>{e.cache=t;const o=lr[r]=lr[r]||[],s=ce(o)<=0,a=!(await Promise.all(n())).some((e=>e===X));return a&&(t&&await(async(e,t)=>{await cr(e);const r=await ar(nr)||{},n=r[t]=r[t]||[];ne(n,e.id),await sr(nr,r)})(e,r),ne(o,e),s&&1===ht&&vr(o,r)),a},gr=e=>{let t=V,r="",n=0;for(const o in lr)if(n=lr[o].indexOf(e),n>=0){t=lr[o],r=o;break}return[t,r,n]};class yr{constructor(e,t,r,n=P(),o,s,a,i,c,u,l,d){const f=this;f.entity=e,f.behavior=t,f.id=n,f.emitter=r,f.force=!!o,f.retryError=s,f.maxRetryTimes=a,f.backoff=i,f.resolveHandler=c,f.rejectHandler=u,f.handlerArgs=l,f.vDatas=d}async save(){this.cache&&await cr(this)}async replace(e){const t=this;Et(e.cache===t.cache,"the cache of new silentMethod must equal with this silentMethod");const[r,n,o]=gr(t);r&&(ie(r,o,1,e),t.cache&&await ur(n,t.id,e))}async remove(){const e=this,[t,r,n]=gr(e);t&&(ie(t,n,1),e.cache&&await ur(r,e.id))}setUpdateState(e,t="data"){e&&(this.targetRefMethod=e,this.updateStates=ue(t)?t:[t])}}var wr=async()=>{const e=await ar(nr)||{},r={},n=[];return re(te(e),(o=>{const s=r[o]=r[o]||[];ne(n,...oe(e[o],(async e=>{const r=await ar(or+e);r&&ne(s,(e=>{const{id:r,behavior:n,entity:o,retryError:s,maxRetryTimes:a,backoff:i,resolveHandler:c,rejectHandler:u,handlerArgs:l,targetRefMethod:d,force:f}=e,m=e=>{const{type:r,url:n,config:o,data:s}=e;return H(t.Method,r,ft,n,o,s)},h=H(yr,m(o),n,Le(),r,f,s,a,i,c,u,l);return h.cache=J,d&&(h.targetRefMethod=m(d)),re(te(e),(t=>{fe(["id","behavior","emitter","entity","retryError","maxRetryTimes","backoff","resolveHandler","rejectHandler","handlerArgs","targetRefMethod","force"],t)||(h[t]=e[t])})),h})(r))})))})),await K.all(n),r};const br=async(e,t=ct,r=X)=>{const n=(t=[])=>t.filter((t=>{if(e===V)return J;const n=j(t.entity).name||"";return(R(e,RegExp)?de(e,n):n===e)&&(r?t.active:J)}));return[...n(lr[t]),...0===ht?n((await wr())[t]):[]]};let Sr=V;var xr=(e,t)=>{const{behavior:r="queue",queue:n=ct,retryError:o,maxRetryTimes:s,backoff:a}=t||{},i=Le();let c,u,l,d=ct,f=X;return{c:(...t)=>(Et(w(e),"method handler must be a function. eg. useSQRequest(() => method)"),dt({}),c=t,e(...t)),m:({method:e,args:t,cachedResponse:m,proxyStates:h,config:v},p)=>{const{silentDefaultResponse:g,vDataCaptured:y,force:b=X}=v,S=Ke.spawn(e,t);u=$(r,[S]),d=$(n,[S]),f=$(b,[S]);const x=()=>{dt(c=V)};if(w(y)){let t=lt&&ce(te(lt))>0;if(!t){const{url:r,data:n}=e,{params:o,headers:s}=j(e);Q({url:r,params:o,data:n,headers:s},(e=>(t||!Wt(e,X)&&!de(Ut,e)||(t=J),e)))}const r=t?y(e):V;if(r!==V)return x(),U(r)}if("static"!==u){const r=()=>{const r=H(K,((t,r)=>{l=H(yr,e,u,i,V,!!f,o,s,a,t,r,c,lt&&te(lt)),x()}));return Y(U(V),(async()=>{const r=()=>H(qt,u,e,l,t);await pr(l,ce(i.eventMap.fallback||[])<=0&&u===ut,d,(()=>i.emit("beforePushQueue",r())))&&i.emit("pushedQueue",r())})),r};if("queue"===u){const e=f||!m;return e&&(h.loading.v=J),e?r():Y(U(m))}const n=r(),v=l.virtualResponse=Xt(w(g)?g():V);return Y(n,(e=>{h.data.v=e})),U(v)}return x(),p()},d:e=>{e.onSuccess=Qe(e.onSuccess,((e,t)=>{Sr=l,e(H(Tt,u,t.method,l,t.args,t.data))})),e.onError=Qe(e.onError,((e,t)=>{e(H(Dt,u,t.method,l,t.args,t.error))})),e.onComplete=Qe(e.onComplete,((e,t)=>{e(H(Ht,u,t.method,l,t.args,t.status,t.data,t.error))}))},b:{onFallback:e=>{i.on("fallback",e)},onBeforePushQueue:e=>{i.on("beforePushQueue",e)},onPushedQueue:e=>{i.on("pushedQueue",e)},onRetry:e=>{i.on("retry",e)}}}};const Er={},kr=Me("subscriber");const Rr=Me("usePagination"),Mr=(e,t)=>Rr(b(e)&&e<ce(t),"index must be a number that less than list length");const _r=(e,r={})=>{let n=J;const{enableFocus:o=J,enableVisibility:s=J,enableNetwork:a=J,pollingTime:i=0,throttle:c=1e3}=r,{onMounted:u,onUnmounted:l,__referingObj:d}=A(t.promiseStatesHook()),f=nt(e,{...r,__referingObj:d}),m=()=>{n&&(f.send(),c>0&&(n=X,setTimeout((()=>{n=J}),c)))};let h=g,v=g,p=g,y=g;return u((()=>{t.globalConfigMap.ssr||(h=a?_r.onNetwork(m,r):h,v=o?_r.onFocus(m,r):v,p=s?_r.onVisibility(m,r):p,y=i>0?_r.onPolling(m,r):y)})),l((()=>{h(),v(),p(),y()})),f},jr=(e,t)=>(window.addEventListener(e,t),()=>window.removeEventListener(e,t));_r.onNetwork=e=>jr("online",e),_r.onFocus=e=>jr("focus",e),_r.onVisibility=e=>jr("visibilitychange",(()=>"visible"===document.visibilityState&&e())),_r.onPolling=(e,t)=>{const r=setInterval(e,t.pollingTime);return()=>clearInterval(r)};const Pr="useCaptcha",Cr=Me(Pr);const Or=Symbol("FormRestore"),qr={},Tr=e=>{const t=e=>ue(e)?[...e]:k(e)?{...e}:e;return Q(t(e),t)};const Dr=Symbol("RetriableRetry"),Fr=Symbol("RetriableFail"),Hr="useRetriableRequest",$r=Me(Hr);const Lr=Symbol("SSEOpen"),Qr=Symbol("SSEMessage"),Ar=Symbol("SSEError"),zr=Me("useSSE"),Nr="open",Br="error",Kr="message";e.accessAction=(e,t,r=!1)=>{const n=[];"symbol"==typeof e||S(e)||b(e)?Er[e]&&ne(n,...Er[e]):R(e,RegExp)&&re(se(te(Er),(t=>e.test(t))),(e=>{ne(n,...Er[e])})),0!==n.length||r||kr(!1,`no handler can be matched by using \`${e.toString()}\``),re(n,t)},e.actionDelegationMiddleware=e=>{const{ref:r}=A(t.promiseStatesHook()),n=r(X);return(t,r)=>{if(!n.current){const{abort:r,proxyStates:o,delegatingActions:s={}}=t,a=e=>{for(const t in e)o[t]&&(o[t].v=e[t])};(Er[e]=Er[e]||[]).push((e=>!!e.send)(t)?{...s,send:t.send,abort:r,update:a}:{...s,fetch:t.fetch,abort:r,update:a}),n.current=J}return r()}},e.bootSilentFactory=e=>{if(0===ht){const{alova:t,delay:r=500}=e;ft=t,((e={})=>{mt=e})(e.serializers),((e=0)=>{pt=ue(e)?e:[{queue:ct,wait:e}]})(e.requestWait),ee((async()=>{var e;e=await wr(),re(te(e),(t=>{const r=lr[t]=lr[t]||[];ne(r,...e[t])})),re(te(lr),(e=>{vr(lr[e],e)})),vt(1),xt.emit(gt,V)}),r)}},e.createClientTokenAuthentication=({visitorMeta:e,login:t,logout:r,refreshToken:n,assignToken:o=g})=>{let s=X;const a=[];return{waitingList:a,onAuthRequired:r=>async i=>{const c=we(i,e||ve),u=we(i,(null==t?void 0:t.metaMatches)||pe);return c||u||we(i,(null==n?void 0:n.metaMatches)||ye)||(s&&await be(i,a),await xe(i,a,(e=>{s=e}),[i],n)),c||u||await o(i),null==r?void 0:r(i)},onResponseRefreshToken:e=>{const n=Ee(e);return{...n,onSuccess:async(e,o)=>(await Se(o,t,pe,e),await Se(o,r,ge,e),(n.onSuccess||y)(e,o))}}}},e.createServerTokenAuthentication=({visitorMeta:e,login:t,logout:r,refreshTokenOnSuccess:n,refreshTokenOnError:o,assignToken:s=g})=>{let a=X;const i=[];return{waitingList:i,onAuthRequired:r=>async c=>{const u=we(c,e||ve),l=we(c,(null==t?void 0:t.metaMatches)||pe);return u||l||we(c,(null==n?void 0:n.metaMatches)||ye)||we(c,(null==o?void 0:o.metaMatches)||ye)||a&&await be(c,i),u||l||await s(c),null==r?void 0:r(c)},onResponseRefreshToken:s=>{const c=Ee(s);return{...c,onSuccess:async(o,s)=>{if(!we(s,e||ve)&&!we(s,(null==t?void 0:t.metaMatches)||pe)&&!we(s,(null==n?void 0:n.metaMatches)||ye)){const e=await xe(s,i,(e=>{a=e}),[o,s],n,a);if(e)return e}return await Se(s,t,pe,o),await Se(s,r,ge,o),(c.onSuccess||y)(o,s)},onError:async(r,n)=>{if(!we(n,e||ve)&&!we(n,(null==t?void 0:t.metaMatches)||pe)&&!we(n,(null==o?void 0:o.metaMatches)||ye)){const e=await xe(n,i,(e=>{a=e}),[r,n],o,a);if(e)return e}return(c.onError||g)(r,n)}}}}},e.dehydrateVData=e=>Yt(e),e.equals=(e,t)=>e===t?J:Wt(e)===Wt(t),e.filterSilentMethods=br,e.getSilentMethod=async(e,t=ct,r=X)=>(await br(e,t,r))[0],e.isVData=e=>!!Wt(e,X)||de(Ut,e),e.onBeforeSilentSubmit=e=>xt.on(yt,e),e.onSilentSubmitBoot=e=>xt.on(gt,e),e.onSilentSubmitError=e=>xt.on(bt,e),e.onSilentSubmitFail=e=>xt.on(St,e),e.onSilentSubmitSuccess=e=>xt.on(wt,e),e.silentQueueMap=lr,e.stringifyVData=Wt,e.updateState=Qt,e.updateStateEffect=async(e,t)=>(Sr&&(Sr.setUpdateState(e,w(Qt)?V:te(Qt)),await Sr.save()),Qt(e,t)),e.useAutoRequest=_r,e.useCaptcha=(e,r={})=>{const{initialCountdown:n,middleware:o}=r;Cr(n===V||n>0,"initialCountdown must be greater than 0");const{create:s,ref:a,objectify:i,exposeProvider:c,__referingObj:u}=A(t.promiseStatesHook()),l=s(0,"countdown"),d=nt(e,{...r,__referingObj:u,immediate:X,managedStates:i([l],"s"),middleware:o?(e,t)=>o({...e,send:m},t):V}),f=a(V),m=(...e)=>H(K,((t,n)=>{l.v<=0?d.send(...e).then((e=>{l.v=r.initialCountdown||60,f.current=setInterval((()=>{l.v-=1,l.v<=0&&clearInterval(f.current)}),1e3),t(e)})).catch((e=>n(e))):n(H(Re,Pr,"the countdown is not over yet"))}));return c({...d,send:m,...i([l])})},e.useFetcher=rt,e.useForm=(e,r={})=>{const n=qr,{id:o,initialForm:s,store:a,resetAfterSubmiting:i,immediate:c=X,middleware:u}=r;t.promiseStatesHook();const{create:l,ref:d,onMounted:f,watch:m,objectify:h,exposeProvider:v,__referingObj:p}=A(t.promiseStatesHook()),g=k(a),y=g?a.enable:a,w=o?n[o]:V,b=l(Tr(s),"form"),S=e,x=Le(),E=d($(S,[b.v])),R=_(E.current).l2Cache,M=((e,t)=>`alova/form-${t||C(e)}`)(E.current,o),j=d(X),P=d(Nt(g?a.serializers:V)),O=d(!1),q=nt(((...e)=>S(b.v,...e)),{...r,__referingObj:p,middleware:u?(e,t)=>u({...e,delegatingActions:{updateForm:D,reset:T}},t):V,immediate:y||w?X:c}),T=()=>{j.current=J;const e=Tr(s);e&&(b.v=e),y&&R.remove(M)},D=e=>{b.v={...b.v,...e}},F=v({...q,...h([b]),updateForm:D,reset:T,onRestore(e){x.on(Or,e)}});o&&(w||(O.current=J),O.current&&(n[o]={hookProvider:F,config:r}));const{send:H,onSuccess:L}=F;return f((()=>{if(y&&!w){const e=P.current.deserialize(R.get(M));e&&(b.v=e,x.emit(Or,V),y&&c&&H())}})),m([b],(()=>{!j.current&&y?R.set(M,P.current.serialize(b.v)):j.current=X})),L((()=>{i&&T()})),w&&!O.current?w.hookProvider:F},e.usePagination=(e,r={})=>{const{create:n,computed:o,ref:s,watch:a,exposeProvider:i,objectify:c,__referingObj:u}=A(t.promiseStatesHook()),{preloadPreviousPage:l=J,preloadNextPage:d=J,total:f=e=>e.total,data:m=e=>e.data,append:h=X,initialPage:v=1,initialPageSize:p=10,watchingStates:y=[],initialData:S,immediate:x=J,middleware:E=g,force:k=g,..._}=r,j=s(e),P=s(X),O=n(v,"page"),q=n(p,"pageSize"),T=n(S&&m(S)||[],"data"),D=n(S?f(S):V,"total"),{snapshots:H,get:$,save:Q,remove:z}=s((e=>{let r={};return{snapshots:()=>r,save(e,t=X){const n=C(e);r[n]&&!t||(r[n]={entity:e})},get:n=>r[C(R(n,t.Method)?n:e(n))],remove(e){e?delete r[e]:r={}}}})((e=>j.current(e,q.v)))).current,N=e=>m(e)||e,B=rt({__referingObj:u,updateState:X,force:({args:e})=>e[0]}),{loading:K,fetch:W,abort:I,onSuccess:ee}=B,ae=s(K),le=(t=O.v)=>{const r=q.v,n=e(t,r);return Q(n),n};a(y,(()=>{O.v=v,P.current=J}));const de=s({}),me=o((()=>{const e=D.v;return e!==V?Math.ceil(e/q.v):V}),[q,D],"pageCount"),he=e=>(...t)=>de.current[e](...t),ve=ot(le,[...y,O.e,q.e],{__referingObj:u,immediate:x,initialData:S,managedStates:c([T,O,q,D],"s"),middleware:(e,t)=>(E({...e,delegatingActions:{refresh:he("refresh"),insert:he("insert"),remove:he("remove"),replace:he("replace"),reload:he("reload"),getState:e=>({page:O,pageSize:q,data:T,pageCount:me,total:D,isLastPage:be}[e].v)}},U),t()),force:e=>e.args[1]||(w(k)?k(e):k),..._}),{send:pe}=ve,ge=ve.__proxyState("data"),ye=async e=>{const{rawData:r=ge.v,preloadPage:n,fetchMethod:o,forceRequest:s=X,isNextPage:a=X}=e,{e:i}=F(o);if(i("memory")<=M())return X;if(s)return J;if(await t.queryCache(o))return X;const c=me.v,u=c?n>c:a?ce(N(r))<q.v:X;return n>0&&!u},we=async(e,t=X)=>{const r=O.v+1,n=le(r);d&&await ye({rawData:e,preloadPage:r,fetchMethod:n,isNextPage:J,forceRequest:t})&&Z(W(n,t),g)},be=o((()=>{const e=ge.v;if(!e)return J;const t=N(e),r=O.v,n=me.v,o=ue(t)?ce(t):0;return n?r>=n:o<q.v}),[O,me,ge,q],"isLastPage"),Se=async()=>{const e=$(O.v);e&&await t.setCache(e.entity,(e=>{if(e){const t=N(e)||[];return ie(t,0,ce(t),...T.v),e}}))};ee((({method:e,data:t})=>{const r=$(O.v);if(r&&C(r.entity)===C(e)){const e=N(t);if(h){const t=T.v,r=q.v,n=ce(t)%r;if(n>0){const t=[...T.v];ie(t,(O.v-1)*r,n,...e),T.v=t}}else T.v=e}})),ve.onSuccess((({data:e,args:[t,r],method:n})=>{const{total:o}=$(n)||{},s=e;D.v=o!==V?o:f(s),r||((async e=>{const t=O.v-1,r=le(t);l&&await ye({rawData:e,preloadPage:t,fetchMethod:r})&&Z(W(r),g)})(s),we(s));const a=q.v,i=N(s);if(Rr(ue(i),"Got wrong array, did you return the correct array of list in `data` function"),h){if(P.current&&(T.v=[]),t===V)T.v=[...T.v,...i];else if(t){const e=[...T.v];ie(e,(t-1)*a,a,...i),T.v=e}}else T.v=i})),ve.onComplete((()=>{P.current=X}));const xe=e=>{const t=T.v.indexOf(e);return Rr(t>=0,"item is not found in list"),t},{addQueue:Ee,onComplete:ke}=s(L()).current,Re=(t=O.v)=>{let r=t;if(h){if(!b(t)){const e=xe(t);r=Math.floor(e/q.v)+1}Rr(r<=O.v,"refresh page can't greater than page"),Z(pe(r,J),g)}else Rr(b(r),"unable to calculate refresh page by item in pagination mode"),Z(r===O.v?pe(V,J):W(e(r,q.v),J),g)},Me=async(e=X)=>{const r=O.v,n=H();let o=(s=n,G.values(s));var s;if(e)z();else{const e=oe(se([$(r-1),$(r),$(r+1)],Boolean),(({entity:e})=>C(e)));o=oe(se(te(n),(t=>!fe(e,t))),(e=>{const t=n[e];return delete n[e],t}))}await t.invalidateCache(oe(o,(({entity:e})=>e)))},_e=async()=>{ae.current&&I(),await Me();const e=$(O.v+1);if(e){const r=N(await t.queryCache(e.entity)||{})||[];we(V,ce(r)<q.v)}},je=e=>{if(0===e)return;const t=D.v;if(b(t)){const r=Math.max(t+e,0);D.v=r;const n=O.v;re([$(n-1),$(n),$(n+1)],(e=>{e&&(e.total=r)}))}},Pe=(e,r=0)=>(ke(_e),Ee((async()=>{const n=b(r)?r:xe(r)+1;let o=V;const s=[...T.v];if(ce(s)%q.v==0&&(o=s.pop()),ie(s,n,0,e),T.v=s,je(1),await Se(),o){const e=$(O.v+1);e&&await t.setCache(e.entity,(e=>{if(e){const t=N(e)||[];return t.unshift(o),t.pop(),e}}))}}))),Ce=(...e)=>(ke(_e),Ee((async()=>{const r=oe(e,(e=>{const t=b(e)?e:xe(e);return Mr(t,T.v),t})),n=O.v,o=$(n+1),s=[];o&&await t.setCache(o.entity,(e=>{if(e){const t=N(e);return ue(t)&&ne(s,...ie(t,0,ce(r))),e}}));const a=be.v,i=ce(s);if(i>0||a){const e=se(T.v,((e,t)=>!fe(r,t)));!h&&a&&ce(e)<=0?O.v=n-1:i>0&&ne(e,...s),T.v=e}else i<=0&&!a&&Re(n);return je(-ce(r)),Se()}))),Oe=(e,t)=>Ee((async()=>{Rr(t!==V,"expect specify the replace position");const r=b(t)?t:xe(t);Mr(r,T.v);const n=[...T.v];ie(n,r,1,e),T.v=n,await Se()})),qe=()=>{Y(Me(J),(()=>{P.current=J,O.v===v?Z(pe(),g):O.v=v}))};return de.current={refresh:Re,insert:Pe,remove:Ce,replace:Oe,reload:qe},i({...ve,...c([T,O,me,q,D,be]),fetching:B.loading,onFetchSuccess:B.onSuccess,onFetchError:B.onError,onFetchComplete:B.onComplete,refresh:Re,insert:Pe,remove:Ce,replace:Oe,reload:qe})},e.useRequest=nt,e.useRetriableRequest=(e,r={})=>{const{retry:n=3,backoff:o={delay:1e3},middleware:s=g}=r,{ref:a,exposeProvider:i,__referingObj:c}=A(t.promiseStatesHook()),u=Le(),l=a(0),d=a(V),f=a(V),m=a(V),h=a(X),v=a(X),p=a(V),y=a(D()),w=a(X),S=(e,t,r)=>{w.current||(w.current=J,ee((()=>{u.emit(Fr,H(Lt,Ke.spawn(e,t),r,l.current)),d.current=V,l.current=0})))},x=nt(e,{...r,__referingObj:c,middleware(e,t){s({...e,delegatingActions:{stop:E}},(()=>U(V)));const{proxyStates:r,args:a,send:i,method:c,controlLoading:x}=e,k=(e=X)=>{e!==h.current&&(r.loading.v=e,h.current=e)};return x(),k(J),f.current=c,m.current=a,v.current=J,0===l.current&&(w.current=X),Y(Promise.race([t(),y.current.promise]),(e=>(v.current=X,k(),e)),(e=>{if(!d.current&&(b(n)?l.current<n:n(e,...a))){l.current+=1;const e=N(o,l.current);p.current=ee((()=>{Z(i(...a),g),u.emit(Dr,H($t,Ke.spawn(c,a),l.current,e))}),e)}else k(),e=d.current||e,S(c,a,e);return v.current=X,t=e,K.reject(t);var t}))}}),E=()=>{$r(h.current,"there is no requests being retried"),d.current=H(Re,Hr,"stop retry manually"),v.current?x.abort():(y.current.reject(d.current),setTimeout((()=>{y.current=D()})),x.update({error:d.current,loading:X}),h.current=X,clearTimeout(p.current),S(f.current,m.current,d.current))};return i({...x,stop:E,onRetry:e=>{u.on(Dr,(t=>e(t)))},onFail:e=>{u.on(Fr,(t=>e(t)))}})},e.useSQRequest=function(e,r={}){const{exposeProvider:n,__referingObj:o}=A(t.promiseStatesHook()),{middleware:s=g}=r,{c:a,m:i,b:c,d:u}=xr(e,r),l=nt(a,{...r,__referingObj:o,middleware:(e,t)=>{const r=i(e,t);return s(e,(()=>r)),r}});return u(l),n({...l,...c})},e.useSSE=(e,r={})=>{const{initialData:n,withCredentials:o,interceptByGlobalResponded:s=J,immediate:a=X}=r,i=J;let{memorize:c}=t.promiseStatesHook();null!=c||(c=y);const{create:u,ref:l,onMounted:d,onUnmounted:f,objectify:m,exposeProvider:h}=A(t.promiseStatesHook()),v=l([]),p=l(V),b=l(V),S=u(n,"data"),x=u(2,"readyState");let E,R=Fe(e);const M=Le(),P=l(new Map),C=l(y),O=l(Te),q=l(g),T=e=>{const{responded:t}=(e=>_(e).options)(e);if(E=t,w(E))C.current=E;else if(E&&k(E)){const{onSuccess:e,onError:t,onComplete:r}=E;C.current=w(e)?e:C.current,O.current=w(t)?t:O.current,q.current=w(r)?r:q.current}},F=async e=>{const{headers:r,transform:n=y}=j(R),o=await e,s=await n(o,r||{});return S.v=s,t.hitCacheBySource(R),s},H=async(e,t)=>{zr(!!p.current,"EventSource is not initialized");const r=p.current,n=new kt(Ke.spawn(R,v.current),r);if(e===Nr)return Promise.resolve(n);const o=s?C.current:y,a=s?O.current:Te,i=s?q.current:g,c=(u=Y(t,(e=>F(o(e,R))),(e=>F(a(e,R)))),l=()=>{i(R)},u.finally(l));var u,l;return Y(c,(e=>new Mt(n,e)),(e=>new Rt(n,e)))},$=e=>t=>t.error===V?e(t):M.emit(Ar,t),L=c((()=>{var e;x.v=1,Y(H(Nr,Promise.resolve()),(e=>M.emit(Lr,e))),null===(e=b.current)||void 0===e||e.resolve()})),Q=c((e=>{var t,r;x.v=2,Y(H(Br,Promise.reject(null!==(t=null==e?void 0:e.message)&&void 0!==t?t:"SSE Error")),$((e=>M.emit(Qr,e)))),null===(r=b.current)||void 0===r||r.resolve()})),z=c((e=>{Y(H(Kr,Promise.resolve(e.data)),$((e=>M.emit(Qr,e))))})),N=()=>{const e=p.current;e&&(b.current&&b.current.resolve(),e.close(),e.removeEventListener(Nr,L),e.removeEventListener(Br,Q),e.removeEventListener(Kr,z),x.v=2,P.current.forEach((([t,r],n)=>{e.removeEventListener(n,r)})))},B=(...t)=>{let r=p.current,n=b.current;r&&i&&N(),n||(n=b.current=D(),n&&n.promise.finally((()=>{n=V}))),v.current=t,R=Fe(e,t),T(R);const{params:s}=j(R),{baseURL:a,url:c}=R,u=((e,t,r)=>{const n=(e=e.endsWith("/")?e.slice(0,-1):e)+(t=t.match(/^(\/|https?:\/\/)/)?t:`/${t}`),o=oe(se(te(r),(e=>r[e]!==V)),(e=>`${e}=${r[e]}`)).join("&");return o?+n.includes("?")?`${n}&${o}`:`${n}?${o}`:n})(a,c,s);return r=new EventSource(u,{withCredentials:o}),p.current=r,x.v=0,r.addEventListener(Nr,L),r.addEventListener(Br,Q),r.addEventListener(Kr,z),P.current.forEach((([e,t],n)=>{null==r||r.addEventListener(n,(e=>{Y(H(n,Promise.resolve(e.data)),$(t))}))})),n.promise};return f((()=>{N(),M.off(Lr),M.off(Qr),M.off(Ar),P.current.forEach((([e,t,r])=>{r()}))})),d((()=>{var e;a&&(B(),null===(e=b.current)||void 0===e||e.promise.catch((()=>{})))})),h({send:B,close:N,on:(e,t)=>{var r;const n=P.current;if(!n.has(e)){const t=function(e=g){let t=[];return[r=>(t.includes(r)||(t.push(r),e(t)),()=>{t=se(t,(e=>e!==r)),e(t)}),(...e)=>{if(t.length>0)return re(t,(t=>t(...e)))},()=>{t=[],e(t)}]}((r=>{var n;0===r.length&&(null===(n=p.current)||void 0===n||n.removeEventListener(e,t[1]),P.current.delete(e))})),o=t[1];n.set(e,t),null===(r=p.current)||void 0===r||r.addEventListener(e,(t=>{Y(H(e,Promise.resolve(t.data)),$(o))}))}const[o]=n.get(e);return o(t)},onMessage:e=>{M.on(Qr,e)},onError:e=>{M.on(Ar,e)},onOpen:e=>{M.on(Lr,e)},eventSource:p,...m([x,S])})},e.useSerialRequest=(e,r={})=>{st("useSerialRequest",e);const{ref:n,__referingObj:o}=A(t.promiseStatesHook()),s=n([]).current,a=nt(e[0],{...r,__referingObj:o,middleware:at(e,r.middleware,s)});return a.onError=Qe(a.onError,((e,t)=>{t.method=s[ce(s)-1],e(t)})),a},e.useSerialWatcher=(e,r,n={})=>{st("useSerialWatcher",e);const{ref:o,__referingObj:s}=A(t.promiseStatesHook()),a=o([]).current,i=ot(e[0],r,{...n,__referingObj:s,middleware:at(e,n.middleware,a)});return i.onError=Qe(i.onError,((e,t)=>{t.method=a[ce(a)-1],e(t)})),i},e.useWatcher=ot}));
