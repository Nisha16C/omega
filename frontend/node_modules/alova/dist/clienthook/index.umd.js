/**
  * @alova/client 2.0.0 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2024 Scott hu. All Rights Reserved
  * Licensed under MIT (https://github.com/alovajs/alova/blob/main/LICENSE)
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('alova')) :
  typeof define === 'function' && define.amd ? define(['exports', 'alova'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.AlovaClientHook = {}, global.alova));
})(this, (function (exports, alova) { 'use strict';

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  class FrameworkReadableState {
      constructor(state, key, dehydrate, exportState) {
          this.s = state;
          this.k = key;
          this.$dhy = dehydrate;
          this.$exp = exportState;
      }
      get v() {
          return this.$dhy(this.s);
      }
      get e() {
          return this.$exp(this.s);
      }
  }
  class FrameworkState extends FrameworkReadableState {
      constructor(state, key, dehydrate, exportState, update) {
          super(state, key, dehydrate, exportState);
          this.$upd = update;
      }
      set v(newValue) {
          this.$upd(this.s, newValue);
      }
      get v() {
          return super.v;
      }
  }

  const undefStr$3 = 'undefined';
  // 以下为减少编译代码量而添加的统一处理函数或变量
  const PromiseCls$1 = Promise;
  const ObjectCls$1 = Object;
  const undefinedValue$1 = undefined;
  const nullValue$1 = null;
  const trueValue$1 = true;
  const falseValue$1 = false;
  const promiseThen$1 = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);
  const objectKeys$1 = (obj) => ObjectCls$1.keys(obj);
  const forEach$1 = (ary, fn) => ary.forEach(fn);
  const pushItem$2 = (ary, ...item) => ary.push(...item);
  const mapItem$2 = (ary, callbackfn) => ary.map(callbackfn);
  const shift$1 = (ary) => ary.shift();
  const len$1 = (data) => data.length;
  const typeOf = (arg) => typeof arg;
  const includes$1 = (ary, target) => ary.includes(target);
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr$3 &&
      (typeof process !== undefStr$3 ? typeof process.cwd === 'function' : typeof Deno !== undefStr$3);
  /** cache mode */
  // only cache in memory, it's default option
  const MEMORY$1 = 'memory';
  // persistent cache, and will be read to memory when page is refreshed, it means that the memory cache always exist until cache is expired.
  const STORAGE_RESTORE = 'restore';

  /**
   * 空函数，做兼容处理
   */
  const noop = () => { };
  /**
   * 返回参数自身的函数，做兼容处理用
   * 由于部分系统将self作为了保留字，故使用$self来区分
   * @param arg 任意参数
   * @returns 返回参数本身
   */
  const $self = (arg) => arg;
  /**
   * 判断参数是否为函数
   * @param fn 任意参数
   * @returns 该参数是否为函数
   */
  const isFn = (arg) => typeOf(arg) === 'function';
  /**
   * 判断参数是否为数字
   * @param arg 任意参数
   * @returns 该参数是否为数字
   */
  const isNumber = (arg) => typeOf(arg) === 'number' && !Number.isNaN(arg);
  /**
   * 判断参数是否为字符串
   * @param arg 任意参数
   * @returns 该参数是否为字符串
   */
  const isString = (arg) => typeOf(arg) === 'string';
  /**
   * 判断参数是否为对象
   * @param arg 任意参数
   * @returns 该参数是否为对象
   */
  const isObject = (arg) => arg !== nullValue$1 && typeOf(arg) === 'object';
  /**
   * 全局的toString
   * @param arg 任意参数
   * @returns 字符串化的参数
   */
  const globalToString = (arg) => ObjectCls$1.prototype.toString.call(arg);
  /**
   * 判断是否为普通对象
   * @param arg 任意参数
   * @returns 判断结果
   */
  const isPlainObject = (arg) => globalToString(arg) === '[object Object]';
  /**
   * 判断是否为某个类的实例
   * @param arg 任意参数
   * @returns 判断结果
   */
  const instanceOf = (arg, cls) => arg instanceof cls;
  /**
   * 统一的时间戳获取函数
   * @returns 时间戳
   */
  const getTime = (date) => (date ? date.getTime() : Date.now());
  /**
   * 通过method实例获取alova实例
   * @returns alova实例
   */
  const getContext = (methodInstance) => methodInstance.context;
  /**
   * 获取method实例配置数据
   * @returns 配置对象
   */
  const getConfig = (methodInstance) => methodInstance.config;
  /**
   * 获取alova配置数据
   * @returns alova配置对象
   */
  const getContextOptions = (alovaInstance) => alovaInstance.options;
  /**
   * 通过method实例获取alova配置数据
   * @returns alova配置对象
   */
  const getOptions = (methodInstance) => getContextOptions(getContext(methodInstance));
  /**
   * 创建uuid简易版
   * @returns uuid
   */
  const uuid$1 = () => {
      const timestamp = new Date().getTime();
      return Math.floor(Math.random() * timestamp).toString(36);
  };
  /**
   * 获取method实例的key值
   * @param methodInstance method实例
   * @returns 此method实例的key值
   */
  const getMethodInternalKey = (methodInstance) => methodInstance.key;
  /**
   * 获取请求方法对象
   * @param methodHandler 请求方法句柄
   * @param args 方法调用参数
   * @returns 请求方法对象
   */
  const getHandlerMethod$1 = (methodHandler, assert, args = []) => {
      const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;
      assert(!!methodInstance.key, 'hook handler must be a method instance or a function that returns method instance');
      return methodInstance;
  };
  const objAssign = (target, ...sources) => ObjectCls$1.assign(target, ...sources);
  /**
   * 排除一个数据集合中指定的属性，并返回新的数据集合
   * @param obj 数据集合
   * @param keys 排除的key
   * @returns 新的数据集合
   */
  const omit = (obj, ...keys) => {
      const result = {};
      for (const key in obj) {
          if (!keys.includes(key)) {
              result[key] = obj[key];
          }
      }
      return result;
  };
  /**
   * the same as `Promise.withResolvers`
   * @returns promise with resolvers.
   */
  function usePromise() {
      let retResolve;
      let retReject;
      const promise = new Promise((resolve, reject) => {
          retResolve = resolve;
          retReject = reject;
      });
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return { promise, resolve: retResolve, reject: retReject };
  }
  /**
   * 获取缓存的配置参数，固定返回{ e: function, c: any, f: any, m: number, s: boolean, t: string }格式的对象
   * e为expire缩写，它返回缓存失效时间点（时间戳），单位为毫秒
   * c为controlled，表示是否为受控缓存
   * f为cacheFor原始值，用于在c为true时调用获取缓存数据
   * m为mode缩写，存储模式
   * s为storage缩写，是否存储到本地
   * t为tag缩写，持久化存储标签
   * @param methodInstance method实例
   * @returns 统一的缓存参数对象
   */
  const getLocalCacheConfigParam = (methodInstance) => {
      const { cacheFor } = getConfig(methodInstance);
      const getCacheExpireTs = (cacheExpire) => isNumber(cacheExpire) ? getTime() + cacheExpire : getTime(cacheExpire || undefinedValue$1);
      let cacheMode = MEMORY$1;
      let expire = () => 0;
      let store = falseValue$1;
      let tag = undefinedValue$1;
      const controlled = isFn(cacheFor);
      if (!controlled) {
          let expireColumn = cacheFor;
          if (isPlainObject(cacheFor)) {
              const { mode = MEMORY$1, expire, tag: configTag } = cacheFor || {};
              cacheMode = mode;
              store = mode === STORAGE_RESTORE;
              tag = configTag ? configTag.toString() : undefinedValue$1;
              expireColumn = expire;
          }
          expire = (mode) => getCacheExpireTs(isFn(expireColumn) ? expireColumn({ method: methodInstance, mode }) : expireColumn);
      }
      return {
          f: cacheFor,
          c: controlled,
          e: expire,
          m: cacheMode,
          s: store,
          t: tag
      };
  };
  /**
   * 创建类实例
   * @param Cls 构造函数
   * @param args 构造函数参数
   * @returns 类实例
   */
  const newInstance$1 = (Cls, ...args) => new Cls(...args);
  /**
   * 统一配置
   * @param 数据
   * @returns 统一的配置
   */
  const sloughConfig = (config, args = []) => isFn(config) ? config(...args) : config;
  /**
   * 创建异步函数队列，异步函数将串行执行
   * @returns 队列添加函数
   */
  const createAsyncQueue = (catchError = falseValue$1) => {
      const queue = [];
      let completedHandler = undefinedValue$1;
      let executing = false;
      const executeQueue = async () => {
          executing = true;
          while (len$1(queue) > 0) {
              const asyncFunc = shift$1(queue);
              if (asyncFunc) {
                  await asyncFunc();
              }
          }
          completedHandler && completedHandler();
          executing = false;
      };
      const addQueue = (asyncFunc) => newInstance$1((PromiseCls$1), (resolve, reject) => {
          const wrappedFunc = () => promiseThen$1(asyncFunc(), resolve, err => {
              catchError ? resolve(undefinedValue$1) : reject(err);
          });
          pushItem$2(queue, wrappedFunc);
          if (!executing) {
              executeQueue();
          }
      });
      const onComplete = (fn) => {
          completedHandler = fn;
      };
      return {
          addQueue,
          onComplete
      };
  };
  /**
   * 深层遍历目标对象
   * @param target 目标对象
   * @param callback 遍历回调
   * @param preorder 是否前序遍历，默认为true
   * @param key 当前遍历的key
   * @param parent 当前遍历的父节点
   */
  const walkObject = (target, callback, preorder = trueValue$1, key, parent) => {
      const callCallback = () => {
          if (parent && key) {
              target = callback(target, key, parent);
              if (target !== parent[key]) {
                  parent[key] = target;
              }
          }
      };
      // 前序遍历
      preorder && callCallback();
      if (isObject(target)) {
          for (const i in target) {
              if (!instanceOf(target, String)) {
                  walkObject(target[i], callback, preorder, i, target);
              }
          }
      }
      // 后序遍历
      !preorder && callCallback();
      return target;
  };
  /**
   * create simple and unified, framework-independent states creators and handlers.
   * @param statesHook states hook from `promiseStatesHook` function of alova
   * @param referingObject refering object exported from `promiseStatesHook` function
   * @returns simple and unified states creators and handlers
   */
  function statesHookHelper(statesHook, referingObject = { trackedKeys: {}, bindError: falseValue$1 }) {
      const ref = (initialValue) => (statesHook.ref ? statesHook.ref(initialValue) : { current: initialValue });
      referingObject = ref(referingObject).current;
      const exportState = (state) => (statesHook.export || $self)(state, referingObject);
      const memorize = (fn) => {
          if (!isFn(statesHook.memorize)) {
              return fn;
          }
          const memorizedFn = statesHook.memorize(fn);
          memorizedFn.memorized = true;
          return memorizedFn;
      };
      const { dehydrate } = statesHook;
      // For performance reasons, only value is different, and the key is tracked can be updated.
      const update = (newValue, state, key) => newValue !== dehydrate(state, key, referingObject) &&
          referingObject.trackedKeys[key] &&
          statesHook.update(newValue, state, key, referingObject);
      const mapDeps = (deps) => mapItem$2(deps, item => (instanceOf(item, FrameworkReadableState) ? item.e : item));
      const createdStateList = [];
      // key of deps on computed
      const depKeys = {};
      return {
          create: (initialValue, key) => {
              pushItem$2(createdStateList, key); // record the keys of created states.
              return newInstance$1((FrameworkState), statesHook.create(initialValue, key, referingObject), key, state => dehydrate(state, key, referingObject), exportState, (state, newValue) => update(newValue, state, key));
          },
          computed: (getter, depList, key) => {
              // Collect all dependencies in computed
              forEach$1(depList, dep => {
                  if (dep.k) {
                      depKeys[dep.k] = true;
                  }
              });
              return newInstance$1((FrameworkReadableState), statesHook.computed(getter, mapDeps(depList), key, referingObject), key, state => dehydrate(state, key, referingObject), exportState);
          },
          effectRequest: (effectRequestParams) => statesHook.effectRequest(effectRequestParams, referingObject),
          ref,
          watch: (source, callback) => statesHook.watch(mapDeps(source), callback, referingObject),
          onMounted: (callback) => statesHook.onMounted(callback, referingObject),
          onUnmounted: (callback) => statesHook.onUnmounted(callback, referingObject),
          /**
           * refering object that sharing some value with this object.
           */
          __referingObj: referingObject,
          /**
           * expose provider for specified use hook.
           * @param object object that contains state proxy, framework state, operating function and event binder.
           * @returns provider component.
           */
          exposeProvider: (object) => {
              const provider = {};
              const originalStatesMap = {};
              for (const key in object) {
                  const value = object[key];
                  const isValueFunction = isFn(value);
                  // if it's a memorized function, don't memorize it any more, add it to provider directly.
                  // if it's start with `on`, it indicates it is an event binder, we should define a new function which return provider object.
                  // if it's a common function, add it to provider with memorize mode.
                  if (isValueFunction) {
                      provider[key] = key.startsWith('on')
                          ? (...args) => {
                              value(...args);
                              // eslint-disable-next-line
                              return completedProvider;
                          }
                          : value.memorized
                              ? value
                              : memorize(value);
                  }
                  else {
                      const isFrameworkState = instanceOf(value, FrameworkReadableState);
                      if (isFrameworkState) {
                          originalStatesMap[key] = value.s;
                      }
                      // otherwise, it's a state proxy or framework state, add it to provider with getter mode.
                      ObjectCls$1.defineProperty(provider, key, {
                          get: () => {
                              // record the key that is being tracked.
                              referingObject.trackedKeys[key] = trueValue$1;
                              return isFrameworkState ? value.e : value;
                          },
                          // set need to set an function,
                          // otherwise it will throw `TypeError: Cannot set property __referingObj of #<Object> which has only a getter` when setting value
                          set: noop,
                          enumerable: trueValue$1,
                          configurable: trueValue$1
                      });
                  }
              }
              const { update: nestedHookUpdate, __proxyState: nestedProxyState } = provider;
              // reset the tracked keys and bingError flag, so that the nest hook providers can be initialized.
              // Always track the dependencies in computed
              referingObject.trackedKeys = {
                  ...depKeys
              };
              referingObject.bindError = falseValue$1;
              const extraProvider = {
                  // expose referingObject automatically.
                  __referingObj: referingObject,
                  // the new updating function that can update the new states and nested hook states.
                  update: memorize((newStates) => {
                      objectKeys$1(newStates).forEach(key => {
                          if (includes$1(createdStateList, key)) {
                              update(newStates[key], originalStatesMap[key], key);
                          }
                          else if (key in provider && isFn(nestedHookUpdate)) {
                              nestedHookUpdate({
                                  [key]: newStates[key]
                              });
                          }
                      });
                  }),
                  __proxyState: memorize((key) => {
                      if (includes$1(createdStateList, key) && instanceOf(object[key], FrameworkReadableState)) {
                          // need to tag the key that is being tracked so that it can be updated with `state.v = xxx`.
                          referingObject.trackedKeys[key] = trueValue$1;
                          return object[key];
                      }
                      return nestedProxyState(key);
                  })
              };
              const completedProvider = objAssign(provider, extraProvider);
              return completedProvider;
          },
          /**
           * transform state proxies to object.
           * @param states proxy array of framework states
           * @param filterKey filter key of state proxy
           * @returns an object that contains the states of target form
           */
          objectify: (states, filterKey) => states.reduce((result, item) => {
              result[item.k] = filterKey ? item[filterKey] : item;
              return result;
          }, {}),
          transformState2Proxy: (state, key) => newInstance$1((FrameworkState), state, key, state => dehydrate(state, key, referingObject), exportState, (state, newValue) => update(newValue, state, key))
      };
  }
  const cacheKeyPrefix = '$a.';
  /**
   * build common cache key.
   */
  const buildNamespacedCacheKey = (namespace, key) => cacheKeyPrefix + namespace + key;
  /**
   * 根据避让策略和重试次数计算重试延迟时间
   * @param backoff 避让参数
   * @param retryTimes 重试次数
   * @returns 重试延迟时间
   */
  const delayWithBackoff = (backoff, retryTimes) => {
      let { startQuiver, endQuiver } = backoff;
      const { delay, multiplier = 1 } = backoff;
      let retryDelayFinally = (delay || 0) * multiplier ** (retryTimes - 1);
      // 如果startQuiver或endQuiver有值，则需要增加指定范围的随机抖动值
      if (startQuiver || endQuiver) {
          startQuiver = startQuiver || 0;
          endQuiver = endQuiver || 1;
          retryDelayFinally +=
              retryDelayFinally * startQuiver + Math.random() * retryDelayFinally * (endQuiver - startQuiver);
          retryDelayFinally = Math.floor(retryDelayFinally); // 取整数延迟
      }
      return retryDelayFinally;
  };

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  const undefStr$2 = 'undefined';
  // 以下为减少编译代码量而添加的统一处理函数或变量
  const PromiseCls = Promise;
  const promiseResolve = (value) => PromiseCls.resolve(value);
  const promiseReject = (value) => PromiseCls.reject(value);
  const ObjectCls = Object;
  const RegExpCls = RegExp;
  const undefinedValue = undefined;
  const nullValue = null;
  const trueValue = true;
  const falseValue = false;
  const promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);
  const promiseCatch = (promise, onrejected) => promise.catch(onrejected);
  const promiseFinally = (promise, onfinally) => promise.finally(onfinally);
  const setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);
  const clearTimeoutTimer = (timer) => clearTimeout(timer);
  const objectKeys = (obj) => ObjectCls.keys(obj);
  const objectValues = (obj) => ObjectCls.values(obj);
  const forEach = (ary, fn) => ary.forEach(fn);
  const pushItem$1 = (ary, ...item) => ary.push(...item);
  const mapItem$1 = (ary, callbackfn) => ary.map(callbackfn);
  const filterItem$1 = (ary, predicate) => ary.filter(predicate);
  const shift = (ary) => ary.shift();
  const splice = (ary, start, deleteCount = 0, ...items) => ary.splice(start, deleteCount, ...items);
  const len = (data) => data.length;
  const isArray = (arg) => Array.isArray(arg);
  const deleteAttr = (arg, attr) => delete arg[attr];
  const regexpTest = (reg, str) => reg.test(str);
  const includes = (ary, target) => ary.includes(target);
  const valueObject = (value, writable = falseValue) => ({ value, writable });
  const defineProperty = (o, key, value, isDescriptor = falseValue) => ObjectCls.defineProperty(o, key, isDescriptor ? value : valueObject(value, falseValue));
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr$2 &&
      (typeof process !== undefStr$2 ? typeof process.cwd === 'function' : typeof Deno !== undefStr$2);
  /** cache mode */
  // only cache in memory, it's default option
  const MEMORY = 'memory';

  const defaultVisitorMeta = {
      authRole: null
  };
  const defaultLoginMeta = {
      authRole: 'login'
  };
  const defaultLogoutMeta = {
      authRole: 'logout'
  };
  const defaultRefreshTokenMeta = {
      authRole: 'refreshToken'
  };
  const checkMethodRole = ({ meta }, metaMatches) => {
      if (isPlainObject(meta)) {
          for (const key in meta) {
              if (Object.prototype.hasOwnProperty.call(meta, key)) {
                  const matchedMetaItem = metaMatches[key];
                  if (instanceOf(matchedMetaItem, RegExp) ? matchedMetaItem.test(meta[key]) : meta[key] === matchedMetaItem) {
                      return trueValue;
                  }
              }
          }
      }
      return falseValue;
  };
  const waitForTokenRefreshed = (method, waitingList) => newInstance$1(PromiseCls, resolve => {
      pushItem$1(waitingList, {
          method,
          resolve
      });
  });
  const callHandlerIfMatchesMeta = (method, authorizationInterceptor, defaultMeta, response) => {
      if (checkMethodRole(method, (authorizationInterceptor === null || authorizationInterceptor === void 0 ? void 0 : authorizationInterceptor.metaMatches) || defaultMeta)) {
          const handler = isFn(authorizationInterceptor)
              ? authorizationInterceptor
              : isPlainObject(authorizationInterceptor) && isFn(authorizationInterceptor.handler)
                  ? authorizationInterceptor.handler
                  : noop;
          return handler(response, method);
      }
  };
  const refreshTokenIfExpired = async (method, waitingList, updateRefreshStatus, handlerParams, refreshToken, tokenRefreshing) => {
      // 当handleParams数量大于2时，说明是从响应中调用此函数的，此时需要重新请求原接口
      const fromResponse = len(handlerParams) >= 2;
      let isExpired = refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.isExpired(...handlerParams);
      // 兼容处理同步函数和异步函数
      if (instanceOf(isExpired, PromiseCls)) {
          isExpired = await isExpired;
      }
      if (isExpired) {
          try {
              // 在响应中再次判断，防止请求多次刷新token，把在token刷新完成前发送的拦截并等待
              let intentToRefreshToken = trueValue;
              if (fromResponse && tokenRefreshing) {
                  intentToRefreshToken = falseValue; // 在此等待的请求表示token刷新中，当它们通过后不再需要再次刷新token了
                  await waitForTokenRefreshed(method, waitingList);
              }
              if (intentToRefreshToken) {
                  updateRefreshStatus(trueValue);
                  // 调用刷新token
                  await (refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.handler(...handlerParams));
                  updateRefreshStatus(falseValue);
                  // 刷新token完成后，通知等待列表中的请求
                  forEach(waitingList, ({ resolve }) => resolve());
              }
              if (fromResponse) {
                  // 这里因为是重新请求原接口，与上一次请求叠加会导致重复调用transform，因此需要将transform置空去除一次调用
                  const { config } = method;
                  const methodTransformData = config.transform;
                  config.transform = undefinedValue;
                  const resentData = await method;
                  config.transform = methodTransformData;
                  return resentData;
              }
          }
          finally {
              updateRefreshStatus(falseValue);
              splice(waitingList, 0, len(waitingList)); // 清空waitingList
          }
      }
  };
  const onResponded2Record = (onRespondedHandlers) => {
      let successHandler = undefinedValue;
      let errorHandler = undefinedValue;
      let onCompleteHandler = undefinedValue;
      if (isFn(onRespondedHandlers)) {
          successHandler = onRespondedHandlers;
      }
      else if (isPlainObject(onRespondedHandlers)) {
          const { onSuccess, onError, onComplete } = onRespondedHandlers;
          successHandler = isFn(onSuccess) ? onSuccess : successHandler;
          errorHandler = isFn(onError) ? onError : errorHandler;
          onCompleteHandler = isFn(onComplete) ? onComplete : onCompleteHandler;
      }
      return {
          onSuccess: successHandler,
          onError: errorHandler,
          onComplete: onCompleteHandler
      };
  };

  /**
   * 创建客户端的token认证拦截器
   * @param options 配置参数
   * @returns token认证拦截器函数
   */
  const createClientTokenAuthentication = ({ visitorMeta, login, logout, refreshToken, assignToken = noop }) => {
      let tokenRefreshing = falseValue;
      const waitingList = [];
      const onAuthRequired = onBeforeRequest => async (method) => {
          const isVisitorRole = checkMethodRole(method, visitorMeta || defaultVisitorMeta);
          const isLoginRole = checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta);
          // 被忽略的、登录、刷新token的请求不进行token认证
          if (!isVisitorRole &&
              !isLoginRole &&
              !checkMethodRole(method, (refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.metaMatches) || defaultRefreshTokenMeta)) {
              // 如果正在刷新token，则等待刷新完成后再发请求
              if (tokenRefreshing) {
                  await waitForTokenRefreshed(method, waitingList);
              }
              await refreshTokenIfExpired(method, waitingList, refreshing => {
                  tokenRefreshing = refreshing;
              }, [method], refreshToken);
          }
          // 非访客和登录角色的请求会进入赋值token函数
          if (!isVisitorRole && !isLoginRole) {
              await assignToken(method);
          }
          return onBeforeRequest === null || onBeforeRequest === void 0 ? void 0 : onBeforeRequest(method);
      };
      const onResponseRefreshToken = originalResponded => {
          const respondedRecord = onResponded2Record(originalResponded);
          return {
              ...respondedRecord,
              onSuccess: async (response, method) => {
                  await callHandlerIfMatchesMeta(method, login, defaultLoginMeta, response);
                  await callHandlerIfMatchesMeta(method, logout, defaultLogoutMeta, response);
                  return (respondedRecord.onSuccess || $self)(response, method);
              }
          };
      };
      return {
          waitingList,
          onAuthRequired,
          onResponseRefreshToken
      };
  };
  /**
   * 创建服务端的token认证拦截器
   * @param options 配置参数
   * @returns token认证拦截器函数
   */
  const createServerTokenAuthentication = ({ visitorMeta, login, logout, refreshTokenOnSuccess, refreshTokenOnError, assignToken = noop }) => {
      let tokenRefreshing = falseValue;
      const waitingList = [];
      const onAuthRequired = onBeforeRequest => async (method) => {
          const isVisitorRole = checkMethodRole(method, visitorMeta || defaultVisitorMeta);
          const isLoginRole = checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta);
          // 被忽略的、登录、刷新token的请求不进行token认证
          if (!isVisitorRole &&
              !isLoginRole &&
              !checkMethodRole(method, (refreshTokenOnSuccess === null || refreshTokenOnSuccess === void 0 ? void 0 : refreshTokenOnSuccess.metaMatches) || defaultRefreshTokenMeta) &&
              !checkMethodRole(method, (refreshTokenOnError === null || refreshTokenOnError === void 0 ? void 0 : refreshTokenOnError.metaMatches) || defaultRefreshTokenMeta)) {
              // 如果正在刷新token，则等待刷新完成后再发请求
              if (tokenRefreshing) {
                  await waitForTokenRefreshed(method, waitingList);
              }
          }
          if (!isVisitorRole && !isLoginRole) {
              await assignToken(method);
          }
          return onBeforeRequest === null || onBeforeRequest === void 0 ? void 0 : onBeforeRequest(method);
      };
      const onResponseRefreshToken = onRespondedHandlers => {
          const respondedRecord = onResponded2Record(onRespondedHandlers);
          return {
              ...respondedRecord,
              onSuccess: async (response, method) => {
                  if (!checkMethodRole(method, visitorMeta || defaultVisitorMeta) &&
                      !checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta) &&
                      !checkMethodRole(method, (refreshTokenOnSuccess === null || refreshTokenOnSuccess === void 0 ? void 0 : refreshTokenOnSuccess.metaMatches) || defaultRefreshTokenMeta)) {
                      const dataResent = await refreshTokenIfExpired(method, waitingList, refreshing => {
                          tokenRefreshing = refreshing;
                      }, [response, method], refreshTokenOnSuccess, tokenRefreshing);
                      if (dataResent) {
                          return dataResent;
                      }
                  }
                  await callHandlerIfMatchesMeta(method, login, defaultLoginMeta, response);
                  await callHandlerIfMatchesMeta(method, logout, defaultLogoutMeta, response);
                  return (respondedRecord.onSuccess || $self)(response, method);
              },
              onError: async (error, method) => {
                  if (!checkMethodRole(method, visitorMeta || defaultVisitorMeta) &&
                      !checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta) &&
                      !checkMethodRole(method, (refreshTokenOnError === null || refreshTokenOnError === void 0 ? void 0 : refreshTokenOnError.metaMatches) || defaultRefreshTokenMeta)) {
                      const dataResent = await refreshTokenIfExpired(method, waitingList, refreshing => {
                          tokenRefreshing = refreshing;
                      }, [error, method], refreshTokenOnError, tokenRefreshing);
                      if (dataResent) {
                          return dataResent;
                      }
                  }
                  return (respondedRecord.onError || noop)(error, method);
              }
          };
      };
      return {
          waitingList,
          onAuthRequired,
          onResponseRefreshToken
      };
  };

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  const undefStr$1 = 'undefined';
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr$1 &&
      (typeof process !== undefStr$1 ? typeof process.cwd === 'function' : typeof Deno !== undefStr$1);

  /**
   * 创建类实例
   * @param Cls 构造函数
   * @param args 构造函数参数
   * @returns 类实例
   */
  const newInstance = (Cls, ...args) => new Cls(...args);

  /**
   * alova错误类
   */
  class AlovaError extends Error {
      constructor(prefix, message, errorCode) {
          super(message + (errorCode ? `\n\nFor detailed: https://alova.js.org/error#${errorCode}` : ''));
          this.name = `[alova${prefix ? `/${prefix}` : ''}]`;
      }
  }
  /**
   * 自定义断言函数，表达式为false时抛出错误
   * 当传入了errorCode时，将提供链接到错误文档，引导用户改正
   * @param expression 判断表达式，true或false
   * @param message 断言消息
   */
  const createAssert = (prefix = '') => (expression, message, errorCode) => {
      if (!expression) {
          throw newInstance(AlovaError, prefix, message, errorCode);
      }
  };

  const coreAssert = createAssert('');
  const requestHookAssert = createAssert('useRequest');
  const watcherHookAssert = createAssert('useWatcher');
  const fetcherHookAssert = createAssert('useFetcher');
  const coreHookAssert = (hookType) => ({
      [1 /* EnumHookType.USE_REQUEST */]: requestHookAssert,
      [2 /* EnumHookType.USE_WATCHER */]: watcherHookAssert,
      [3 /* EnumHookType.USE_FETCHER */]: fetcherHookAssert
  })[hookType];
  /**
   * 断言是否为method实例
   * @param methodInstance method实例
   */
  const assertMethod = (assert, methodInstance) => assert(instanceOf(methodInstance, alova.Method), 'expected a method instance.');

  /**
   * 兼容函数，抛出参数
   * @param error 错误
   */
  const throwFn = (error) => {
      // eslint-disable-next-line @typescript-eslint/no-throw-literal
      throw error;
  };
  function useCallback(onCallbackChange = noop) {
      let callbacks = [];
      const setCallback = (fn) => {
          if (!callbacks.includes(fn)) {
              callbacks.push(fn);
              onCallbackChange(callbacks);
          }
          // 返回取消注册函数
          return () => {
              callbacks = filterItem$1(callbacks, e => e !== fn);
              onCallbackChange(callbacks);
          };
      };
      const triggerCallback = (...args) => {
          if (callbacks.length > 0) {
              return forEach(callbacks, fn => fn(...args));
          }
      };
      const removeAllCallback = () => {
          callbacks = [];
          onCallbackChange(callbacks);
      };
      return [setCallback, triggerCallback, removeAllCallback];
  }
  /**
   * 创建防抖函数，当delay为0时立即触发函数
   * 场景：在调用useWatcher并设置了immediate为true时，首次调用需立即执行，否则会造成延迟调用
   * @param {GeneralFn} fn 回调函数
   * @param {number|(...args: any[]) => number} delay 延迟描述，设置为函数时可实现动态的延迟
   * @returns 延迟后的回调函数
   */
  const debounce = (fn, delay) => {
      let timer = nullValue;
      return function debounceFn(...args) {
          const bindFn = fn.bind(this, ...args);
          const delayMill = isNumber(delay) ? delay : delay(...args);
          timer && clearTimeoutTimer(timer);
          if (delayMill > 0) {
              timer = setTimeoutFn(bindFn, delayMill);
          }
          else {
              bindFn();
          }
      };
  };
  /**
   * 获取请求方法对象
   * @param methodHandler 请求方法句柄
   * @param args 方法调用参数
   * @returns 请求方法对象
   */
  const getHandlerMethod = (methodHandler, args = []) => {
      const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;
      createAssert('scene')(instanceOf(methodInstance, alova.Method), 'hook handler must be a method instance or a function that returns method instance');
      return methodInstance;
  };
  /**
   * 转换对象的每一项值，并返回新的对象
   * @param obj 对象
   * @param callback 回调函数
   * @returns 转换后的对象
   */
  const mapObject = (obj, callback) => {
      const ret = {};
      for (const key in obj) {
          ret[key] = callback(obj[key], key, obj);
      }
      return ret;
  };

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  const undefStr = 'undefined';
  const pushItem = (ary, ...item) => ary.push(...item);
  const mapItem = (ary, callbackfn) => ary.map(callbackfn);
  const filterItem = (ary, predicate) => ary.filter(predicate);
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr &&
      (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);

  /**
   * 创建uuid简易版
   * @returns uuid
   */
  const uuid = () => {
      const timestamp = new Date().getTime();
      return Math.floor(Math.random() * timestamp).toString(36);
  };

  const createEventManager = () => {
      const eventMap = {};
      return {
          eventMap,
          on(type, handler) {
              const eventTypeItem = (eventMap[type] = eventMap[type] || []);
              pushItem(eventTypeItem, handler);
              // return the off function
              return () => {
                  eventMap[type] = filterItem(eventTypeItem, item => item !== handler);
              };
          },
          off(type, handler) {
              const handlers = eventMap[type];
              if (!handlers) {
                  return;
              }
              if (handler) {
                  const index = handlers.indexOf(handler);
                  index > -1 && handlers.splice(index, 1);
              }
              else {
                  delete eventMap[type];
              }
          },
          emit(type, event) {
              const handlers = eventMap[type] || [];
              return mapItem(handlers, handler => handler(event));
          }
      };
  };
  const decorateEvent = (onEvent, decoratedHandler) => {
      const emitter = createEventManager();
      const eventType = uuid();
      const eventReturn = onEvent(event => emitter.emit(eventType, event));
      return (handler) => {
          emitter.on(eventType, event => {
              decoratedHandler(handler, event);
          });
          return eventReturn;
      };
  };

  const KEY_SUCCESS = 'success';
  const KEY_ERROR = 'error';
  const KEY_COMPLETE = 'complete';

  var createHook = (ht, c, eventManager, ro) => ({
      /** 最后一次请求的method实例 */
      m: undefinedValue,
      /** saveStatesFns */
      sf: [],
      /** removeStatesFns */
      rf: [],
      /** frontStates */
      fs: {},
      /** eventManager */
      em: eventManager,
      /** hookType, useRequest=1, useWatcher=2, useFetcher=3 */
      ht,
      /** hook config */
      c,
      /** referingObject */
      ro,
      /** managedStates */
      ms: {}
  });

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  class AlovaEventBase {
      constructor(method, args) {
          this.method = method;
          this.args = args;
      }
      clone() {
          return { ...this };
      }
      static spawn(method, args) {
          return new AlovaEventBase(method, args);
      }
  }
  class AlovaSuccessEvent extends AlovaEventBase {
      constructor(base, data, fromCache) {
          super(base.method, base.args);
          this.data = data;
          this.fromCache = fromCache;
      }
  }
  class AlovaErrorEvent extends AlovaEventBase {
      constructor(base, error) {
          super(base.method, base.args);
          this.error = error;
      }
  }
  class AlovaCompleteEvent extends AlovaEventBase {
      constructor(base, status, data, fromCache, error) {
          super(base.method, base.args);
          this.status = status;
          this.data = data;
          this.fromCache = status === 'error' ? false : fromCache;
          this.error = error;
      }
  }

  const defaultMiddleware = (_, next) => next();

  const stateCache = {};
  /**
   * @description 获取State缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   * @returns 缓存的响应数据，如果没有则返回{}
   */
  const getStateCache = (namespace, key) => {
      const cachedState = stateCache[namespace] || {};
      return cachedState[key] || {};
  };
  /**
   * @description 设置State缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   * @param data 缓存数据
   */
  const setStateCache = (namespace, key, data, hookInstance) => {
      const cachedState = (stateCache[namespace] = stateCache[namespace] || {});
      cachedState[key] = {
          s: data,
          h: hookInstance
      };
  };
  /**
   * @description 清除State缓存数据
   * @param baseURL 基础URL
   * @param key 请求key值
   */
  const removeStateCache = (namespace, key) => {
      const cachedState = stateCache[namespace];
      if (cachedState) {
          deleteAttr(cachedState, key);
      }
  };

  /**
   * 统一处理useRequest/useWatcher/useFetcher等请求钩子函数的请求逻辑
   * @param hookInstance hook实例
   * @param methodHandler 请求方法对象或获取函数
   * @param sendCallingArgs send函数参数
   * @returns 请求状态
   */
  function useHookToSendRequest(hookInstance, methodHandler, sendCallingArgs = []) {
      const currentHookAssert = coreHookAssert(hookInstance.ht);
      let methodInstance = getHandlerMethod$1(methodHandler, currentHookAssert, sendCallingArgs);
      const { fs: frontStates, ht: hookType, c: useHookConfig, ms: managedStates } = hookInstance;
      const { loading: loadingState, data: dataState, error: errorState } = frontStates;
      const isFetcher = hookType === 3 /* EnumHookType.USE_FETCHER */;
      const { force: forceRequest = falseValue, middleware = defaultMiddleware } = useHookConfig;
      const alovaInstance = getContext(methodInstance);
      const { id } = alovaInstance;
      // 如果是静默请求，则请求后直接调用onSuccess，不触发onError，然后也不会更新progress
      const methodKey = getMethodInternalKey(methodInstance);
      const { abortLast = trueValue } = useHookConfig;
      hookInstance.m = methodInstance;
      return (async () => {
          // 初始化状态数据，在拉取数据时不需要加载，因为拉取数据不需要返回data数据
          let removeStates = noop;
          let saveStates = noop;
          let isNextCalled = falseValue;
          let responseHandlePromise = promiseResolve(undefinedValue);
          let offDownloadEvent = noop;
          let offUploadEvent = noop;
          const cachedResponse = await alova.queryCache(methodInstance);
          let fromCache = () => !!cachedResponse;
          // 是否为受控的loading状态，当为true时，响应处理中将不再设置loading为false
          let controlledLoading = falseValue;
          if (!isFetcher) {
              // 将初始状态存入缓存以便后续更新
              saveStates = frontStates => setStateCache(id, methodKey, frontStates, hookInstance);
              saveStates({ ...frontStates, ...managedStates });
              // 设置状态移除函数，将会传递给hook内的effectRequest，它将被设置在组件卸载时调用
              removeStates = () => removeStateCache(id, methodKey);
          }
          // 中间件函数next回调函数，允许修改强制请求参数，甚至替换即将发送请求的Method实例
          const guardNext = guardNextConfig => {
              isNextCalled = trueValue;
              const { force: guardNextForceRequest = forceRequest, method: guardNextReplacingMethod = methodInstance } = guardNextConfig || {};
              const forceRequestFinally = sloughConfig(guardNextForceRequest, [
                  newInstance$1((AlovaEventBase), methodInstance, sendCallingArgs)
              ]);
              const progressUpdater = (stage) => ({ loaded, total }) => {
                  frontStates[stage].v = {
                      loaded,
                      total
                  };
              };
              methodInstance = guardNextReplacingMethod;
              // 每次发送请求都需要保存最新的控制器
              pushItem$1(hookInstance.sf, saveStates);
              pushItem$1(hookInstance.rf, removeStates);
              // loading状态受控时将不更改loading
              // 未命中缓存，或强制请求时需要设置loading为true
              if (!controlledLoading) {
                  loadingState.v = !!forceRequestFinally || !cachedResponse;
              }
              // 根据downloading、uploading的追踪状态来判断是否触发进度更新
              const { downloading: enableDownload, uploading: enableUpload } = hookInstance.ro.trackedKeys;
              offDownloadEvent = enableDownload ? methodInstance.onDownload(progressUpdater('downloading')) : offDownloadEvent;
              offUploadEvent = enableUpload ? methodInstance.onUpload(progressUpdater('uploading')) : offUploadEvent;
              responseHandlePromise = methodInstance.send(forceRequestFinally);
              fromCache = () => methodInstance.fromCache || falseValue;
              return responseHandlePromise;
          };
          // 调用中间件函数
          const commonContext = {
              method: methodInstance,
              cachedResponse,
              config: useHookConfig,
              abort: () => methodInstance.abort()
          };
          // 是否需要更新响应数据，以及调用响应回调
          const toUpdateResponse = () => hookType !== 2 /* EnumHookType.USE_WATCHER */ || !abortLast || hookInstance.m === methodInstance;
          // 调用中间件函数
          const middlewareCompletePromise = isFetcher
              ? middleware({
                  ...commonContext,
                  args: sendCallingArgs,
                  fetch: (methodInstance, ...args) => {
                      assertMethod(currentHookAssert, methodInstance);
                      return useHookToSendRequest(hookInstance, methodInstance, args);
                  },
                  proxyStates: omit(frontStates, 'data'),
                  controlFetching(control = trueValue) {
                      controlledLoading = control;
                  }
              }, guardNext)
              : middleware({
                  ...commonContext,
                  args: sendCallingArgs,
                  send: (...args) => useHookToSendRequest(hookInstance, methodHandler, args),
                  proxyStates: frontStates,
                  controlLoading(control = trueValue) {
                      controlledLoading = control;
                  }
              }, guardNext);
          let finallyResponse = undefinedValue;
          const baseEvent = AlovaEventBase.spawn(methodInstance, sendCallingArgs);
          try {
              // 统一处理响应
              const middlewareReturnedData = await middlewareCompletePromise;
              const afterSuccess = (data) => {
                  // 更新缓存响应数据
                  if (!isFetcher) {
                      toUpdateResponse() && (dataState.v = data);
                  }
                  else if (hookInstance.c.updateState !== falseValue) {
                      // 更新缓存内的状态，一般为useFetcher中进入
                      const cachedState = getStateCache(id, methodKey).s;
                      cachedState && (cachedState.data.v = data);
                  }
                  // 如果需要更新响应数据，则在请求后触发对应回调函数
                  if (toUpdateResponse()) {
                      errorState.v = undefinedValue;
                      // loading状态受控时将不再更改为false
                      !controlledLoading && (loadingState.v = falseValue);
                      hookInstance.em.emit(KEY_SUCCESS, newInstance$1((AlovaSuccessEvent), baseEvent, data, fromCache()));
                      hookInstance.em.emit(KEY_COMPLETE, newInstance$1((AlovaCompleteEvent), baseEvent, KEY_SUCCESS, data, fromCache(), undefinedValue));
                  }
                  return data;
              };
              finallyResponse =
                  // 中间件中未返回数据或返回undefined时，去获取真实的响应数据
                  // 否则使用返回数据并不再等待响应promise，此时也需要调用响应回调
                  middlewareReturnedData !== undefinedValue
                      ? afterSuccess(middlewareReturnedData)
                      : isNextCalled
                          ? // 当middlewareCompletePromise为resolve时有两种可能
                              // 1. 请求正常
                              // 2. 请求错误，但错误被中间件函数捕获了，此时也将调用成功回调，即afterSuccess(undefinedValue)
                              await promiseThen(responseHandlePromise, afterSuccess, () => afterSuccess(undefinedValue))
                          : // 如果isNextCalled未被调用，则不返回数据
                              undefinedValue;
              // 未调用next函数时，更新loading为false
              !isNextCalled && !controlledLoading && (loadingState.v = falseValue);
          }
          catch (error) {
              if (toUpdateResponse()) {
                  // 控制在输出错误消息
                  errorState.v = error;
                  // loading状态受控时将不再更改为false
                  !controlledLoading && (loadingState.v = falseValue);
                  hookInstance.em.emit(KEY_ERROR, newInstance$1((AlovaErrorEvent), baseEvent, error));
                  hookInstance.em.emit(KEY_COMPLETE, newInstance$1((AlovaCompleteEvent), baseEvent, KEY_ERROR, undefinedValue, fromCache(), error));
              }
              throw error;
          }
          // 响应后解绑下载和上传事件
          offDownloadEvent();
          offUploadEvent();
          return finallyResponse;
      })();
  }

  const refCurrent = (ref) => ref.current;
  /**
   * 创建请求状态，统一处理useRequest、useWatcher、useFetcher中一致的逻辑
   * 该函数会调用statesHook的创建函数来创建对应的请求状态
   * 当该值为空时，表示useFetcher进入的，此时不需要data状态和缓存状态
   * @param methodInstance 请求方法对象
   * @param useHookConfig hook请求配置对象
   * @param initialData 初始data数据
   * @param immediate 是否立即发起请求
   * @param watchingStates 被监听的状态，如果未传入，直接调用handleRequest
   * @param debounceDelay 请求发起的延迟时间
   * @returns 当前的请求状态、操作函数及事件绑定函数
   */
  function createRequestState(hookType, methodHandler, useHookConfig, initialData, immediate = falseValue, watchingStates, debounceDelay = 0) {
      var _a;
      // shallow clone config object to avoid passing the same useHookConfig object which may cause vue2 state update error
      useHookConfig = { ...useHookConfig };
      const { middleware, __referingObj: referingObject = { trackedKeys: {}, bindError: falseValue } } = useHookConfig;
      let initialLoading = middleware ? falseValue : !!immediate;
      // 当立即发送请求时，需要通过是否强制请求和是否有缓存来确定初始loading值，这样做有以下两个好处：
      // 1. 在react下立即发送请求可以少渲染一次
      // 2. SSR渲染的html中，其初始视图为loading状态的，避免在客户端展现时的loading视图闪动
      // 3. 如果config.middleware中设置了`controlLoading`时，需要默认为false，但这边无法确定middleware中是否有调用`controlLoading`，因此条件只能放宽点，当有`config.middleware`时则初始`loading`为false
      if (immediate && !middleware) {
          // 调用getHandlerMethod时可能会报错，需要try/catch
          try {
              const methodInstance = getHandlerMethod$1(methodHandler, coreHookAssert(hookType));
              const alovaInstance = getContext(methodInstance);
              const l1CacheResult = alovaInstance.l1Cache.get(buildNamespacedCacheKey(alovaInstance.id, getMethodInternalKey(methodInstance)));
              let cachedResponse = undefinedValue;
              // 只同步检查缓存，因此对异步的l1Cache适配器不生效
              // 建议在客户端不设置异步的l1Cache适配器
              if (l1CacheResult && !instanceOf(l1CacheResult, PromiseCls)) {
                  const [data, expireTimestamp] = l1CacheResult;
                  // 如果没有过期时间则表示数据永不过期，否则需要判断是否过期
                  if (!expireTimestamp || expireTimestamp > getTime()) {
                      cachedResponse = data;
                  }
              }
              const forceRequestFinally = sloughConfig((_a = useHookConfig.force) !== null && _a !== void 0 ? _a : falseValue);
              initialLoading = !!forceRequestFinally || !cachedResponse;
          }
          catch (error) { }
      }
      const { create, effectRequest, ref, objectify, exposeProvider, transformState2Proxy } = statesHookHelper(alova.promiseStatesHook(), referingObject);
      const progress = {
          total: 0,
          loaded: 0
      };
      // 将外部传入的受监管的状态一同放到frontStates集合中
      const { managedStates = {} } = useHookConfig;
      const managedStatesProxy = mapObject(managedStates, (state, key) => transformState2Proxy(state, key));
      const data = create((isFn(initialData) ? initialData() : initialData), 'data');
      const loading = create(initialLoading, 'loading');
      const error = create(undefinedValue, 'error');
      const downloading = create({ ...progress }, 'downloading');
      const uploading = create({ ...progress }, 'uploading');
      const frontStates = objectify([data, loading, error, downloading, uploading]);
      const eventManager = createEventManager();
      const hookInstance = refCurrent(ref(createHook(hookType, useHookConfig, eventManager, referingObject)));
      /**
       * ## react ##每次执行函数都需要重置以下项
       */
      hookInstance.fs = frontStates;
      hookInstance.em = eventManager;
      hookInstance.c = useHookConfig;
      hookInstance.ms = managedStatesProxy;
      const hasWatchingStates = watchingStates !== undefinedValue;
      // 初始化请求事件
      // 统一的发送请求函数
      const handleRequest = (handler = methodHandler, sendCallingArgs) => useHookToSendRequest(hookInstance, handler, sendCallingArgs);
      // 以捕获异常的方式调用handleRequest
      // 捕获异常避免异常继续向外抛出
      const wrapEffectRequest = (ro = referingObject, handler) => promiseCatch(handleRequest(handler), error => {
          // the error tracking indicates that the error need to throw.
          if (!ro.bindError && !ro.trackedKeys.error) {
              throw error;
          }
      });
      /**
       * fix: #421
       * Use ref wraps to prevent react from creating new debounce function in every render
       * Explicit passing is required because the context will change
       */
      const debouncingSendHandler = ref(debounce((delay, ro, handler) => wrapEffectRequest(ro, handler), (changedIndex) => isNumber(changedIndex) ? (isArray(debounceDelay) ? debounceDelay[changedIndex] : debounceDelay) : 0));
      // 在服务端渲染时不发送请求
      if (!alova.globalConfigMap.ssr) {
          effectRequest({
              handler: 
              // watchingStates为数组时表示监听状态（包含空数组），为undefined时表示不监听状态
              hasWatchingStates
                  ? (delay) => debouncingSendHandler.current(delay, referingObject, methodHandler)
                  : () => wrapEffectRequest(referingObject),
              removeStates: () => forEach(hookInstance.rf, fn => fn()),
              saveStates: states => forEach(hookInstance.sf, fn => fn(states)),
              frontStates: { ...frontStates, ...managedStatesProxy },
              watchingStates,
              immediate: immediate !== null && immediate !== void 0 ? immediate : trueValue
          });
      }
      return exposeProvider({
          ...objectify([data, loading, error, downloading, uploading]),
          abort: () => hookInstance.m && hookInstance.m.abort(),
          /**
           * 通过执行该方法来手动发起请求
           * @param sendCallingArgs 调用send函数时传入的参数
           * @param methodInstance 方法对象
           * @param isFetcher 是否为isFetcher调用
           * @returns 请求promise
           */
          send: (sendCallingArgs, methodInstance) => handleRequest(methodInstance, sendCallingArgs),
          onSuccess(handler) {
              eventManager.on(KEY_SUCCESS, handler);
          },
          onError(handler) {
              // will not throw error when bindError is true.
              // it will reset in `exposeProvider` so that ignore the error binding in custom use hooks.
              referingObject.bindError = trueValue;
              eventManager.on(KEY_ERROR, handler);
          },
          onComplete(handler) {
              eventManager.on(KEY_COMPLETE, handler);
          }
      });
  }

  /**
   * Fetch request data and cache
   * @param method request method object
   */
  function useFetcher(config = {}) {
      const props = createRequestState(3 /* EnumHookType.USE_FETCHER */, noop, config);
      const { send } = props;
      deleteAttr(props, 'send');
      return objAssign(props, {
          /**
           * Fetch data
           * fetch will definitely send a request, and if the currently requested data has a corresponding management state, this state will be updated.
           * @param matcher Method object
           */
          fetch: (matcher, ...args) => {
              assertMethod(fetcherHookAssert, matcher);
              return send(args, matcher);
          }
      });
  }

  function useRequest(handler, config = {}) {
      const { immediate = trueValue, initialData } = config;
      const props = createRequestState(1 /* EnumHookType.USE_REQUEST */, handler, config, initialData, !!immediate);
      const { send } = props;
      return objAssign(props, {
          send: (...args) => send(args)
      });
  }

  function useWatcher(handler, watchingStates, config = {}) {
      watcherHookAssert(watchingStates && len(watchingStates) > 0, 'expected at least one watching state');
      const { immediate, debounce = 0, initialData } = config;
      const props = createRequestState(2 /* EnumHookType.USE_WATCHER */, handler, config, initialData, !!immediate, // !!immediate means not send request immediately
      watchingStates, debounce);
      const { send } = props;
      return objAssign(props, {
          send: (...args) => send(args)
      });
  }

  /**
   * 断言serialHandlers
   * @param hookName hook name
   * @param serialHandlers 串行请求method获取函数
   */
  const assertSerialHandlers = (hookName, serialHandlers) => createAssert(hookName)(isArray(serialHandlers) && len(serialHandlers) > 0, 'please use an array to represent serial requests');
  /**
   * 创建串行请求中间件
   * @param serialHandlers 串行请求method获取函数
   * @param hookMiddleware use hook的中间件
   * @returns 串行请求中间件
   */
  const serialMiddleware = (serialHandlers, hookMiddleware, serialRequestMethods = []) => {
      // 第一个handler在外部传递给了use hook，不需要再次请求
      serialHandlers.shift();
      return ((ctx, next) => {
          hookMiddleware === null || hookMiddleware === void 0 ? void 0 : hookMiddleware(ctx, () => promiseResolve(undefinedValue));
          ctx.controlLoading();
          const loadingState = ctx.proxyStates.loading;
          loadingState.v = trueValue;
          let serialPromise = next();
          for (const handler of serialHandlers) {
              serialPromise = promiseThen(serialPromise, value => {
                  const methodItem = handler(value, ...ctx.args);
                  pushItem$1(serialRequestMethods, methodItem);
                  return methodItem.send();
              });
          }
          return serialPromise.finally(() => {
              loadingState.v = falseValue;
          });
      });
  };

  /**
   * 串行请求hook，每个serialHandlers中将接收到上一个请求的结果
   * 适用场景：串行请求一组接口
   * @param serialHandlers 串行请求回调数组
   * @param config 配置参数
   * @return useSerialRequest相关数据和操作函数
   */
  var useSerialRequest = (serialHandlers, config = {}) => {
      assertSerialHandlers('useSerialRequest', serialHandlers);
      // eslint-disable-next-line
      const { ref, __referingObj } = statesHookHelper(alova.promiseStatesHook());
      const methods = ref([]).current;
      const exposures = useRequest(serialHandlers[0], {
          ...config,
          __referingObj,
          middleware: serialMiddleware(serialHandlers, config.middleware, methods)
      });
      // 装饰错误回调函数，将event.method设置为出错的实例
      exposures.onError = decorateEvent(exposures.onError, (handler, event) => {
          event.method = methods[len(methods) - 1];
          handler(event);
      });
      return exposures;
  };

  /**
   * 串行请求hook，每个serialHandlers中将接收到上一个请求的结果
   * 适用场景：监听状态变化后，串行请求一组接口
   * @param serialHandlers 串行请求回调数组
   * @param config 配置参数
   * @return useSerialRequest相关数据和操作函数
   */
  var useSerialWatcher = (serialHandlers, watchingStates, config = {}) => {
      assertSerialHandlers('useSerialWatcher', serialHandlers);
      // eslint-disable-next-line
      const { ref, __referingObj } = statesHookHelper(alova.promiseStatesHook());
      const methods = ref([]).current;
      const exposures = useWatcher(serialHandlers[0], watchingStates, {
          ...config,
          __referingObj,
          middleware: serialMiddleware(serialHandlers, config.middleware, methods)
      });
      // 装饰错误回调函数，将event.method设置为出错的实例
      exposures.onError = decorateEvent(exposures.onError, (handler, event) => {
          event.method = methods[len(methods) - 1];
          handler(event);
      });
      return exposures;
  };

  const STR_VALUE_OF = 'valueOf';
  const DEFAULT_QUEUE_NAME = 'default';
  const BEHAVIOR_SILENT = 'silent';
  const BEHAVIOR_QUEUE = 'queue';
  const BEHAVIOR_STATIC = 'static';
  /**
   * 全局的虚拟数据收集数组
   * 它只会在method创建时为数组，其他时间为undefined
   *
   * 解释：收集虚拟数据的目的为了判断某个method实例内是否使用了虚拟数据
   * 包括以下形式：
   * useSQRequest((vDataId) => createMethod({ vDataId }) // 引用函数参数
   * useSQRequest(() => createMethod({ vDataId }) // 直接引用作用域参数
   *
   * 甚至是：
   * function createMethod(obj) {
   *   return alovaInst.Get('/list', {
   *     params: { status: obj.vDataId ? 1 : 0 }
   *   })
   * }
   * useSQRequest(() => createMethod(obj) // 直接引用作用域参数
   *
   * 使用虚拟数据的方式包含：
   * 1. 直接作为参数赋值
   * 2. 使用虚拟数据id
   * 3. 间接使用虚拟数据，如
   *    vData ? 1 : 0
   *    !!vData
   *    vData + 1
   *    等作为计算参数参与的形式
   */
  let vDataIdCollectBasket;
  const setVDataIdCollectBasket = (value) => {
      vDataIdCollectBasket = value;
  };
  /**
   * 依赖的alova实例，它的存储适配器、请求适配器等将用于存取SilentMethod实例，以及发送静默提交
   */
  let dependentAlovaInstance;
  const setDependentAlova = (alovaInst) => {
      dependentAlovaInstance = alovaInst;
  };
  /**
   * 设置自定义的序列化器
   */
  let customSerializers = {};
  const setCustomSerializers = (serializers = {}) => {
      customSerializers = serializers;
  };
  /**
   * silentFactory状态
   * 0表示未启动
   * 1表示进行中，调用bootSilentFactory后变更
   * 2表示请求失败，即按重试规则请求达到最大次数时，或不匹配重试规则时变更
   */
  let silentFactoryStatus = 0;
  const setSilentFactoryStatus = (status) => {
      silentFactoryStatus = status;
  };
  /**
   * silentQueue内的请求等待时间，单位为毫秒（ms）
   * 它表示即将发送请求的silentMethod的等待时间
   * 如果未设置，或设置为0表示立即触发silentMethod请求
   *
   * Tips:
   * 1. 直接设置时默认对default queue有效
   * 2. 如果需要对其他queue设置可指定为对象，如：
   * [
   *   表示对名为customName的队列设置请求等待5000ms
   *   { name: 'customName', wait: 5000 },
   *
   *   // 表示前缀为prefix的所有队列中，method实例名为xxx的请求设置等待5000ms
   *   { name: /^prefix/, wait: silentMethod => silentMethod.entity.config.name === 'xxx' ? 5000 : 0 },
   * ]
   *
   * >>> 它只在请求成功时起作用，如果失败则会使用重试策略参数
   */
  let queueRequestWaitSetting = [];
  const setQueueRequestWaitSetting = (requestWaitSetting = 0) => {
      queueRequestWaitSetting = isArray(requestWaitSetting)
          ? requestWaitSetting
          : [
              {
                  queue: DEFAULT_QUEUE_NAME,
                  wait: requestWaitSetting
              }
          ];
  };
  const BootEventKey = Symbol('GlobalSQBoot');
  const BeforeEventKey = Symbol('GlobalSQBefore');
  const SuccessEventKey = Symbol('GlobalSQSuccess');
  const ErrorEventKey = Symbol('GlobalSQError');
  const FailEventKey$1 = Symbol('GlobalSQFail');
  /** 全局的silent事件管理对象 */
  const globalSQEventManager = createEventManager();
  /** silentAssert */
  const silentAssert = createAssert('useSQRequest');

  class AlovaSSEEvent extends AlovaEventBase {
      constructor(base, eventSource) {
          super(base.method, base.args);
          this.eventSource = eventSource;
      }
  }
  class AlovaSSEErrorEvent extends AlovaSSEEvent {
      constructor(base, error) {
          super(base, base.eventSource);
          this.error = error;
      }
  }
  class AlovaSSEMessageEvent extends AlovaSSEEvent {
      constructor(base, data) {
          super(base, base.eventSource);
          this.data = data;
      }
  }
  /** SQ顶层事件 */
  class SQEvent {
      constructor(behavior, method, silentMethod) {
          this.behavior = behavior;
          this.method = method;
          this.silentMethod = silentMethod;
      }
  }
  /** SQ全局事件 */
  class GlobalSQEvent extends SQEvent {
      constructor(behavior, method, silentMethod, queueName, retryTimes) {
          super(behavior, method, silentMethod);
          this.queueName = queueName;
          this.retryTimes = retryTimes;
      }
  }
  class GlobalSQSuccessEvent extends GlobalSQEvent {
      constructor(behavior, method, silentMethod, queueName, retryTimes, data, vDataResponse) {
          super(behavior, method, silentMethod, queueName, retryTimes);
          this.data = data;
          this.vDataResponse = vDataResponse;
      }
  }
  class GlobalSQErrorEvent extends GlobalSQEvent {
      constructor(behavior, method, silentMethod, queueName, retryTimes, error, retryDelay) {
          super(behavior, method, silentMethod, queueName, retryTimes);
          this.error = error;
          this.retryDelay = retryDelay;
      }
  }
  class GlobalSQFailEvent extends GlobalSQEvent {
      constructor(behavior, method, silentMethod, queueName, retryTimes, error) {
          super(behavior, method, silentMethod, queueName, retryTimes);
          this.error = error;
      }
  }
  /** SQ事件 */
  class ScopedSQEvent extends SQEvent {
      constructor(behavior, method, silentMethod, args) {
          super(behavior, method, silentMethod);
          this.args = args;
      }
  }
  class ScopedSQSuccessEvent extends ScopedSQEvent {
      constructor(behavior, method, silentMethod, args, data) {
          super(behavior, method, silentMethod, args);
          this.data = data;
      }
  }
  class ScopedSQErrorEvent extends ScopedSQEvent {
      constructor(behavior, method, silentMethod, args, error) {
          super(behavior, method, silentMethod, args);
          this.error = error;
      }
  }
  class ScopedSQRetryEvent extends ScopedSQEvent {
      constructor(behavior, method, silentMethod, args, retryTimes, retryDelay) {
          super(behavior, method, silentMethod, args);
          this.retryTimes = retryTimes;
          this.retryDelay = retryDelay;
      }
  }
  class ScopedSQCompleteEvent extends ScopedSQEvent {
      constructor(behavior, method, silentMethod, args, status, data, error) {
          super(behavior, method, silentMethod, args);
          this.status = status;
          this.data = data;
          this.error = error;
      }
  }
  class RetriableRetryEvent extends AlovaEventBase {
      constructor(base, retryTimes, retryDelay) {
          super(base.method, base.args);
          this.retryTimes = retryTimes;
          this.retryDelay = retryDelay;
      }
  }
  class RetriableFailEvent extends AlovaErrorEvent {
      constructor(base, error, retryTimes) {
          super(base, error);
          this.retryTimes = retryTimes;
      }
  }

  /**
   * 更新对应method的状态
   * @param method 请求方法对象
   * @param handleUpdate 更新回调
   * @returns 是否更新成功，未找到对应的状态时不会更新成功
   */
  async function updateState(matcher, handleUpdate) {
      let updated = falseValue;
      // 只处理符合条件的第一个Method实例，如果没有符合条件的实例，则不处理
      if (matcher) {
          const { update } = alova.promiseStatesHook();
          const methodKey = getMethodInternalKey(matcher);
          const { id } = getContext(matcher);
          const { s: frontStates, h: hookInstance } = getStateCache(id, methodKey);
          const updateStateCollection = isFn(handleUpdate)
              ? { data: handleUpdate }
              : handleUpdate;
          let updatedDataColumnData = undefinedValue;
          if (frontStates) {
              // 循环遍历更新数据，并赋值给受监管的状态
              forEach(objectKeys(updateStateCollection), stateName => {
                  coreAssert(stateName in frontStates, `state named \`${stateName}\` is not found`);
                  const targetStateProxy = frontStates[stateName];
                  let updatedData = updateStateCollection[stateName](targetStateProxy.v);
                  // shallow clone the updatedData so that can effect in react.
                  updatedData = isArray(updatedData)
                      ? [...updatedData]
                      : isObject(updatedData)
                          ? { ...updatedData }
                          : updatedData;
                  // 记录data字段的更新值，用于更新缓存数据
                  if (stateName === 'data') {
                      updatedDataColumnData = updatedData;
                  }
                  // 直接使用update更新，不检查referingObject.trackedKeys
                  update(updatedData, frontStates[stateName].s, stateName, hookInstance.ro);
              });
              updated = trueValue;
          }
          // 如果更新了data，则需要同时更新缓存和持久化数据
          if (updatedDataColumnData !== undefinedValue) {
              alova.setCache(matcher, updatedDataColumnData);
          }
      }
      return updated;
  }

  var dateSerializer = {
      forward: data => (instanceOf(data, Date) ? data.getTime() : undefinedValue),
      backward: ts => newInstance$1(Date, ts)
  };

  var regexpSerializer = {
      forward: data => (instanceOf(data, RegExp) ? data.source : undefined),
      backward: source => newInstance$1(RegExp, source)
  };

  const createSerializerPerformer = (customSerializers = {}) => {
      /**
       * 合并内置序列化器和自定义序列化器
       */
      const serializers = {
          date: dateSerializer,
          regexp: regexpSerializer,
          ...customSerializers
      };
      /**
       * 序列化数据
       */
      const serialize = (payload) => {
          if (isObject(payload)) {
              payload = walkObject(isArray(payload) ? [...payload] : { ...payload }, value => {
                  let finallyApplySerializerName = undefinedValue;
                  // 找到匹配的序列化器并进行值的序列化，未找到则返回原值
                  const serializedValue = objectKeys(serializers).reduce((currentValue, serializerName) => {
                      if (!finallyApplySerializerName) {
                          const serializedValueItem = serializers[serializerName].forward(currentValue);
                          if (serializedValueItem !== undefinedValue) {
                              finallyApplySerializerName = serializerName;
                              currentValue = serializedValueItem;
                          }
                      }
                      return currentValue;
                  }, value);
                  // 需要用原始值判断，否则像new Number(1)等包装类也会是[object Object]
                  const toStringTag = ObjectCls.prototype.toString.call(value);
                  if (toStringTag === '[object Object]') {
                      value = { ...value };
                  }
                  else if (isArray(value)) {
                      value = [...value];
                  }
                  return finallyApplySerializerName !== undefinedValue ? [finallyApplySerializerName, serializedValue] : value;
              });
          }
          return payload;
      };
      /**
       * 反序列化数据
       */
      const deserialize = (payload) => isObject(payload)
          ? walkObject(payload, value => {
              if (isArray(value) && len(value) === 2) {
                  const foundSerializer = serializers[value[0]];
                  value = foundSerializer ? foundSerializer.backward(value[1]) : value;
              }
              return value;
          }, falseValue)
          : payload;
      return {
          serialize,
          deserialize
      };
  };

  const symbolVDataId = Symbol('vdid');
  const symbolOriginal = Symbol('original');
  const regVDataId = /\[vd:([0-9a-z]+)\]/;

  /**
   * 统一的vData收集函数
   * 它将在以下4个位置被调用
   * 1. 访问子属性时
   * 2. 参与计算并触发[Symbol.toPrimitive]时
   * 3. 获取vData的id时
   * 4. 获取其原始值时
   *
   * @param returnValue 返回值，如果是函数则调用它
   * @returns 收集函数
   */
  const vDataCollectUnified = (target) => {
      const vDataId = target === null || target === void 0 ? void 0 : target[symbolVDataId];
      vDataId && vDataIdCollectBasket && (vDataIdCollectBasket[vDataId] = undefinedValue);
  };
  // export const vDataGetter = (key: string) => vDataCollectGetter((thisObj: any) => thisObj.__proto__[key].call(thisObj));

  /**
   * 虚拟数据字符串化，如果参数不是虚拟数据则返回原数据
   * @param target 虚拟数据
   * @param returnOriginalIfNotVData 如果不是虚拟数据则返回原值
   * @returns 虚拟数据id或原数据
   */
  const stringifyVData = (target, returnOriginalIfNotVData = trueValue) => {
      vDataCollectUnified(target);
      const vDataIdRaw = target === null || target === void 0 ? void 0 : target[symbolVDataId];
      const vDataId = vDataIdRaw ? `[vd:${vDataIdRaw}]` : undefinedValue;
      return vDataId || (returnOriginalIfNotVData ? target : undefinedValue);
  };
  /**
   * 创建虚拟数据id收集的getter函数
   * @param valueReturnFn 返回值函数
   * @returns getter函数
   */
  function stringifyWithThis() {
      return stringifyVData(this);
  }

  /**
   * Null包装类实现
   */
  const Null = function Null() { };
  Null.prototype = ObjectCls.create(nullValue, {
      [STR_VALUE_OF]: valueObject(stringifyWithThis)
  });

  /**
   * Undefined包装类实现
   */
  const Undefined = function Undefined() { };
  Undefined.prototype = ObjectCls.create(nullValue, {
      [STR_VALUE_OF]: valueObject(stringifyWithThis)
  });

  /**
   * 创建虚拟响应数据
   * @returns 虚拟响应数据代理实例
   */
  var createVirtualResponse = (structure, vDataId = uuid$1()) => {
      const transform2VData = (value, vDataIdInner = uuid$1()) => {
          if (value === nullValue) {
              value = newInstance$1(Null);
          }
          else if (value === undefinedValue) {
              value = newInstance$1(Undefined);
          }
          else {
              const newValue = ObjectCls(value);
              defineProperty(newValue, STR_VALUE_OF, stringifyWithThis);
              defineProperty(newValue, symbolOriginal, value);
              value = newValue;
          }
          defineProperty(value, symbolVDataId, vDataIdInner);
          return value;
      };
      const virtualResponse = transform2VData(structure, vDataId);
      if (isPlainObject(virtualResponse) || isArray(virtualResponse)) {
          walkObject(virtualResponse, value => transform2VData(value));
      }
      return virtualResponse;
  };

  /**
   * 获取带虚拟数据变量的原始值
   * 此函数也将会进行vData收集
   * @param target 目标值
   * @param deepDehydrate 是否深度脱水值
   * @returns 具有原始类型的目标值
   */
  const dehydrateVDataUnified = (target, deepDehydrate = trueValue) => {
      const dehydrateItem = (value) => {
          vDataCollectUnified(value);
          if (value === null || value === void 0 ? void 0 : value[symbolVDataId]) {
              if (instanceOf(value, Undefined)) {
                  value = undefinedValue;
              }
              else if (instanceOf(value, Null)) {
                  value = nullValue;
              }
              else if (instanceOf(value, Number) || instanceOf(value, String) || instanceOf(value, Boolean)) {
                  value = value[symbolOriginal];
              }
          }
          return value;
      };
      const newTarget = dehydrateItem(target);
      // 如果是对象或数组，需要深度遍历获取虚拟数据值
      if (deepDehydrate && (isObject(newTarget) || isArray(newTarget))) {
          walkObject(newTarget, value => dehydrateItem(value));
      }
      return newTarget;
  };
  /**
   * 上面函数deepDehydrate为true的版本
   */
  var dehydrateVData = (target) => dehydrateVDataUnified(target);

  const vDataKey = '__$k';
  const vDataValueKey = '__$v';
  const getAlovaStorage = () => {
      // 未启动silentFactory时提供提示
      silentAssert(!!dependentAlovaInstance, 'alova instance is not found, Do you forget to set `alova` or call `bootSilentFactory`?');
      return dependentAlovaInstance.l2Cache;
  };
  let serializerPerformer = undefinedValue;
  const silentMethodIdQueueMapStorageKey = 'alova.SQ'; // silentMethod实例id组成的队列集合缓存key
  const silentMethodStorageKeyPrefix = 'alova.SM.'; // silentMethod实例缓存key前缀
  /**
   * 持久化带虚拟数据和可序列化的数据集合
   * @param key 持久化key
   * @param payload 持久化数据
   */
  const storageSetItem = async (key, payload) => {
      const storage = getAlovaStorage();
      if (isObject(payload)) {
          payload = walkObject(isArray(payload) ? [...payload] : { ...payload }, (value, key, parent) => {
              var _a;
              if (key === vDataValueKey && parent[vDataKey]) {
                  return value;
              }
              // 如果序列化的是silentMethod实例，则过滤掉alova实例
              if (key === 'context' && ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Alova') {
                  return undefinedValue;
              }
              const vDataId = value === null || value === void 0 ? void 0 : value[symbolVDataId];
              let primitiveValue = dehydrateVDataUnified(value, falseValue);
              // 需要用原始值判断，否则像new Number(1)等包装类也会是[object Object]
              const toStringTag = globalToString(primitiveValue);
              if (toStringTag === '[object Object]') {
                  value = { ...value };
                  primitiveValue = {};
              }
              else if (isArray(value)) {
                  value = [...value];
                  primitiveValue = [];
              }
              if (vDataId) {
                  const valueWithVData = {
                      [vDataKey]: vDataId,
                      // 对于对象和数组来说，它内部的属性会全部通过`...value`放到外部，因此内部的不需要再进行遍历转换了
                      // 因此将数组或对象置空，这样既避免了重复转换，又避免了污染原对象
                      [vDataValueKey]: primitiveValue,
                      ...value
                  };
                  // 如果是String类型，将会有像数组一样的如0、1、2为下标，值为字符的项，需将他们过滤掉
                  if (instanceOf(value, String)) {
                      for (let i = 0; i < len(value); i += 1) {
                          valueWithVData === null || valueWithVData === void 0 ? true : delete valueWithVData[i];
                      }
                  }
                  // 如果转换成了虚拟数据，则将转换值赋给它内部，并在下面逻辑中统一由value处理
                  value = valueWithVData;
              }
              return value;
          });
      }
      serializerPerformer = serializerPerformer || createSerializerPerformer(customSerializers);
      await storage.set(key, serializerPerformer.serialize(payload));
  };
  /**
   * 取出持久化数据，并将数据转换为虚拟数据和已序列化数据
   * @param key 持久化数据的key
   */
  const storageGetItem = async (key) => {
      const storagedResponse = await getAlovaStorage().get(key);
      serializerPerformer = serializerPerformer || createSerializerPerformer(customSerializers);
      return isObject(storagedResponse)
          ? walkObject(serializerPerformer.deserialize(storagedResponse), value => {
              // 将虚拟数据格式转换回虚拟数据实例
              if (isObject(value) && (value === null || value === void 0 ? void 0 : value[vDataKey])) {
                  const vDataId = value[vDataKey];
                  const vDataValue = createVirtualResponse(value[vDataValueKey], vDataId);
                  forEach(objectKeys(value), key => {
                      if (!includes([vDataKey, vDataValueKey], key)) {
                          vDataValue[key] = value[key];
                      }
                  });
                  value = vDataValue;
              }
              return value;
          }, falseValue)
          : storagedResponse;
  };
  /**
   * 移除持久化数据
   * @param key 持久化数据的key
   */
  const storageRemoveItem = async (key) => {
      await getAlovaStorage().remove(key);
  };

  /**
   * 序列化并保存silentMethod实例
   * @param silentMethodInstance silentMethod实例
   */
  const persistSilentMethod = (silentMethodInstance) => storageSetItem(silentMethodStorageKeyPrefix + silentMethodInstance.id, silentMethodInstance);
  /**
   * 将静默请求的配置信息放入对应storage中
   * 逻辑：通过构造一个key，并用这个key将静默方法的配置信息放入对应storage中，然后将key存入统一管理key的存储中
   * @param silentMethod SilentMethod实例
   * @param queue 操作的队列名
   */
  const push2PersistentSilentQueue = async (silentMethodInstance, queueName) => {
      await persistSilentMethod(silentMethodInstance);
      // 将silentMethod实例id保存到queue存储中
      const silentMethodIdQueueMap = ((await storageGetItem(silentMethodIdQueueMapStorageKey)) ||
          {});
      const currentQueue = (silentMethodIdQueueMap[queueName] = silentMethodIdQueueMap[queueName] || []);
      pushItem$1(currentQueue, silentMethodInstance.id);
      await storageSetItem(silentMethodIdQueueMapStorageKey, silentMethodIdQueueMap);
  };
  /**
   * 对缓存中的silentMethod实例移除或替换
   * @param queue 操作的队列名
   * @param targetSilentMethodId 目标silentMethod实例id
   * @param newSilentMethod 替换的新silentMethod实例，未传则表示删除
   */
  const spliceStorageSilentMethod = async (queueName, targetSilentMethodId, newSilentMethod) => {
      // 将silentMethod实例id从queue中移除
      const silentMethodIdQueueMap = ((await storageGetItem(silentMethodIdQueueMapStorageKey)) ||
          {});
      const currentQueue = silentMethodIdQueueMap[queueName] || [];
      const index = currentQueue.findIndex(id => id === targetSilentMethodId);
      if (index >= 0) {
          if (newSilentMethod) {
              splice(currentQueue, index, 1, newSilentMethod.id);
              await persistSilentMethod(newSilentMethod);
          }
          else {
              splice(currentQueue, index, 1);
          }
          await storageRemoveItem(silentMethodStorageKeyPrefix + targetSilentMethodId);
          // 队列为空时删除此队列
          len(currentQueue) <= 0 && delete silentMethodIdQueueMap[queueName];
          if (len(objectKeys(silentMethodIdQueueMap)) > 0) {
              await storageSetItem(silentMethodIdQueueMapStorageKey, silentMethodIdQueueMap);
          }
          else {
              // 队列集合为空时移除它
              await storageRemoveItem(silentMethodIdQueueMapStorageKey);
          }
      }
  };

  /** 静默方法队列集合 */
  let silentQueueMap = {};
  /**
   * 合并queueMap到silentMethod队列集合
   * @param queueMap silentMethod队列集合
   */
  const merge2SilentQueueMap = (queueMap) => {
      forEach(objectKeys(queueMap), targetQueueName => {
          const currentQueue = (silentQueueMap[targetQueueName] = silentQueueMap[targetQueueName] || []);
          pushItem$1(currentQueue, ...queueMap[targetQueueName]);
      });
  };
  /**
   * 深层遍历目标数据，并将虚拟数据替换为实际数据
   * @param target 目标数据
   * @param vDataResponse 虚拟数据和实际数据的集合
   * @returns 是否有替换数据
   */
  const deepReplaceVData = (target, vDataResponse) => {
      // 搜索单一值并将虚拟数据对象或虚拟数据id替换为实际值
      const replaceVData = (value) => {
          const vData = stringifyVData(value);
          // 如果直接是虚拟数据对象并且在vDataResponse中，则使用vDataResponse中的值替换Map
          // 如果是字符串，则里面可能包含虚拟数据id并且在vDataResponse中，也需将它替换为实际值Map
          // 不在本次vDataResponse中的虚拟数据将不变，它可能是下一次请求的虚拟数据Map
          if (vData in vDataResponse) {
              return vDataResponse[vData];
          }
          if (isString(value)) {
              return value.replace(newInstance$1(RegExpCls, regVDataId.source, 'g'), mat => mat in vDataResponse ? vDataResponse[mat] : mat);
          }
          return value;
      };
      if (isObject(target) && !stringifyVData(target, falseValue)) {
          walkObject(target, replaceVData);
      }
      else {
          target = replaceVData(target);
      }
      return target;
  };
  /**
   * 更新队列内的method实例，将虚拟数据替换为实际数据
   * @param vDataResponse 虚拟id和对应真实数据的集合
   * @param targetQueue 目标队列
   */
  const updateQueueMethodEntities = (vDataResponse, targetQueue) => PromiseCls.all(mapItem$1(targetQueue, async (silentMethodItem) => {
      // 深层遍历entity对象，如果发现有虚拟数据或虚拟数据id，则替换为实际数据
      deepReplaceVData(silentMethodItem.entity, vDataResponse);
      // 如果method实例有更新，则重新持久化此silentMethod实例
      silentMethodItem.cache && (await persistSilentMethod(silentMethodItem));
  }));
  /**
   * 使用响应数据替换虚拟数据
   * @param response 真实响应数据
   * @param virtualResponse 虚拟响应数据
   * @returns 虚拟数据id所构成的对应真实数据集合
   */
  const replaceVirtualResponseWithResponse = (virtualResponse, response) => {
      let vDataResponse = {};
      const vDataId = stringifyVData(virtualResponse, falseValue);
      vDataId && (vDataResponse[vDataId] = response);
      if (isObject(virtualResponse)) {
          for (const i in virtualResponse) {
              vDataResponse = {
                  ...vDataResponse,
                  ...replaceVirtualResponseWithResponse(virtualResponse[i], response === null || response === void 0 ? void 0 : response[i])
              };
          }
      }
      return vDataResponse;
  };
  /**
   * 启动SilentMethod队列
   * 1. 静默提交将会放入队列中，并按顺序发送请求，只有等到前一个请求响应后才继续发送后面的请求
   * 2. 重试次数只有在未响应时才触发，在服务端响应错误或断网情况下，不会重试
   * 3. 在达到重试次数仍未成功时，当设置了nextRound（下一轮）时延迟nextRound指定的时间后再次请求，否则将在刷新后再次尝试
   * 4. 如果有resolveHandler和rejectHandler，将在请求完成后（无论成功还是失败）调用，通知对应的请求继续响应
   *
   * @param queue SilentMethod队列
   */
  const setSilentMethodActive = (silentMethodInstance, active) => {
      if (active) {
          silentMethodInstance.active = active;
      }
      else {
          delete silentMethodInstance.active;
      }
  };
  const defaultBackoffDelay = 1000;
  const bootSilentQueue = (queue, queueName) => {
      /**
       * 根据请求等待参数控制回调函数的调用，如果未设置或小于等于0则立即触发
       * @param queueName 队列名称
       * @param callback 回调函数
       */
      const emitWithRequestDelay = (queueName) => {
          const nextSilentMethod = queue[0];
          if (nextSilentMethod) {
              const targetSetting = queueRequestWaitSetting.find(({ queue }) => instanceOf(queue, RegExpCls) ? regexpTest(queue, queueName) : queue === queueName);
              // eslint-disable-next-line @typescript-eslint/no-use-before-define
              const callback = () => queue[0] && silentMethodRequest(queue[0]);
              const delay = (targetSetting === null || targetSetting === void 0 ? void 0 : targetSetting.wait) ? sloughConfig(targetSetting.wait, [nextSilentMethod, queueName]) : 0;
              delay && delay > 0 ? setTimeoutFn(callback, delay) : callback();
          }
      };
      /**
       * 运行单个silentMethod实例
       * @param silentMethodInstance silentMethod实例
       * @param retryTimes 重试的次数
       */
      const silentMethodRequest = (silentMethodInstance, retryTimes = 0) => {
          // 将当前silentMethod实例设置活跃状态
          setSilentMethodActive(silentMethodInstance, trueValue);
          const { cache, id, behavior, entity, retryError = /.*/, maxRetryTimes = 0, backoff = { delay: defaultBackoffDelay }, resolveHandler = noop, rejectHandler = noop, emitter: methodEmitter, handlerArgs = [], virtualResponse, force } = silentMethodInstance;
          // 触发请求前事件
          globalSQEventManager.emit(BeforeEventKey, newInstance$1((GlobalSQEvent), behavior, entity, silentMethodInstance, queueName, retryTimes));
          promiseThen(entity.send(force), async (data) => {
              // 请求成功，移除成功的silentMethod实力，并继续下一个请求
              shift(queue);
              // 请求成功，把成功的silentMethod实例在storage中移除，并继续下一个请求
              cache && (await spliceStorageSilentMethod(queueName, id));
              // 如果有resolveHandler则调用它通知外部
              resolveHandler(data);
              // 有virtualResponse时才遍历替换虚拟数据，且触发全局事件
              // 一般为silent behavior，而queue behavior不需要
              if (behavior === BEHAVIOR_SILENT) {
                  // 替换队列中后面方法实例中的虚拟数据为真实数据
                  // 开锁后才能正常访问virtualResponse的层级结构
                  const vDataResponse = replaceVirtualResponseWithResponse(virtualResponse, data);
                  const { targetRefMethod, updateStates } = silentMethodInstance; // 实时获取才准确
                  // 如果此silentMethod带有targetRefMethod，则再次调用updateState更新数据
                  // 此为延迟数据更新的实现
                  if (instanceOf(targetRefMethod, alova.Method) && updateStates && len(updateStates) > 0) {
                      const updateStateCollection = {};
                      forEach(updateStates, stateName => {
                          // 请求成功后，将带有虚拟数据的数据替换为实际数据
                          updateStateCollection[stateName] = dataRaw => deepReplaceVData(dataRaw, vDataResponse);
                      });
                      const updated = updateState(targetRefMethod, updateStateCollection);
                      // 修改状态不成功，则去修改缓存数据
                      if (!updated) {
                          await alova.setCache(targetRefMethod, (dataRaw) => deepReplaceVData(dataRaw, vDataResponse));
                      }
                  }
                  // 对当前队列的后续silentMethod实例进行虚拟数据替换
                  await updateQueueMethodEntities(vDataResponse, queue);
                  // 触发全局的成功事件
                  globalSQEventManager.emit(SuccessEventKey, newInstance$1((GlobalSQSuccessEvent), behavior, entity, silentMethodInstance, queueName, retryTimes, data, vDataResponse));
              }
              // 设为非激活状态
              setSilentMethodActive(silentMethodInstance, falseValue);
              // 继续下一个silentMethod的处理
              emitWithRequestDelay(queueName);
          }, reason => {
              if (behavior !== BEHAVIOR_SILENT) {
                  // 当behavior不为silent时，请求失败就触发rejectHandler
                  // 且在队列中移除，并不再重试
                  shift(queue);
                  rejectHandler(reason);
              }
              else {
                  // 每次请求错误都将触发错误回调
                  const runGlobalErrorEvent = (retryDelay) => globalSQEventManager.emit(ErrorEventKey, newInstance$1((GlobalSQErrorEvent), behavior, entity, silentMethodInstance, queueName, retryTimes, reason, retryDelay));
                  // 在silent行为模式下，判断是否需要重试
                  // 重试只有在响应错误符合retryError正则匹配时有效
                  const { name: errorName = '', message: errorMsg = '' } = reason || {};
                  let regRetryErrorName;
                  let regRetryErrorMsg;
                  if (instanceOf(retryError, RegExp)) {
                      regRetryErrorMsg = retryError;
                  }
                  else if (isObject(retryError)) {
                      regRetryErrorName = retryError.name;
                      regRetryErrorMsg = retryError.message;
                  }
                  const matchRetryError = (regRetryErrorName && regexpTest(regRetryErrorName, errorName)) ||
                      (regRetryErrorMsg && regexpTest(regRetryErrorMsg, errorMsg));
                  // 如果还有重试次数则进行重试
                  if (retryTimes < maxRetryTimes && matchRetryError) {
                      // 需要使用下次的retryTimes来计算延迟时间，因此这边需+1
                      const retryDelay = delayWithBackoff(backoff, retryTimes + 1);
                      runGlobalErrorEvent(retryDelay);
                      setTimeoutFn(() => {
                          retryTimes += 1;
                          silentMethodRequest(silentMethodInstance, retryTimes);
                          methodEmitter.emit('retry', newInstance$1((ScopedSQRetryEvent), behavior, entity, silentMethodInstance, handlerArgs, retryTimes, retryDelay));
                      }, 
                      // 还有重试次数时使用timeout作为下次请求时间
                      retryDelay);
                  }
                  else {
                      setSilentFactoryStatus(2);
                      runGlobalErrorEvent();
                      // 达到失败次数，或不匹配重试的错误信息时，触发失败回调
                      methodEmitter.emit('fallback', newInstance$1((ScopedSQErrorEvent), behavior, entity, silentMethodInstance, handlerArgs, reason));
                      globalSQEventManager.emit(FailEventKey$1, newInstance$1((GlobalSQFailEvent), behavior, entity, silentMethodInstance, queueName, retryTimes, reason));
                  }
              }
              // 设为非激活状态
              setSilentMethodActive(silentMethodInstance, falseValue);
          });
      };
      emitWithRequestDelay(queueName);
  };
  /**
   * 将新的silentMethod实例放入队列中
   * @param silentMethodInstance silentMethod实例
   * @param cache silentMethod是否有缓存
   * @param targetQueueName 目标队列名
   * @param onBeforePush silentMethod实例push前的事件
   */
  const pushNewSilentMethod2Queue = async (silentMethodInstance, cache, targetQueueName = DEFAULT_QUEUE_NAME, onBeforePush = () => []) => {
      silentMethodInstance.cache = cache;
      const currentQueue = (silentQueueMap[targetQueueName] =
          silentQueueMap[targetQueueName] || []);
      const isNewQueue = len(currentQueue) <= 0;
      const beforePushReturns = await Promise.all(onBeforePush());
      const isPush2Queue = !beforePushReturns.some(returns => returns === falseValue);
      // silent行为下，如果没有绑定fallback事件回调，则持久化
      // 如果在onBeforePushQueue返回false，也不再放入队列中
      if (isPush2Queue) {
          cache && (await push2PersistentSilentQueue(silentMethodInstance, targetQueueName));
          pushItem$1(currentQueue, silentMethodInstance);
          // 如果是新的队列且状态为已启动，则执行它
          isNewQueue && silentFactoryStatus === 1 && bootSilentQueue(currentQueue, targetQueueName);
      }
      return isPush2Queue;
  };

  /**
   * 定位silentMethod实例所在的位置
   * @param silentMethodInstance silentMethod实例
   */
  const getBelongQueuePosition = (silentMethodInstance) => {
      let queue = undefinedValue;
      let queueName = '';
      let position = 0;
      for (const queueNameLoop in silentQueueMap) {
          position = silentQueueMap[queueNameLoop].indexOf(silentMethodInstance);
          if (position >= 0) {
              queue = silentQueueMap[queueNameLoop];
              queueName = queueNameLoop;
              break;
          }
      }
      return [queue, queueName, position];
  };
  /**
   * silentMethod实例
   * 需要进入silentQueue的请求都将被包装成silentMethod实例，它将带有请求策略的各项参数
   */
  class SilentMethod {
      constructor(entity, behavior, emitter, id = uuid$1(), force, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, vDatas) {
          const thisObj = this;
          thisObj.entity = entity;
          thisObj.behavior = behavior;
          thisObj.id = id;
          thisObj.emitter = emitter;
          thisObj.force = !!force;
          thisObj.retryError = retryError;
          thisObj.maxRetryTimes = maxRetryTimes;
          thisObj.backoff = backoff;
          thisObj.resolveHandler = resolveHandler;
          thisObj.rejectHandler = rejectHandler;
          thisObj.handlerArgs = handlerArgs;
          thisObj.vDatas = vDatas;
      }
      /**
       * 允许缓存时持久化更新当前实例
       */
      async save() {
          this.cache && (await persistSilentMethod(this));
      }
      /**
       * 在队列中使用一个新的silentMethod实例替换当前实例
       * 如果有持久化缓存也将会更新缓存
       * @param newSilentMethod 新的silentMethod实例
       */
      async replace(newSilentMethod) {
          const targetSilentMethod = this;
          silentAssert(newSilentMethod.cache === targetSilentMethod.cache, 'the cache of new silentMethod must equal with this silentMethod');
          const [queue, queueName, position] = getBelongQueuePosition(targetSilentMethod);
          if (queue) {
              splice(queue, position, 1, newSilentMethod);
              targetSilentMethod.cache && (await spliceStorageSilentMethod(queueName, targetSilentMethod.id, newSilentMethod));
          }
      }
      /**
       * 移除当前实例，如果有持久化数据，也会同步移除
       */
      async remove() {
          const targetSilentMethod = this;
          const [queue, queueName, position] = getBelongQueuePosition(targetSilentMethod);
          if (queue) {
              splice(queue, position, 1);
              targetSilentMethod.cache && (await spliceStorageSilentMethod(queueName, targetSilentMethod.id));
          }
      }
      /**
       * 设置延迟更新状态对应的method实例以及对应的状态名
       * 它将在此silentMethod响应后，找到对应的状态数据并将vData更新为实际数据
       *
       * @param method method实例
       * @param updateStateName 更新的状态名，默认为data，也可以设置多个
       */
      setUpdateState(method, updateStateName = 'data') {
          if (method) {
              this.targetRefMethod = method;
              this.updateStates = isArray(updateStateName) ? updateStateName : [updateStateName];
          }
      }
  }

  /**
   * 反序列化silentMethod实例，根据序列化器的名称进行反序列化
   * @param methodInstance 请求方法实例
   * @returns 请求方法实例
   */
  var convertPayload2SilentMethod = (payload) => {
      const { id, behavior, entity, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, targetRefMethod, force } = payload;
      // method类实例化
      const deserializeMethod = (methodPayload) => {
          const { type, url, config, data } = methodPayload;
          return newInstance$1(alova.Method, type, dependentAlovaInstance, url, config, data);
      };
      const silentMethodInstance = newInstance$1(SilentMethod, deserializeMethod(entity), behavior, createEventManager(), id, force, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs);
      silentMethodInstance.cache = trueValue;
      // targetRefMethod反序列化
      if (targetRefMethod) {
          silentMethodInstance.targetRefMethod = deserializeMethod(targetRefMethod);
      }
      // 将额外的内容放到silentMethod实例上
      forEach(objectKeys(payload), key => {
          if (!includes([
              'id',
              'behavior',
              'emitter',
              'entity',
              'retryError',
              'maxRetryTimes',
              'backoff',
              'resolveHandler',
              'rejectHandler',
              'handlerArgs',
              'targetRefMethod',
              'force'
          ], key)) {
              silentMethodInstance[key] = payload[key];
          }
      });
      return silentMethodInstance;
  };

  /**
   * 从storage中载入静默队列数据
   * @returns 所有队列数据
   */
  var loadSilentQueueMapFromStorage = async () => {
      const silentMethodIdQueueMap = ((await storageGetItem(silentMethodIdQueueMapStorageKey)) ||
          {});
      const silentQueueMap = {};
      const readingPromises = [];
      forEach(objectKeys(silentMethodIdQueueMap), queueName => {
          const currentQueue = (silentQueueMap[queueName] = silentQueueMap[queueName] || []);
          pushItem$1(readingPromises, ...mapItem$1(silentMethodIdQueueMap[queueName], async (silentMethodId) => {
              const serializedSilentMethodPayload = await storageGetItem(silentMethodStorageKeyPrefix + silentMethodId);
              serializedSilentMethodPayload &&
                  pushItem$1(currentQueue, convertPayload2SilentMethod(serializedSilentMethodPayload));
          }));
      });
      await PromiseCls.all(readingPromises);
      return silentQueueMap;
  };

  /**
   * 绑定silentSubmit启动事件
   * @param {SilentSubmitBootHandler} handler 事件回调函数
   * @returns 解绑函数
   */
  const onSilentSubmitBoot = (handler) => globalSQEventManager.on(BootEventKey, handler);
  /**
   * 绑定silentSubmit成功事件
   * @param {SilentSubmitSuccessHandler} handler 事件回调函数
   * @returns 解绑函数
   */
  const onSilentSubmitSuccess = (handler) => globalSQEventManager.on(SuccessEventKey, handler);
  /**
   * 绑定silentSubmit错误事件
   * 每次请求错误，触发错误回调
   * @param {SilentSubmitErrorHandler} handler 事件回调函数
   * @returns 解绑函数
   */
  const onSilentSubmitError = (handler) => globalSQEventManager.on(ErrorEventKey, handler);
  /**
   * 绑定silentSubmit失败事件
   * 失败事件将在最大请求次数到达，或不匹配错误信息时触发
   * @param {SilentSubmitFailHandler} handler 事件回调函数
   * @returns 解绑函数
   */
  const onSilentSubmitFail = (handler) => globalSQEventManager.on(FailEventKey$1, handler);
  /**
   * 绑定silentSubmit发起请求前事件
   * @param {BeforeSilentSubmitHandler} handler 事件回调函数
   * @returns 解绑函数
   */
  const onBeforeSilentSubmit = (handler) => globalSQEventManager.on(BeforeEventKey, handler);
  /**
   * 启动静默提交，它将载入缓存中的静默方法，并开始静默提交
   * 如果未传入延迟时间，则立即同步启动
   * @param {SilentFactoryBootOptions} options 延迟毫秒数
   */
  const bootSilentFactory = (options) => {
      if (silentFactoryStatus === 0) {
          const { alova, delay = 500 } = options;
          setDependentAlova(alova);
          setCustomSerializers(options.serializers);
          setQueueRequestWaitSetting(options.requestWait);
          setTimeoutFn(async () => {
              // 延时加载，让页面的queue放在最前面
              merge2SilentQueueMap(await loadSilentQueueMapFromStorage());
              // 循环启动队列静默提交
              // 多条队列是并行执行的
              forEach(objectKeys(silentQueueMap), queueName => {
                  bootSilentQueue(silentQueueMap[queueName], queueName);
              });
              setSilentFactoryStatus(1); // 设置状态为已启动
              globalSQEventManager.emit(BootEventKey, undefinedValue);
          }, delay);
      }
  };

  /**
   * 以兼容虚拟数据的方式判断两个值是否相等
   * @param prevValue 前项值
   * @param nextValue 后项值
   * @returns 是否相等
   */
  var equals = (prevValue, nextValue) => {
      // 如果相等则直接返回
      if (prevValue === nextValue) {
          return trueValue;
      }
      return stringifyVData(prevValue) === stringifyVData(nextValue);
  };

  /**
   * 按method名称或正则表达式筛选满足条件的所有silentMethod实例
   * @param methodNameMatcher method名称匹配器
   * @param queueName 查找队列名，默认为default队列
   * @param filterActive 是否过滤掉激活状态的实例
   * @returns silentMethod实例数组
   */
  const filterSilentMethods = async (methodNameMatcher, queueName = DEFAULT_QUEUE_NAME, filterActive = falseValue) => {
      const matchSilentMethods = (targetQueue = []) => targetQueue.filter(silentMethodItem => {
          if (methodNameMatcher === undefinedValue) {
              return trueValue;
          }
          const name = getConfig(silentMethodItem.entity).name || '';
          const retain = instanceOf(methodNameMatcher, RegExp)
              ? regexpTest(methodNameMatcher, name)
              : name === methodNameMatcher;
          return retain && (filterActive ? silentMethodItem.active : trueValue);
      });
      return [
          ...matchSilentMethods(silentQueueMap[queueName]),
          // 如果当前未启动silentFactory，则还需要去持久化存储中匹配silentMethods
          ...(silentFactoryStatus === 0 ? matchSilentMethods((await loadSilentQueueMapFromStorage())[queueName]) : [])
      ];
  };
  /**
   * 按method名称或正则表达式查找第一个满足条件的silentMethod实例
   * @param methodNameMatcher method名称匹配器
   * @param queueName 查找队列名，默认为default队列
   * @param filterActive 是否过滤掉激活状态的实例
   * @returns silentMethod实例，未找到时为undefined
   */
  const getSilentMethod = async (methodNameMatcher, queueName = DEFAULT_QUEUE_NAME, filterActive = falseValue) => (await filterSilentMethods(methodNameMatcher, queueName, filterActive))[0];

  /**
   * 判断目标数据是否为虚拟数据
   * @param target 目标数据
   * @returns 是否为虚拟数据
   */
  var isVData = (target) => !!stringifyVData(target, falseValue) || regexpTest(regVDataId, target);

  /**
   * 全局的silentMethod实例，它将在第一个成功事件触发前到最后一个成功事件触发后有值（同步时段）
   * 通过此方式让onSuccess中的updateStateEffect内获得当前的silentMethod实例
   */
  let currentSilentMethod = undefinedValue;
  /**
   * 创建SilentQueue中间件函数
   * @param config 配置对象
   * @returns 中间件函数
   */
  var createSilentQueueMiddlewares = (handler, config) => {
      const { behavior = 'queue', queue = DEFAULT_QUEUE_NAME, retryError, maxRetryTimes, backoff } = config || {};
      const eventEmitter = createEventManager();
      let handlerArgs;
      let behaviorFinally;
      let queueFinally = DEFAULT_QUEUE_NAME;
      let forceRequest = falseValue;
      let silentMethodInstance;
      /**
       * method实例创建函数
       * @param args 调用send传入的函数
       * @returns method实例
       */
      const createMethod = (...args) => {
          silentAssert(isFn(handler), 'method handler must be a function. eg. useSQRequest(() => method)');
          setVDataIdCollectBasket({});
          handlerArgs = args;
          return handler(...args);
      };
      // 装饰success/error/complete事件
      const decorateRequestEvent = (requestExposure) => {
          // 设置事件回调装饰器
          requestExposure.onSuccess = decorateEvent(requestExposure.onSuccess, (handler, event) => {
              currentSilentMethod = silentMethodInstance;
              handler(newInstance$1((ScopedSQSuccessEvent), behaviorFinally, event.method, silentMethodInstance, event.args, event.data));
          });
          requestExposure.onError = decorateEvent(requestExposure.onError, (handler, event) => {
              handler(newInstance$1((ScopedSQErrorEvent), behaviorFinally, event.method, silentMethodInstance, event.args, event.error));
          });
          requestExposure.onComplete = decorateEvent(requestExposure.onComplete, (handler, event) => {
              handler(newInstance$1((ScopedSQCompleteEvent), behaviorFinally, event.method, silentMethodInstance, event.args, event.status, event.data, event.error));
          });
      };
      /**
       * 中间件函数
       * @param context 请求上下文，包含请求相关的值
       * @param next 继续执行函数
       * @returns Promise对象
       */
      const middleware = ({ method, args, cachedResponse, proxyStates, config }, next) => {
          const { silentDefaultResponse, vDataCaptured, force = falseValue } = config;
          // 因为behavior返回值可能会变化，因此每次请求都应该调用它重新获取返回值
          const baseEvent = AlovaEventBase.spawn(method, args);
          behaviorFinally = sloughConfig(behavior, [baseEvent]);
          queueFinally = sloughConfig(queue, [baseEvent]);
          forceRequest = sloughConfig(force, [baseEvent]);
          // 置空临时收集变量
          // 返回前都需要置空它们
          const resetCollectBasket = () => {
              setVDataIdCollectBasket((handlerArgs = undefinedValue));
          };
          // 如果设置了vDataCaptured，则先判断请求相关的数据是否包含虚拟数据
          if (isFn(vDataCaptured)) {
              let hasVData = vDataIdCollectBasket && len(objectKeys(vDataIdCollectBasket)) > 0;
              if (!hasVData) {
                  const { url, data } = method;
                  const { params, headers } = getConfig(method);
                  walkObject({ url, params, data, headers }, value => {
                      if (!hasVData && (stringifyVData(value, falseValue) || regexpTest(regVDataId, value))) {
                          hasVData = trueValue;
                      }
                      return value;
                  });
              }
              // 如果vDataCaptured有返回数据，则使用它作为响应数据，否则继续请求
              const customResponse = hasVData ? vDataCaptured(method) : undefinedValue;
              if (customResponse !== undefinedValue) {
                  resetCollectBasket(); // 被vDataCaptured捕获时的重置
                  return promiseResolve(customResponse);
              }
          }
          if (behaviorFinally !== BEHAVIOR_STATIC) {
              // 等待队列中的method执行完毕
              const createSilentMethodPromise = () => {
                  const queueResolvePromise = newInstance$1(PromiseCls, (resolveHandler, rejectHandler) => {
                      silentMethodInstance = newInstance$1((SilentMethod), method, behaviorFinally, eventEmitter, undefinedValue, !!forceRequest, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, vDataIdCollectBasket && objectKeys(vDataIdCollectBasket));
                      resetCollectBasket(); // behavior为queue和silent时的重置
                  });
                  // onBeforePush和onPushed事件是同步绑定的，因此需要异步执行入队列才能正常触发事件
                  promiseThen(promiseResolve(undefinedValue), async () => {
                      const createPushEvent = () => newInstance$1((ScopedSQEvent), behaviorFinally, method, silentMethodInstance, args);
                      // 将silentMethod放入队列并持久化
                      const isPushed = await pushNewSilentMethod2Queue(silentMethodInstance, 
                      // onFallback绑定了事件后，即使是silent行为模式也不再存储
                      // onFallback会同步调用，因此需要异步判断是否存在fallbackHandlers
                      len(eventEmitter.eventMap.fallback || []) <= 0 && behaviorFinally === BEHAVIOR_SILENT, queueFinally, 
                      // 执行放入队列前回调，如果返回false则阻止放入队列
                      () => eventEmitter.emit('beforePushQueue', createPushEvent()));
                      // 只有在放入队列后，才执行放入队列后的回调
                      isPushed && eventEmitter.emit('pushedQueue', createPushEvent());
                  });
                  return queueResolvePromise;
              };
              if (behaviorFinally === BEHAVIOR_QUEUE) {
                  // 强制请求，或命中缓存时需要更新loading状态
                  const needSendRequest = forceRequest || !cachedResponse;
                  if (needSendRequest) {
                      // 手动设置为true
                      proxyStates.loading.v = trueValue;
                  }
                  // 当使用缓存时，直接使用缓存，否则再进入请求队列
                  return needSendRequest ? createSilentMethodPromise() : promiseThen(promiseResolve(cachedResponse));
              }
              const silentMethodPromise = createSilentMethodPromise();
              // 在silent模式下创建虚拟响应数据，虚拟响应数据可生成任意的虚拟数据
              const virtualResponse = (silentMethodInstance.virtualResponse = createVirtualResponse(isFn(silentDefaultResponse) ? silentDefaultResponse() : undefinedValue));
              promiseThen(silentMethodPromise, realResponse => {
                  // 获取到真实数据后更新过去
                  proxyStates.data.v = realResponse;
              });
              // silent模式下，先立即返回虚拟响应值，然后当真实数据返回时再更新
              return promiseResolve(virtualResponse);
          }
          resetCollectBasket(); // behavior为static时的重置
          return next();
      };
      return {
          c: createMethod,
          m: middleware,
          d: decorateRequestEvent,
          // 事件绑定函数
          b: {
              /**
               * 绑定回退事件
               * @param handler 回退事件回调
               */
              onFallback: (handler) => {
                  eventEmitter.on('fallback', handler);
              },
              /**
               * 绑定入队列前事件
               * @param handler 入队列前的事件回调
               */
              onBeforePushQueue: (handler) => {
                  eventEmitter.on('beforePushQueue', handler);
              },
              /**
               * 绑定入队列后事件
               * @param handler 入队列后的事件回调
               */
              onPushedQueue: (handler) => {
                  eventEmitter.on('pushedQueue', handler);
              },
              /**
               * 重试事件
               * @param handler 重试事件回调
               */
              onRetry: (handler) => {
                  eventEmitter.on('retry', handler);
              }
          }
      };
  };

  /**
   * 更新对应method的状态
   * 与updateState不同的是，除了立即更新状态外，它还会在silent模式下响应后再次更新一次，目的是将虚拟数据替换为实际数据
   * @param method 请求方法对象
   * @param handleUpdate 更新回调
   */
  const updateStateEffect = async (matcher, handleUpdate) => {
      // 将目标method实例保存到当前的silentMethod实例
      if (currentSilentMethod) {
          currentSilentMethod.setUpdateState(matcher, isFn(updateState) ? undefinedValue : objectKeys(updateState));
          await currentSilentMethod.save();
      }
      return updateState(matcher, handleUpdate);
  };

  const actionsMap = {};
  const isFrontMiddlewareContext = (context) => !!context.send;
  const assert$2 = createAssert('subscriber');
  /**
   * 操作函数委托中间件
   * 使用此中间件后可通过accessAction调用委托的函数
   * 可以委托多个相同id
   * 以此来消除组件的层级限制
   * @param id 委托者id
   * @returns alova中间件函数
   */
  const actionDelegationMiddleware = (id) => {
      const { ref } = statesHookHelper(alova.promiseStatesHook());
      const delegated = ref(falseValue);
      return (context, next) => {
          // 中间件会重复调用，已经订阅过了就无需再订阅了
          if (!delegated.current) {
              const { abort, proxyStates, delegatingActions = {} } = context;
              const update = (newStates) => {
                  for (const key in newStates) {
                      proxyStates[key] && (proxyStates[key].v = newStates[key]);
                  }
              };
              // 相同id的将以数组形式保存在一起
              const handlersItems = (actionsMap[id] = actionsMap[id] || []);
              handlersItems.push(isFrontMiddlewareContext(context)
                  ? {
                      ...delegatingActions,
                      send: context.send,
                      abort,
                      update
                  }
                  : {
                      ...delegatingActions,
                      fetch: context.fetch,
                      abort,
                      update
                  });
              delegated.current = trueValue;
          }
          return next();
      };
  };
  /**
   * 访问操作函数，如果匹配多个则会以此调用onMatch
   * @param id 委托者id，或正则表达式
   * @param onMatch 匹配的订阅者
   * @param silent 默认为 false。如果为 true，不匹配时将不会报错
   */
  const accessAction = (id, onMatch, silent = false) => {
      const matched = [];
      if (typeof id === 'symbol' || isString(id) || isNumber(id)) {
          actionsMap[id] && pushItem$1(matched, ...actionsMap[id]);
      }
      else if (instanceOf(id, RegExp)) {
          forEach(filterItem$1(objectKeys(actionsMap), idItem => id.test(idItem)), idItem => {
              pushItem$1(matched, ...actionsMap[idItem]);
          });
      }
      // its opposite expression is too obscure
      if (matched.length === 0 && !silent) {
          assert$2(false, `no handler can be matched by using \`${id.toString()}\``);
      }
      forEach(matched, onMatch);
  };

  var createSnapshotMethodsManager = (handler) => {
      let methodSnapshots = {};
      return {
          snapshots: () => methodSnapshots,
          save(methodInstance, force = falseValue) {
              const key = getMethodInternalKey(methodInstance);
              // 因为无法定位缓存中total数据的位置
              // 因此这边冗余维护这个字段
              if (!methodSnapshots[key] || force) {
                  methodSnapshots[key] = {
                      entity: methodInstance
                  };
              }
          },
          get: (entityOrPage) => methodSnapshots[getMethodInternalKey(instanceOf(entityOrPage, (alova.Method)) ? entityOrPage : handler(entityOrPage))],
          remove(key) {
              if (key) {
                  delete methodSnapshots[key];
              }
              else {
                  methodSnapshots = {};
              }
          }
      };
  };

  const paginationAssert = createAssert('usePagination');
  const indexAssert = (index, rawData) => paginationAssert(isNumber(index) && index < len(rawData), 'index must be a number that less than list length');
  var usePagination = (handler, config = {}) => {
      const { create, computed, ref, watch, exposeProvider, objectify, __referingObj: referingObject } = statesHookHelper(alova.promiseStatesHook());
      const { preloadPreviousPage = trueValue, preloadNextPage = trueValue, total: totalGetter = res => res.total, data: dataGetter = res => res.data, append = falseValue, initialPage = 1, initialPageSize = 10, watchingStates = [], initialData, immediate = trueValue, middleware = noop, force = noop, ...others } = config;
      const handlerRef = ref(handler);
      const isReset = ref(falseValue); // 用于控制是否重置
      // 重置期间请求的次数，为了防止重置时重复请求，使用此参数限制请求
      const page = create(initialPage, 'page');
      const pageSize = create(initialPageSize, 'pageSize');
      const data = create((initialData ? dataGetter(initialData) || [] : []), 'data');
      const total = create(initialData ? totalGetter(initialData) : undefinedValue, 'total');
      // 保存当前hook所使用到的所有method实例快照
      const { snapshots: methodSnapshots, get: getSnapshotMethods, save: saveSnapshot, remove: removeSnapshot } = ref(createSnapshotMethodsManager(page => handlerRef.current(page, pageSize.v))).current;
      const listDataGetter = (rawData) => dataGetter(rawData) || rawData;
      // 初始化fetcher
      const fetchStates = useFetcher({
          __referingObj: referingObject,
          updateState: falseValue,
          force: ({ args }) => args[0]
      });
      const { loading, fetch, abort: abortFetch, onSuccess: onFetchSuccess } = fetchStates;
      const fetchingRef = ref(loading);
      const getHandlerMethod = (refreshPage = page.v) => {
          const pageSizeVal = pageSize.v;
          const handlerMethod = handler(refreshPage, pageSizeVal);
          // 定义统一的额外名称，方便管理
          saveSnapshot(handlerMethod);
          return handlerMethod;
      };
      // 监听状态变化时，重置page为1
      watch(watchingStates, () => {
          page.v = initialPage;
          isReset.current = trueValue;
      });
      // 兼容react，将需要代理的函数存放在此
      // 这样可以在代理函数中调用到最新的操作函数，避免react闭包陷阱
      const delegationActions = ref({});
      // 计算data、total、isLastPage参数
      const pageCount = computed(() => {
          const totalVal = total.v;
          return totalVal !== undefinedValue ? Math.ceil(totalVal / pageSize.v) : undefinedValue;
      }, [pageSize, total], 'pageCount');
      const createDelegationAction = (actionName) => (...args) => delegationActions.current[actionName](...args);
      const states = useWatcher(getHandlerMethod, [...watchingStates, page.e, pageSize.e], {
          __referingObj: referingObject,
          immediate,
          initialData,
          managedStates: objectify([data, page, pageSize, total], 's'),
          middleware(ctx, next) {
              middleware({
                  ...ctx,
                  delegatingActions: {
                      refresh: createDelegationAction('refresh'),
                      insert: createDelegationAction('insert'),
                      remove: createDelegationAction('remove'),
                      replace: createDelegationAction('replace'),
                      reload: createDelegationAction('reload'),
                      getState: (stateKey) => {
                          const states = {
                              page,
                              pageSize,
                              data,
                              pageCount,
                              total,
                              // eslint-disable-next-line @typescript-eslint/no-use-before-define
                              isLastPage
                          };
                          return states[stateKey].v;
                      }
                  }
              }, promiseResolve);
              return next();
          },
          force: event => event.args[1] || (isFn(force) ? force(event) : force),
          ...others
      });
      const { send } = states;
      const nestedData = states.__proxyState('data');
      // 判断是否可预加载数据
      const canPreload = async (payload) => {
          const { rawData = nestedData.v, preloadPage, fetchMethod, forceRequest = falseValue, isNextPage = falseValue } = payload;
          const { e: expireMilliseconds } = getLocalCacheConfigParam(fetchMethod);
          // 如果缓存时间小于等于当前时间，表示没有设置缓存，此时不再预拉取数据
          // 或者已经有缓存了也不预拉取
          if (expireMilliseconds(MEMORY) <= getTime()) {
              return falseValue;
          }
          if (forceRequest) {
              return trueValue;
          }
          if (await alova.queryCache(fetchMethod)) {
              return falseValue;
          }
          const pageCountVal = pageCount.v;
          const exceedPageCount = pageCountVal
              ? preloadPage > pageCountVal
              : isNextPage // 如果是判断预加载下一页数据且没有pageCount的情况下，通过最后一页数据量是否达到pageSize来判断
                  ? len(listDataGetter(rawData)) < pageSize.v
                  : falseValue;
          return preloadPage > 0 && !exceedPageCount;
      };
      // 预加载下一页数据
      const fetchNextPage = async (rawData, force = falseValue) => {
          const nextPage = page.v + 1;
          const fetchMethod = getHandlerMethod(nextPage);
          if (preloadNextPage &&
              (await canPreload({
                  rawData,
                  preloadPage: nextPage,
                  fetchMethod,
                  isNextPage: trueValue,
                  forceRequest: force
              }))) {
              promiseCatch(fetch(fetchMethod, force), noop);
          }
      };
      // 预加载上一页数据
      const fetchPreviousPage = async (rawData) => {
          const prevPage = page.v - 1;
          const fetchMethod = getHandlerMethod(prevPage);
          if (preloadPreviousPage &&
              (await canPreload({
                  rawData,
                  preloadPage: prevPage,
                  fetchMethod
              }))) {
              promiseCatch(fetch(fetchMethod), noop);
          }
      };
      // 如果返回的数据小于pageSize了，则认定为最后一页了
      const isLastPage = computed(() => {
          const dataRaw = nestedData.v;
          if (!dataRaw) {
              return trueValue;
          }
          const statesDataVal = listDataGetter(dataRaw);
          const pageVal = page.v;
          const pageCountVal = pageCount.v;
          const dataLen = isArray(statesDataVal) ? len(statesDataVal) : 0;
          return pageCountVal ? pageVal >= pageCountVal : dataLen < pageSize.v;
      }, [page, pageCount, nestedData, pageSize], 'isLastPage');
      // 更新当前页缓存
      const updateCurrentPageCache = async () => {
          const snapshotItem = getSnapshotMethods(page.v);
          if (snapshotItem) {
              await alova.setCache(snapshotItem.entity, (rawData) => {
                  // 当关闭缓存时，rawData为undefined
                  if (rawData) {
                      const cachedListData = listDataGetter(rawData) || [];
                      splice(cachedListData, 0, len(cachedListData), ...data.v);
                      return rawData;
                  }
              });
          }
      };
      onFetchSuccess(({ method, data: rawData }) => {
          // 处理当fetch还没响应时就翻页到fetch对应的页码时，需要手动更新列表数据
          const snapshotItem = getSnapshotMethods(page.v);
          if (snapshotItem && getMethodInternalKey(snapshotItem.entity) === getMethodInternalKey(method)) {
              // 如果追加数据，才更新data
              const listData = listDataGetter(rawData); // 更新data参数
              if (append) {
                  // 下拉加载时需要替换当前页数据
                  const dataRaw = data.v;
                  const pageSizeVal = pageSize.v;
                  // 当做移除操作时，替换的数量小于pageSize，此时dataRaw % pageSizeVal会大于0
                  // 当新增操作时，替换的数量等于pageSize，此时dataRaw % pageSizeVal会等于0，此时不需要替换
                  const replaceNumber = len(dataRaw) % pageSizeVal;
                  if (replaceNumber > 0) {
                      const rawData = [...data.v];
                      splice(rawData, (page.v - 1) * pageSizeVal, replaceNumber, ...listData);
                      data.v = rawData;
                  }
              }
              else {
                  data.v = listData;
              }
          }
      });
      states.onSuccess(({ data: rawData, args: [refreshPage, isRefresh], method }) => {
          const { total: cachedTotal } = getSnapshotMethods(method) || {};
          const typedRawData = rawData;
          total.v = cachedTotal !== undefinedValue ? cachedTotal : totalGetter(typedRawData);
          if (!isRefresh) {
              fetchPreviousPage(typedRawData);
              fetchNextPage(typedRawData);
          }
          const pageSizeVal = pageSize.v;
          const listData = listDataGetter(typedRawData); // 获取数组
          paginationAssert(isArray(listData), 'Got wrong array, did you return the correct array of list in `data` function');
          // 如果追加数据，才更新data
          if (append) {
              // 如果是reset则先清空数据
              if (isReset.current) {
                  data.v = [];
              }
              if (refreshPage === undefinedValue) {
                  data.v = [...data.v, ...listData];
              }
              else if (refreshPage) {
                  const rawData = [...data.v];
                  // 如果是刷新页面，则是替换那一页的数据
                  splice(rawData, (refreshPage - 1) * pageSizeVal, pageSizeVal, ...listData);
                  data.v = rawData;
              }
          }
          else {
              data.v = listData;
          }
      });
      // 请求成功与否，都要重置isReset
      states.onComplete(() => {
          isReset.current = falseValue;
      });
      // 获取列表项所在位置
      const getItemIndex = (item) => {
          const index = data.v.indexOf(item);
          paginationAssert(index >= 0, 'item is not found in list');
          return index;
      };
      const { addQueue: add2AsyncQueue, onComplete: onAsyncQueueRunComplete } = ref(createAsyncQueue()).current;
      /**
       * 刷新指定页码数据，此函数将忽略缓存强制发送请求
       * 如果未传入页码则会刷新当前页
       * 如果传入一个列表项，将会刷新此列表项所在页，只对append模式有效
       * @param pageOrItemPage 刷新的页码或列表项
       */
      const refresh = (pageOrItemPage = page.v) => {
          let refreshPage = pageOrItemPage;
          if (append) {
              if (!isNumber(pageOrItemPage)) {
                  const itemIndex = getItemIndex(pageOrItemPage);
                  refreshPage = Math.floor(itemIndex / pageSize.v) + 1;
              }
              paginationAssert(refreshPage <= page.v, "refresh page can't greater than page");
              // 更新当前页数据
              promiseCatch(send(refreshPage, trueValue), noop);
          }
          else {
              paginationAssert(isNumber(refreshPage), 'unable to calculate refresh page by item in pagination mode');
              // 页数相等，则刷新当前页，否则fetch数据
              promiseCatch(refreshPage === page.v
                  ? send(undefinedValue, trueValue)
                  : fetch(handler(refreshPage, pageSize.v), trueValue), noop);
          }
      };
      // 删除除此usehook当前页和下一页的所有相关缓存
      const invalidatePaginationCache = async (all = falseValue) => {
          const pageVal = page.v;
          const snapshotObj = methodSnapshots();
          let snapshots = objectValues(snapshotObj);
          if (all) {
              removeSnapshot();
          }
          else {
              // 筛选出上一页、当前页、下一页的数据
              const excludeSnapshotKeys = mapItem$1(filterItem$1([getSnapshotMethods(pageVal - 1), getSnapshotMethods(pageVal), getSnapshotMethods(pageVal + 1)], Boolean), ({ entity }) => getMethodInternalKey(entity));
              snapshots = mapItem$1(filterItem$1(objectKeys(snapshotObj), key => !includes(excludeSnapshotKeys, key)), key => {
                  const item = snapshotObj[key];
                  delete snapshotObj[key];
                  return item;
              });
          }
          await alova.invalidateCache(mapItem$1(snapshots, ({ entity }) => entity));
      };
      // 单独拿出来的原因是
      // 无论同步调用几次insert、remove，或它们组合调用，reset操作只需要异步执行一次
      const resetCache = async () => {
          fetchingRef.current && abortFetch();
          // 缓存失效
          await invalidatePaginationCache();
          // 当下一页的数据量不超过pageSize时，强制请求下一页，因为有请求共享，需要在中断请求后异步执行拉取操作
          const snapshotItem = getSnapshotMethods(page.v + 1);
          if (snapshotItem) {
              const cachedListData = listDataGetter((await alova.queryCache(snapshotItem.entity)) || {}) || [];
              fetchNextPage(undefinedValue, len(cachedListData) < pageSize.v);
          }
      };
      // 统一更新总条数
      const updateTotal = (offset) => {
          if (offset === 0) {
              return;
          }
          // 更新当前页
          const totalVal = total.v;
          if (isNumber(totalVal)) {
              const offsetedTotal = Math.max(totalVal + offset, 0);
              total.v = offsetedTotal;
              const pageVal = page.v;
              // 更新冗余的total字段
              forEach([getSnapshotMethods(pageVal - 1), getSnapshotMethods(pageVal), getSnapshotMethods(pageVal + 1)], item => {
                  item && (item.total = offsetedTotal);
              });
          }
      };
      /**
       * 插入一条数据
       * 如果未传入index，将默认插入到最前面
       * 如果传入一个列表项，将插入到这个列表项的后面，如果列表项未在列表数据中将会抛出错误
       * @param item 插入项
       * @param position 插入位置（索引）或列表项
       */
      const insert = (item, position = 0) => {
          onAsyncQueueRunComplete(resetCache); // 执行结束需要重置缓存
          return add2AsyncQueue(async () => {
              const index = isNumber(position) ? position : getItemIndex(position) + 1;
              let popItem = undefinedValue;
              const rawData = [...data.v];
              // 当前展示的项数量刚好是pageSize的倍数时，才需要去掉一项数据，保证操作页的数量为pageSize
              if (len(rawData) % pageSize.v === 0) {
                  popItem = rawData.pop();
              }
              // 插入位置为空默认插到最前面
              splice(rawData, index, 0, item);
              data.v = rawData;
              updateTotal(1);
              // 当前页的缓存同步更新
              await updateCurrentPageCache();
              // 如果有pop项，将它放到下一页缓存的头部，与remove的操作保持一致
              // 这样在同步调用insert和remove时表现才一致
              if (popItem) {
                  const snapshotItem = getSnapshotMethods(page.v + 1);
                  if (snapshotItem) {
                      await alova.setCache(snapshotItem.entity, (rawData) => {
                          if (rawData) {
                              const cachedListData = listDataGetter(rawData) || [];
                              cachedListData.unshift(popItem);
                              cachedListData.pop();
                              return rawData;
                          }
                      });
                  }
              }
          });
      };
      /**
       * 移除一条数据
       * 如果传入的是列表项，将移除此列表项，如果列表项未在列表数据中将会抛出错误
       * @param position 移除的索引或列表项
       */
      const remove = (...positions) => {
          onAsyncQueueRunComplete(resetCache); // 执行结束需要重置缓存
          return add2AsyncQueue(async () => {
              const indexes = mapItem$1(positions, position => {
                  const index = isNumber(position) ? position : getItemIndex(position);
                  indexAssert(index, data.v);
                  return index;
              });
              const pageVal = page.v;
              const nextPage = pageVal + 1;
              const snapshotItem = getSnapshotMethods(nextPage);
              const fillingItems = []; // 补位数据项
              if (snapshotItem) {
                  await alova.setCache(snapshotItem.entity, (rawData) => {
                      if (rawData) {
                          const cachedListData = listDataGetter(rawData);
                          // 从下一页列表的头部开始取补位数据
                          if (isArray(cachedListData)) {
                              pushItem$1(fillingItems, ...splice(cachedListData, 0, len(indexes)));
                          }
                          return rawData;
                      }
                  });
              }
              const isLastPageVal = isLastPage.v;
              const fillingItemsLen = len(fillingItems);
              if (fillingItemsLen > 0 || isLastPageVal) {
                  // 删除指定索引的数据
                  const newListData = filterItem$1(data.v, (_, index) => !includes(indexes, index));
                  // 翻页模式下，如果是最后一页且全部项被删除了，则往前翻一页
                  if (!append && isLastPageVal && len(newListData) <= 0) {
                      page.v = pageVal - 1;
                  }
                  else if (fillingItemsLen > 0) {
                      pushItem$1(newListData, ...fillingItems);
                  }
                  data.v = newListData;
              }
              else if (fillingItemsLen <= 0 && !isLastPageVal) {
                  // 移除最后一页数据时，就不需要再刷新了
                  refresh(pageVal);
              }
              updateTotal(-len(indexes));
              // 当前页的缓存同步更新
              return updateCurrentPageCache();
          });
      };
      /**
       * 替换一条数据
       * 如果position传入的是列表项，将替换此列表项，如果列表项未在列表数据中将会抛出错误
       * @param item 替换项
       * @param position 替换位置（索引）或列表项
       */
      const replace = (item, position) => add2AsyncQueue(async () => {
          paginationAssert(position !== undefinedValue, 'expect specify the replace position');
          const index = isNumber(position) ? position : getItemIndex(position);
          indexAssert(index, data.v);
          const rawData = [...data.v];
          splice(rawData, index, 1, item);
          data.v = rawData;
          // 当前页的缓存同步更新
          await updateCurrentPageCache();
      });
      /**
       * 从第${initialPage}页开始重新加载列表，并清空缓存
       */
      const reload = () => {
          promiseThen(invalidatePaginationCache(trueValue), () => {
              isReset.current = trueValue;
              page.v === initialPage ? promiseCatch(send(), noop) : (page.v = initialPage);
          });
      };
      // 兼容react，每次缓存最新的操作函数，避免闭包陷阱
      delegationActions.current = {
          refresh,
          insert,
          remove,
          replace,
          reload
      };
      /** @Returns */
      return exposeProvider({
          ...states,
          ...objectify([data, page, pageCount, pageSize, total, isLastPage]),
          fetching: fetchStates.loading,
          onFetchSuccess: fetchStates.onSuccess,
          onFetchError: fetchStates.onError,
          onFetchComplete: fetchStates.onComplete,
          refresh,
          insert,
          remove,
          replace,
          reload
      });
  };

  function useSQRequest(handler, config = {}) {
      const { exposeProvider, __referingObj: referingObj } = statesHookHelper(alova.promiseStatesHook());
      const { middleware = noop } = config;
      const { c: methodCreateHandler, m: silentMiddleware, b: binders, d: decorateEvent } = createSilentQueueMiddlewares(handler, config);
      const states = useRequest(methodCreateHandler, {
          ...config,
          __referingObj: referingObj,
          middleware: (ctx, next) => {
              const silentMidPromise = silentMiddleware(ctx, next);
              middleware(ctx, () => silentMidPromise);
              return silentMidPromise;
          }
      });
      decorateEvent(states);
      return exposeProvider({
          ...states,
          ...binders
      });
  }

  const useAutoRequest = (handler, config = {}) => {
      let notifiable = trueValue;
      const { enableFocus = trueValue, enableVisibility = trueValue, enableNetwork = trueValue, pollingTime = 0, throttle = 1000 } = config;
      const { onMounted, onUnmounted, __referingObj: referingObject } = statesHookHelper(alova.promiseStatesHook());
      const states = useRequest(handler, {
          ...config,
          __referingObj: referingObject
      });
      const notify = () => {
          if (notifiable) {
              states.send();
              if (throttle > 0) {
                  notifiable = falseValue;
                  setTimeout(() => {
                      notifiable = trueValue;
                  }, throttle);
              }
          }
      };
      let offNetwork = noop;
      let offFocus = noop;
      let offVisiblity = noop;
      let offPolling = noop;
      onMounted(() => {
          if (!alova.globalConfigMap.ssr) {
              offNetwork = enableNetwork ? useAutoRequest.onNetwork(notify, config) : offNetwork;
              offFocus = enableFocus ? useAutoRequest.onFocus(notify, config) : offFocus;
              offVisiblity = enableVisibility ? useAutoRequest.onVisibility(notify, config) : offVisiblity;
              offPolling = pollingTime > 0 ? useAutoRequest.onPolling(notify, config) : offPolling;
          }
      });
      onUnmounted(() => {
          offNetwork();
          offFocus();
          offVisiblity();
          offPolling();
      });
      return states;
  };
  const on = (type, handler) => {
      window.addEventListener(type, handler);
      return () => window.removeEventListener(type, handler);
  };
  useAutoRequest.onNetwork = notify => on('online', notify);
  useAutoRequest.onFocus = notify => on('focus', notify);
  useAutoRequest.onVisibility = notify => {
      const handle = () => document.visibilityState === 'visible' && notify();
      return on('visibilitychange', handle);
  };
  useAutoRequest.onPolling = (notify, config) => {
      const timer = setInterval(notify, config.pollingTime);
      return () => clearInterval(timer);
  };

  const hookPrefix$1 = 'useCaptcha';
  const captchaAssert = createAssert(hookPrefix$1);
  var useCaptcha = (handler, config = {}) => {
      const { initialCountdown, middleware } = config;
      captchaAssert(initialCountdown === undefinedValue || initialCountdown > 0, 'initialCountdown must be greater than 0');
      const { create, ref, objectify, exposeProvider, __referingObj: referingObject } = statesHookHelper(alova.promiseStatesHook());
      const countdown = create(0, 'countdown');
      const requestReturned = useRequest(handler, {
          ...config,
          __referingObj: referingObject,
          immediate: falseValue,
          managedStates: objectify([countdown], 's'),
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          middleware: middleware ? (ctx, next) => middleware({ ...ctx, send }, next) : undefinedValue
      });
      const timer = ref(undefinedValue);
      const send = (...args) => newInstance$1(PromiseCls, (resolve, reject) => {
          if (countdown.v <= 0) {
              requestReturned
                  .send(...args)
                  .then(result => {
                  countdown.v = config.initialCountdown || 60;
                  timer.current = setInterval(() => {
                      countdown.v -= 1;
                      if (countdown.v <= 0) {
                          clearInterval(timer.current);
                      }
                  }, 1000);
                  resolve(result);
              })
                  .catch(reason => reject(reason));
          }
          else {
              reject(newInstance$1(AlovaError, hookPrefix$1, 'the countdown is not over yet'));
          }
      });
      return exposeProvider({
          ...requestReturned,
          send,
          ...objectify([countdown])
      });
  };

  const RestoreEventKey = Symbol('FormRestore');
  const getStoragedKey = (methodInstance, id) => `alova/form-${id || getMethodInternalKey(methodInstance)}`;
  const sharedStates = {};
  const cloneFormData = (form) => {
      const shallowClone = (value) => (isArray(value) ? [...value] : isPlainObject(value) ? { ...value } : value);
      return walkObject(shallowClone(form), shallowClone);
  };
  var useForm = (handler, config = {}) => {
      const typedSharedStates = sharedStates;
      const { id, initialForm, store, resetAfterSubmiting, immediate = falseValue, middleware } = config;
      alova.promiseStatesHook();
      const { create: $, ref: useFlag$, onMounted: onMounted$, watch: watch$, objectify, exposeProvider, __referingObj: referingObject } = statesHookHelper(alova.promiseStatesHook());
      const isStoreObject = isPlainObject(store);
      const enableStore = isStoreObject ? store.enable : store;
      // 如果config中的id也有对应的共享状态，则也会返回它
      // 继续往下执行是为了兼容react的hook执行数不能变的问题，否则会抛出"Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
      const sharedState = id ? typedSharedStates[id] : undefinedValue;
      const form = $(cloneFormData(initialForm), 'form');
      const methodHandler = handler;
      const eventManager = createEventManager();
      // 使用计算属性，避免每次执行此use hook都调用一遍methodHandler
      const initialMethodInstance = useFlag$(sloughConfig(methodHandler, [form.v]));
      const storageContext = getContext(initialMethodInstance.current).l2Cache;
      const storagedKey = getStoragedKey(initialMethodInstance.current, id);
      const reseting = useFlag$(falseValue);
      const serializerPerformer = useFlag$(createSerializerPerformer(isStoreObject ? store.serializers : undefinedValue));
      // 是否由当前hook发起创建的共享状态，发起创建的hook需要返回最新的状态，否则会因为在react中hook被调用，导致发起获得的hook中无法获得最新的状态
      const isCreateShardState = useFlag$(false);
      const originalHookProvider = useRequest((...args) => methodHandler(form.v, ...args), {
          ...config,
          __referingObj: referingObject,
          // 中间件函数，也支持subscriberMiddleware
          middleware: middleware
              ? (ctx, next) => middleware({
                  ...ctx,
                  // eslint-disable-next-line
                  delegatingActions: { updateForm, reset }
              }, next)
              : undefinedValue,
          // 1. 当需要持久化时，将在数据恢复后触发
          // 2. 当已有共享状态时，表示之前已有初始化（无论有无立即发起请求），后面的不再自动发起请求，这是为了兼容多表单立即发起请求时，重复发出请求的问题
          immediate: enableStore || sharedState ? falseValue : immediate
      });
      /**
       * 重置form数据
       */
      const reset = () => {
          reseting.current = trueValue;
          const clonedFormData = cloneFormData(initialForm);
          clonedFormData && (form.v = clonedFormData);
          enableStore && storageContext.remove(storagedKey);
      };
      /**
       * 更新form数据
       * @param newForm 新表单数据
       */
      const updateForm = (newForm) => {
          form.v = {
              ...form.v,
              ...newForm
          };
      };
      const hookProvider = exposeProvider({
          // 第一个参数固定为form数据
          ...originalHookProvider,
          ...objectify([form]),
          updateForm,
          reset,
          // 持久化数据恢复事件绑定
          onRestore(handler) {
              eventManager.on(RestoreEventKey, handler);
          }
      });
      // 有id时，才保存到sharedStates中
      // 在react中，因为更新form后会产生新的form，因此需要每次调用重新保存
      if (id) {
          // 还没有共享状态则表示当前hook是创建的hook
          if (!sharedState) {
              isCreateShardState.current = trueValue;
          }
          // 只保存创建hook的共享状态
          if (isCreateShardState.current) {
              typedSharedStates[id] = {
                  hookProvider: hookProvider,
                  config
              };
          }
      }
      const { send, onSuccess } = hookProvider;
      onMounted$(() => {
          // 需要持久化时更新data
          if (enableStore && !sharedState) {
              // 获取存储并更新data
              // 需要在onMounted中调用，否则会导致在react中重复被调用
              const storagedForm = serializerPerformer.current.deserialize(storageContext.get(storagedKey));
              // 有草稿数据时，异步恢复数据，否则无法正常绑定onRetore事件
              if (storagedForm) {
                  form.v = storagedForm;
                  // 触发持久化数据恢复事件
                  eventManager.emit(RestoreEventKey, undefinedValue);
                  enableStore && immediate && send();
              }
          }
      });
      // 监听变化同步存储，如果是reset触发的则不需要再序列化
      watch$([form], () => {
          if (reseting.current || !enableStore) {
              reseting.current = falseValue;
              return;
          }
          storageContext.set(storagedKey, serializerPerformer.current.serialize(form.v));
      });
      // 如果在提交后需要清除数据，则调用reset
      onSuccess(() => {
          resetAfterSubmiting && reset();
      });
      // 有已保存的sharedState，则返回它
      // 如果是当前hook创建的共享状态，则返回最新的而非缓存的
      return sharedState && !isCreateShardState.current ? sharedState.hookProvider : hookProvider;
  };

  const RetryEventKey = Symbol('RetriableRetry');
  const FailEventKey = Symbol('RetriableFail');
  const hookPrefix = 'useRetriableRequest';
  const assert$1 = createAssert(hookPrefix);
  var useRetriableRequest = (handler, config = {}) => {
      const { retry = 3, backoff = { delay: 1000 }, middleware = noop } = config;
      const { ref: useFlag$, exposeProvider, __referingObj: referingObject } = statesHookHelper(alova.promiseStatesHook());
      const eventManager = createEventManager();
      const retryTimes = useFlag$(0);
      const stopManuallyError = useFlag$(undefinedValue); // 停止错误对象，在手动触发停止时有值
      const methodInstanceLastest = useFlag$(undefinedValue);
      const argsLatest = useFlag$(undefinedValue);
      const currentLoadingState = useFlag$(falseValue);
      const requesting = useFlag$(falseValue); // 是否正在请求
      const retryTimer = useFlag$(undefinedValue);
      const promiseObj = useFlag$(usePromise());
      const requestResolved = useFlag$(falseValue);
      const emitOnFail = (method, args, error) => {
          if (requestResolved.current) {
              return;
          }
          requestResolved.current = trueValue;
          // 需要异步触发onFail，让onError和onComplete先触发
          setTimeoutFn(() => {
              eventManager.emit(FailEventKey, newInstance$1((RetriableFailEvent), AlovaEventBase.spawn(method, args), error, retryTimes.current));
              stopManuallyError.current = undefinedValue;
              retryTimes.current = 0; // 重置已重试次数
          });
      };
      const nestedHookProvider = useRequest(handler, {
          ...config,
          __referingObj: referingObject,
          middleware(ctx, next) {
              middleware({
                  ...ctx,
                  delegatingActions: {
                      // eslint-disable-next-line @typescript-eslint/no-use-before-define
                      stop
                  }
              }, () => promiseResolve(undefinedValue));
              const { proxyStates, args, send, method, controlLoading } = ctx;
              const setLoading = (loading = falseValue) => {
                  if (loading !== currentLoadingState.current) {
                      proxyStates.loading.v = loading;
                      currentLoadingState.current = loading;
                  }
              };
              controlLoading();
              setLoading(trueValue);
              methodInstanceLastest.current = method;
              argsLatest.current = args;
              requesting.current = trueValue;
              // init the resolved flag as `false` before first request.
              if (retryTimes.current === 0) {
                  requestResolved.current = falseValue;
              }
              /**
               * Consider this situation: user call stop() and send another request immediately,
               * but now the previous request haven't finished. `next()` will raises the branch on completion.
               *
               * By using Promise.race(), we can cause the returned promise to be rejected immediately when call `stop()`
               */
              return promiseThen(Promise.race([next(), promiseObj.current.promise]), 
              // 请求成功时设置loading为false
              val => {
                  // retryTimes.current = 0; // 重置已重试次数
                  requesting.current = falseValue;
                  setLoading();
                  return val;
              }, 
              // 请求失败时触发重试机制
              error => {
                  // 没有手动触发停止，以及重试次数未到达最大时触发重试
                  if (!stopManuallyError.current && (isNumber(retry) ? retryTimes.current < retry : retry(error, ...args))) {
                      retryTimes.current += 1;
                      // 计算重试延迟时间
                      const retryDelay = delayWithBackoff(backoff, retryTimes.current);
                      // 延迟对应时间重试
                      retryTimer.current = setTimeoutFn(() => {
                          // 如果手动停止了则不再触发重试
                          promiseCatch(send(...args), noop); // 捕获错误不再往外抛，否则重试时也会抛出错误
                          // 触发重试事件
                          eventManager.emit(RetryEventKey, newInstance$1((RetriableRetryEvent), AlovaEventBase.spawn(method, args), retryTimes.current, retryDelay));
                      }, retryDelay);
                  }
                  else {
                      setLoading();
                      error = stopManuallyError.current || error; // 如果stopManuallyError有值表示是通过stop函数触发停止的
                      emitOnFail(method, args, error);
                  }
                  requesting.current = falseValue;
                  // 返回reject执行后续的错误流程
                  return promiseReject(error);
              });
          }
      });
      /**
       * 停止重试，只在重试期间调用有效
       * 如果正在请求中，则触发中断请求，让请求错误来抛出错误，否则手动修改状态以及触发onFail
       * 停止后将立即触发onFail事件
       */
      const stop = () => {
          assert$1(currentLoadingState.current, 'there is no requests being retried');
          stopManuallyError.current = newInstance$1(AlovaError, hookPrefix, 'stop retry manually');
          if (requesting.current) {
              nestedHookProvider.abort();
          }
          else {
              promiseObj.current.reject(stopManuallyError.current);
              setTimeout(() => {
                  promiseObj.current = usePromise();
              });
              nestedHookProvider.update({ error: stopManuallyError.current, loading: falseValue });
              currentLoadingState.current = falseValue;
              clearTimeout(retryTimer.current); // 清除重试定时器
              // raise fail event at the end, because the above process depends on `stopManuallyError`
              // emit this event will clears this variable
              emitOnFail(methodInstanceLastest.current, argsLatest.current, stopManuallyError.current);
          }
      };
      /**
       * 重试事件绑定
       * 它们将在重试发起后触发
       * @param handler 重试事件回调
       */
      const onRetry = (handler) => {
          eventManager.on(RetryEventKey, event => handler(event));
      };
      /**
       * 失败事件绑定
       * 它们将在不再重试时触发，例如到达最大重试次数时，重试回调返回false时，手动调用stop停止重试时
       * 而alova的onError事件是在每次请求报错时都将被触发
       *
       * 注意：如果没有重试次数时，onError、onComplete和onFail会被同时触发
       *
       * @param handler 失败事件回调
       */
      const onFail = (handler) => {
          eventManager.on(FailEventKey, event => handler(event));
      };
      return exposeProvider({
          ...nestedHookProvider,
          stop,
          onRetry,
          onFail
      });
  };

  /**
   * 构建完整的url
   * @param base baseURL
   * @param url 路径
   * @param params url参数
   * @returns 完整的url
   */
  const buildCompletedURL = (baseURL, url, params) => {
      // baseURL如果以/结尾，则去掉/
      baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;
      // 如果不是/或http协议开头的，则需要添加/
      url = url.match(/^(\/|https?:\/\/)/) ? url : `/${url}`;
      const completeURL = baseURL + url;
      // 将params对象转换为get字符串
      // 过滤掉值为undefined的
      const paramsStr = mapItem$1(filterItem$1(objectKeys(params), key => params[key] !== undefinedValue), key => `${key}=${params[key]}`).join('&');
      // 将get参数拼接到url后面，注意url可能已存在参数
      return paramsStr
          ? +completeURL.includes('?')
              ? `${completeURL}&${paramsStr}`
              : `${completeURL}?${paramsStr}`
          : completeURL;
  };

  const SSEOpenEventKey = Symbol('SSEOpen');
  const SSEMessageEventKey = Symbol('SSEMessage');
  const SSEErrorEventKey = Symbol('SSEError');
  const assert = createAssert('useSSE');
  const MessageType = {
      Open: 'open',
      Error: 'error',
      Message: 'message'
  };
  var useSSE = (handler, config = {}) => {
      const { initialData, withCredentials, interceptByGlobalResponded = trueValue, 
      /** abortLast = trueValue, */
      immediate = falseValue } = config;
      // ! 暂时不支持指定 abortLast
      const abortLast = trueValue;
      let { memorize } = alova.promiseStatesHook();
      memorize !== null && memorize !== void 0 ? memorize : (memorize = $self);
      const { create, ref, onMounted, onUnmounted, objectify, exposeProvider } = statesHookHelper(alova.promiseStatesHook());
      const usingArgs = ref([]);
      const eventSource = ref(undefinedValue);
      const sendPromiseObject = ref(undefinedValue);
      const data = create(initialData, 'data');
      const readyState = create(2 /* SSEHookReadyState.CLOSED */, 'readyState');
      let methodInstance = getHandlerMethod(handler);
      let responseUnified;
      const eventManager = createEventManager();
      // 储存自定义事件的 useCallback 对象，其中 key 为 eventName
      const customEventMap = ref(new Map());
      const onOpen = (handler) => {
          eventManager.on(SSEOpenEventKey, handler);
      };
      const onMessage = (handler) => {
          eventManager.on(SSEMessageEventKey, handler);
      };
      const onError = (handler) => {
          eventManager.on(SSEErrorEventKey, handler);
      };
      const responseSuccessHandler = ref($self);
      const responseErrorHandler = ref(throwFn);
      const responseCompleteHandler = ref(noop);
      /**
       * 设置响应拦截器，在每次 send 之后都需要调用
       */
      const setResponseHandler = (instance) => {
          // responsed 从 3.0 开始移除
          const { responded } = getOptions(instance);
          responseUnified = responded;
          if (isFn(responseUnified)) {
              responseSuccessHandler.current = responseUnified;
          }
          else if (responseUnified && isPlainObject(responseUnified)) {
              const { onSuccess: successHandler, onError: errorHandler, onComplete: completeHandler } = responseUnified;
              responseSuccessHandler.current = isFn(successHandler) ? successHandler : responseSuccessHandler.current;
              responseErrorHandler.current = isFn(errorHandler) ? errorHandler : responseErrorHandler.current;
              responseCompleteHandler.current = isFn(completeHandler) ? completeHandler : responseCompleteHandler.current;
          }
      };
      /**
       * 处理响应任务，失败时不缓存数据
       * @param handlerReturns 拦截器返回后的数据
       * @returns 处理后的response
       */
      const handleResponseTask = async (handlerReturns) => {
          const { headers, transform: transformFn = $self } = getConfig(methodInstance);
          const returnsData = await handlerReturns;
          const transformedData = await transformFn(returnsData, (headers || {}));
          data.v = transformedData;
          // invalidate cache
          alova.hitCacheBySource(methodInstance);
          return transformedData;
      };
      /**
       * 创建 AlovaSSEHook 事件
       * 具体数据处理流程参考以下链接
       * @link https://alova.js.org/zh-CN/tutorial/combine-framework/response
       */
      const createSSEEvent = async (eventFrom, dataOrError) => {
          assert(!!eventSource.current, 'EventSource is not initialized');
          const es = eventSource.current;
          const baseEvent = new AlovaSSEEvent(AlovaEventBase.spawn(methodInstance, usingArgs.current), es);
          if (eventFrom === MessageType.Open) {
              return Promise.resolve(baseEvent);
          }
          const globalSuccess = interceptByGlobalResponded ? responseSuccessHandler.current : $self;
          const globalError = interceptByGlobalResponded ? responseErrorHandler.current : throwFn;
          const globalFinally = interceptByGlobalResponded ? responseCompleteHandler.current : noop;
          const p = promiseFinally(promiseThen(dataOrError, res => handleResponseTask(globalSuccess(res, methodInstance)), error => handleResponseTask(globalError(error, methodInstance))), 
          // finally
          () => {
              globalFinally(methodInstance);
          });
          // 无论如何，函数返回的 Promise 对象一定都会 fulfilled
          return promiseThen(p, 
          // 得到处理好的数据（transform 之后的数据）
          res => new AlovaSSEMessageEvent(baseEvent, res), 
          // 有错误
          error => new AlovaSSEErrorEvent(baseEvent, error));
      };
      /**
       * 根据事件选择需要的触发函数。如果事件无错误则触发传传入的回调函数
       * @param callback 无错误时触发的回调函数
       */
      const sendSSEEvent = (callback) => (event) => {
          if (event.error === undefinedValue) {
              return callback(event);
          }
          return eventManager.emit(SSEErrorEventKey, event);
      };
      // * MARK: EventSource 的事件处理
      const onCustomEvent = (eventName, callbackHandler) => {
          var _a;
          const currentMap = customEventMap.current;
          if (!currentMap.has(eventName)) {
              const useCallbackObject = useCallback(callbacks => {
                  var _a;
                  if (callbacks.length === 0) {
                      (_a = eventSource.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, useCallbackObject[1]);
                      customEventMap.current.delete(eventName);
                  }
              });
              const trigger = useCallbackObject[1];
              currentMap.set(eventName, useCallbackObject);
              (_a = eventSource.current) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, event => {
                  promiseThen(createSSEEvent(eventName, Promise.resolve(event.data)), sendSSEEvent(trigger));
              });
          }
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const [onEvent] = currentMap.get(eventName);
          return onEvent(callbackHandler);
      };
      /**
       * 取消自定义事件在 useCallback 中的注册
       */
      const offCustomEvent = () => {
          customEventMap.current.forEach(([_1, _2, offTrigger]) => {
              offTrigger();
          });
      };
      const esOpen = memorize(() => {
          var _a;
          // resolve 使用 send() 时返回的 promise
          readyState.v = 1 /* SSEHookReadyState.OPEN */;
          promiseThen(createSSEEvent(MessageType.Open, Promise.resolve()), event => eventManager.emit(SSEOpenEventKey, event));
          // ! 一定要在调用 onOpen 之后 resolve
          (_a = sendPromiseObject.current) === null || _a === void 0 ? void 0 : _a.resolve();
      });
      const esError = memorize((event) => {
          var _a, _b;
          readyState.v = 2 /* SSEHookReadyState.CLOSED */;
          promiseThen(createSSEEvent(MessageType.Error, Promise.reject((_a = event === null || event === void 0 ? void 0 : event.message) !== null && _a !== void 0 ? _a : 'SSE Error')), sendSSEEvent(event => eventManager.emit(SSEMessageEventKey, event)));
          (_b = sendPromiseObject.current) === null || _b === void 0 ? void 0 : _b.resolve();
      });
      const esMessage = memorize((event) => {
          promiseThen(createSSEEvent(MessageType.Message, Promise.resolve(event.data)), sendSSEEvent(event => eventManager.emit(SSEMessageEventKey, event)));
      });
      /**
       * 关闭当前 eventSource 的注册
       */
      const close = () => {
          const es = eventSource.current;
          if (!es) {
              return;
          }
          if (sendPromiseObject.current) {
              // 如果 close 时 promise 还在
              sendPromiseObject.current.resolve();
          }
          // * MARK: 解绑事件处理
          es.close();
          es.removeEventListener(MessageType.Open, esOpen);
          es.removeEventListener(MessageType.Error, esError);
          es.removeEventListener(MessageType.Message, esMessage);
          readyState.v = 2 /* SSEHookReadyState.CLOSED */;
          // eventSource 关闭后，取消注册所有自定义事件
          // 否则可能造成内存泄露
          customEventMap.current.forEach(([_, eventTrigger], eventName) => {
              es.removeEventListener(eventName, eventTrigger);
          });
      };
      /**
       * 发送请求并初始化 eventSource
       */
      const connect = (...args) => {
          let es = eventSource.current;
          let promiseObj = sendPromiseObject.current;
          if (es && abortLast) {
              // 当 abortLast === true，关闭之前的连接并重新建立
              close();
          }
          // 设置 send 函数使用的 promise 对象
          if (!promiseObj) {
              promiseObj = sendPromiseObject.current = usePromise();
              // open 后清除 promise 对象
              promiseObj &&
                  promiseObj.promise.finally(() => {
                      promiseObj = undefinedValue;
                  });
          }
          usingArgs.current = args;
          methodInstance = getHandlerMethod(handler, args);
          // 设置响应拦截器
          setResponseHandler(methodInstance);
          const { params } = getConfig(methodInstance);
          const { baseURL, url } = methodInstance;
          const fullURL = buildCompletedURL(baseURL, url, params);
          // 建立连接
          es = new EventSource(fullURL, { withCredentials });
          eventSource.current = es;
          readyState.v = 0 /* SSEHookReadyState.CONNECTING */;
          // * MARK: 注册处理事件
          // 注册处理事件 open error message
          es.addEventListener(MessageType.Open, esOpen);
          es.addEventListener(MessageType.Error, esError);
          es.addEventListener(MessageType.Message, esMessage);
          // 以及 自定义事件
          // 如果在 connect（send）之前就使用了 on 监听，则 customEventMap 里就已经有事件存在
          customEventMap.current.forEach(([_, eventTrigger], eventName) => {
              es === null || es === void 0 ? void 0 : es.addEventListener(eventName, event => {
                  promiseThen(createSSEEvent(eventName, Promise.resolve(event.data)), sendSSEEvent(eventTrigger));
              });
          });
          return promiseObj.promise;
      };
      onUnmounted(() => {
          close();
          // 上面使用 eventSource.removeEventListener 只是断开了 eventSource 和 trigger 的联系
          // 这里是取消 useCallback 对象中的事件注册
          eventManager.off(SSEOpenEventKey);
          eventManager.off(SSEMessageEventKey);
          eventManager.off(SSEErrorEventKey);
          offCustomEvent();
      });
      // * MARK: 初始化动作
      onMounted(() => {
          var _a;
          if (immediate) {
              connect();
              (_a = sendPromiseObject.current) === null || _a === void 0 ? void 0 : _a.promise.catch(() => { });
          }
      });
      return exposeProvider({
          send: connect,
          close,
          on: onCustomEvent,
          onMessage,
          onError,
          onOpen,
          eventSource,
          ...objectify([readyState, data])
      });
  };

  exports.accessAction = accessAction;
  exports.actionDelegationMiddleware = actionDelegationMiddleware;
  exports.bootSilentFactory = bootSilentFactory;
  exports.createClientTokenAuthentication = createClientTokenAuthentication;
  exports.createServerTokenAuthentication = createServerTokenAuthentication;
  exports.dehydrateVData = dehydrateVData;
  exports.equals = equals;
  exports.filterSilentMethods = filterSilentMethods;
  exports.getSilentMethod = getSilentMethod;
  exports.isVData = isVData;
  exports.onBeforeSilentSubmit = onBeforeSilentSubmit;
  exports.onSilentSubmitBoot = onSilentSubmitBoot;
  exports.onSilentSubmitError = onSilentSubmitError;
  exports.onSilentSubmitFail = onSilentSubmitFail;
  exports.onSilentSubmitSuccess = onSilentSubmitSuccess;
  exports.silentQueueMap = silentQueueMap;
  exports.stringifyVData = stringifyVData;
  exports.updateState = updateState;
  exports.updateStateEffect = updateStateEffect;
  exports.useAutoRequest = useAutoRequest;
  exports.useCaptcha = useCaptcha;
  exports.useFetcher = useFetcher;
  exports.useForm = useForm;
  exports.usePagination = usePagination;
  exports.useRequest = useRequest;
  exports.useRetriableRequest = useRetriableRequest;
  exports.useSQRequest = useSQRequest;
  exports.useSSE = useSSE;
  exports.useSerialRequest = useSerialRequest;
  exports.useSerialWatcher = useSerialWatcher;
  exports.useWatcher = useWatcher;

}));
