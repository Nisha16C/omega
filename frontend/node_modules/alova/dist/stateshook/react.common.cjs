/**
  * @alova/client 2.0.0 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2024 Scott hu. All Rights Reserved
  * Licensed under MIT (https://github.com/alovajs/alova/blob/main/LICENSE)
*/

'use strict';

var _function = require('@alova/shared/function');
var vars = require('@alova/shared/vars');
var react$1 = require('react');

const stateToData = (reactState) => (2 in reactState ? reactState[2] : reactState[0]);
const refCurrent = (ref) => ref.current;
const setRef = (ref, newVal) => {
    ref.current = newVal;
};
// React的预定义hooks
var react = {
    name: 'React',
    create: initialValue => react$1.useState(initialValue),
    export: stateToData,
    dehydrate: stateToData,
    update: (newVal, state) => {
        // update value synchronously so that we can access the new value synchronously.
        state[2] = newVal;
        state[1](newVal);
    },
    memorize: fn => {
        // 使用useCallback使用同一个引用，同事通过useRef来引用最新函数
        const fnRef = react$1.useRef(_function.noop);
        setRef(fnRef, fn);
        return react$1.useCallback((...args) => refCurrent(fnRef)(...args), []);
    },
    ref: initialValue => {
        const refObj = react$1.useRef(initialValue);
        refCurrent(refObj) === vars.undefinedValue && setRef(refObj, initialValue);
        return refObj;
    },
    effectRequest({ handler, removeStates, saveStates, immediate, frontStates, watchingStates = [] }) {
        // 当有监听状态时，状态变化再触发
        const oldStates = react$1.useRef(watchingStates);
        // 多个值同时改变只触发一次
        const onceRunner = refCurrent(react$1.useRef(_function.createSyncOnceRunner()));
        react$1.useEffect(() => {
            const oldStatesValue = refCurrent(oldStates);
            // 对比新旧状态，获取变化的状态索引
            let changedIndex = vars.undefinedValue;
            for (const index in watchingStates) {
                if (!Object.is(oldStatesValue[index], watchingStates[index])) {
                    changedIndex = Number(index);
                    break;
                }
            }
            setRef(oldStates, watchingStates);
            onceRunner(() => {
                if (immediate || _function.isNumber(changedIndex)) {
                    handler(changedIndex);
                }
            });
            // 组件卸载时移除对应状态
            return removeStates;
        }, watchingStates);
        // 因为react每次刷新都会重新调用usehook，因此每次会让状态缓存失效
        // 因此每次都需要更新管理的状态
        const needSave = react$1.useRef(false);
        react$1.useEffect(() => {
            refCurrent(needSave) ? saveStates(frontStates) : setRef(needSave, vars.trueValue);
        });
    },
    computed: (getter, depList) => {
        const memo = react$1.useMemo(getter, depList);
        return [memo, _function.noop];
    },
    watch: (states, callback) => {
        // 当有监听状态时，状态变化再触发
        const needEmit = react$1.useRef(vars.falseValue);
        react$1.useEffect(() => {
            needEmit.current ? callback() : (needEmit.current = true);
        }, states);
    },
    onMounted: callback => {
        react$1.useEffect(callback, []);
    },
    onUnmounted: callback => {
        react$1.useEffect(() => callback, []);
    }
};

module.exports = react;
