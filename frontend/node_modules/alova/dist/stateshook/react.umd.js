/**
  * @alova/client 2.0.0 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2024 Scott hu. All Rights Reserved
  * Licensed under MIT (https://github.com/alovajs/alova/blob/main/LICENSE)
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.reactHook = factory(global.React));
})(this, (function (react$1) { 'use strict';

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */


  const undefStr$1 = 'undefined';
  const undefinedValue$1 = undefined;
  const setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);
  const typeOf = (arg) => typeof arg;
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr$1 &&
      (typeof process !== undefStr$1 ? typeof process.cwd === 'function' : typeof Deno !== undefStr$1);

  /**
   * 空函数，做兼容处理
   */
  const noop = () => { };
  /**
   * 判断参数是否为数字
   * @param arg 任意参数
   * @returns 该参数是否为数字
   */
  const isNumber = (arg) => typeOf(arg) === 'number' && !Number.isNaN(arg);
  /**
   * 创建同步多次调用只在异步执行一次的执行器
   */
  const createSyncOnceRunner = (delay = 0) => {
      let timer = undefinedValue$1;
      // 执行多次调用此函数将异步执行一次
      return (fn) => {
          if (timer) {
              clearTimeout(timer);
          }
          timer = setTimeoutFn(fn, delay);
      };
  };

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  const undefStr = 'undefined';
  const undefinedValue = undefined;
  const trueValue = true;
  const falseValue = false;
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr &&
      (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);

  const stateToData = (reactState) => (2 in reactState ? reactState[2] : reactState[0]);
  const refCurrent = (ref) => ref.current;
  const setRef = (ref, newVal) => {
      ref.current = newVal;
  };
  // React的预定义hooks
  var react = {
      name: 'React',
      create: initialValue => react$1.useState(initialValue),
      export: stateToData,
      dehydrate: stateToData,
      update: (newVal, state) => {
          // update value synchronously so that we can access the new value synchronously.
          state[2] = newVal;
          state[1](newVal);
      },
      memorize: fn => {
          // 使用useCallback使用同一个引用，同事通过useRef来引用最新函数
          const fnRef = react$1.useRef(noop);
          setRef(fnRef, fn);
          return react$1.useCallback((...args) => refCurrent(fnRef)(...args), []);
      },
      ref: initialValue => {
          const refObj = react$1.useRef(initialValue);
          refCurrent(refObj) === undefinedValue && setRef(refObj, initialValue);
          return refObj;
      },
      effectRequest({ handler, removeStates, saveStates, immediate, frontStates, watchingStates = [] }) {
          // 当有监听状态时，状态变化再触发
          const oldStates = react$1.useRef(watchingStates);
          // 多个值同时改变只触发一次
          const onceRunner = refCurrent(react$1.useRef(createSyncOnceRunner()));
          react$1.useEffect(() => {
              const oldStatesValue = refCurrent(oldStates);
              // 对比新旧状态，获取变化的状态索引
              let changedIndex = undefinedValue;
              for (const index in watchingStates) {
                  if (!Object.is(oldStatesValue[index], watchingStates[index])) {
                      changedIndex = Number(index);
                      break;
                  }
              }
              setRef(oldStates, watchingStates);
              onceRunner(() => {
                  if (immediate || isNumber(changedIndex)) {
                      handler(changedIndex);
                  }
              });
              // 组件卸载时移除对应状态
              return removeStates;
          }, watchingStates);
          // 因为react每次刷新都会重新调用usehook，因此每次会让状态缓存失效
          // 因此每次都需要更新管理的状态
          const needSave = react$1.useRef(false);
          react$1.useEffect(() => {
              refCurrent(needSave) ? saveStates(frontStates) : setRef(needSave, trueValue);
          });
      },
      computed: (getter, depList) => {
          const memo = react$1.useMemo(getter, depList);
          return [memo, noop];
      },
      watch: (states, callback) => {
          // 当有监听状态时，状态变化再触发
          const needEmit = react$1.useRef(falseValue);
          react$1.useEffect(() => {
              needEmit.current ? callback() : (needEmit.current = true);
          }, states);
      },
      onMounted: callback => {
          react$1.useEffect(callback, []);
      },
      onUnmounted: callback => {
          react$1.useEffect(() => callback, []);
      }
  };

  return react;

}));
