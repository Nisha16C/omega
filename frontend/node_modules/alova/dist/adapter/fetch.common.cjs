/**
  * alova 3.0.17 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2024 Scott Hu. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
*/

'use strict';

var _function = require('@alova/shared/function');
var vars = require('@alova/shared/vars');

const isBodyData = (data) => _function.isString(data) || _function.isSpecialRequestBody(data);
function adapterFetch() {
    return (elements, method) => {
        const adapterConfig = method.config;
        const timeout = adapterConfig.timeout || 0;
        const ctrl = new AbortController();
        const { data, headers } = elements;
        const isContentTypeSet = /content-type/i.test(vars.ObjectCls.keys(headers).join());
        const isDataFormData = data && data.toString() === '[object FormData]';
        // 未设置Content-Type并且data不是FormData对象时，默认设置Content-Type为application/json
        if (!isContentTypeSet && !isDataFormData) {
            headers['Content-Type'] = 'application/json;charset=UTF-8';
        }
        const fetchPromise = fetch(elements.url, {
            ...adapterConfig,
            method: elements.type,
            signal: ctrl.signal,
            body: isBodyData(data) ? data : vars.JSONStringify(data)
        });
        // 设置了中断时间，则在指定时间后中断请求
        let abortTimer;
        let isTimeout = vars.falseValue;
        if (timeout > 0) {
            abortTimer = vars.setTimeoutFn(() => {
                isTimeout = vars.trueValue;
                ctrl.abort();
            }, timeout);
        }
        return {
            response: () => fetchPromise.then(response => {
                // 请求成功后清除中断处理
                vars.clearTimeoutTimer(abortTimer);
                // Response的Readable只能被读取一次，需要克隆才可重复使用
                return response.clone();
            }, err => vars.promiseReject(isTimeout ? _function.newInstance(Error, 'fetchError: network timeout') : err)),
            // headers函数内的then需捕获异常，否则会导致内部无法获取到正确的错误对象
            headers: () => fetchPromise.then(({ headers: responseHeaders }) => responseHeaders, () => ({})),
            // 因nodeFetch库限制，这块代码无法进行单元测试，但已在浏览器中通过测试
            /* c8 ignore start */
            onDownload: async (cb) => {
                let isAborted = vars.falseValue;
                const response = await fetchPromise.catch(() => {
                    isAborted = vars.trueValue;
                });
                if (!response)
                    return;
                const { headers: responseHeaders, body } = response.clone();
                const reader = body ? body.getReader() : vars.undefinedValue;
                const total = Number(responseHeaders.get('Content-Length') || responseHeaders.get('content-length') || 0);
                if (total <= 0) {
                    return;
                }
                let loaded = 0;
                if (reader) {
                    const pump = () => reader.read().then(({ done, value = new Uint8Array() }) => {
                        if (done || isAborted) {
                            isAborted && cb(total, 0);
                        }
                        else {
                            loaded += value.byteLength;
                            cb(total, loaded);
                            return pump();
                        }
                    });
                    pump();
                }
            },
            onUpload() {
                // eslint-disable-next-line no-console
                console.error("fetch API does'nt support uploading progress. please consider to change `@alova/adapter-xhr` or `@alova/adapter-axios`");
            },
            /* c8 ignore stop */
            abort: () => {
                ctrl.abort();
                vars.clearTimeoutTimer(abortTimer);
            }
        };
    };
}

module.exports = adapterFetch;
