/**
  * alova 3.0.17 (https://alova.js.org)
  * Document https://alova.js.org
  * Copyright 2024 Scott Hu. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.alova = {}));
})(this, (function (exports) { 'use strict';

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */


  const undefStr$3 = 'undefined';
  const ObjectCls$1 = Object;
  const undefinedValue$1 = undefined;
  const nullValue = null;
  const falseValue$1 = false;
  const JSONStringify$1 = (value, replacer, space) => JSON.stringify(value, replacer, space);
  const typeOf = (arg) => typeof arg;
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr$3 &&
      (typeof process !== undefStr$3 ? typeof process.cwd === 'function' : typeof Deno !== undefStr$3);
  /** cache mode */
  // only cache in memory, it's default option
  const MEMORY$1 = 'memory';
  // persistent cache, and will be read to memory when page is refreshed, it means that the memory cache always exist until cache is expired.
  const STORAGE_RESTORE$1 = 'restore';

  /**
   * 空函数，做兼容处理
   */
  const noop = () => { };
  /**
   * 返回参数自身的函数，做兼容处理用
   * 由于部分系统将self作为了保留字，故使用$self来区分
   * @param arg 任意参数
   * @returns 返回参数本身
   */
  const $self = (arg) => arg;
  /**
   * 判断参数是否为函数
   * @param fn 任意参数
   * @returns 该参数是否为函数
   */
  const isFn = (arg) => typeOf(arg) === 'function';
  /**
   * 判断参数是否为数字
   * @param arg 任意参数
   * @returns 该参数是否为数字
   */
  const isNumber = (arg) => typeOf(arg) === 'number' && !Number.isNaN(arg);
  /**
   * 判断参数是否为字符串
   * @param arg 任意参数
   * @returns 该参数是否为字符串
   */
  const isString = (arg) => typeOf(arg) === 'string';
  /**
   * 全局的toString
   * @param arg 任意参数
   * @returns 字符串化的参数
   */
  const globalToString = (arg) => ObjectCls$1.prototype.toString.call(arg);
  /**
   * 判断是否为普通对象
   * @param arg 任意参数
   * @returns 判断结果
   */
  const isPlainObject = (arg) => globalToString(arg) === '[object Object]';
  /**
   * 判断是否为某个类的实例
   * @param arg 任意参数
   * @returns 判断结果
   */
  const instanceOf = (arg, cls) => arg instanceof cls;
  /**
   * 统一的时间戳获取函数
   * @returns 时间戳
   */
  const getTime = (date) => (date ? date.getTime() : Date.now());
  /**
   * 通过method实例获取alova实例
   * @returns alova实例
   */
  const getContext = (methodInstance) => methodInstance.context;
  /**
   * 获取method实例配置数据
   * @returns 配置对象
   */
  const getConfig = (methodInstance) => methodInstance.config;
  /**
   * 获取alova配置数据
   * @returns alova配置对象
   */
  const getContextOptions = (alovaInstance) => alovaInstance.options;
  /**
   * 通过method实例获取alova配置数据
   * @returns alova配置对象
   */
  const getOptions = (methodInstance) => getContextOptions(getContext(methodInstance));
  /**
   * 获取请求方式的key值
   * @returns 此请求方式的key值
   */
  const key = (methodInstance) => {
      const { params, headers } = getConfig(methodInstance);
      return JSONStringify$1([methodInstance.type, methodInstance.url, params, methodInstance.data, headers]);
  };
  /**
   * 获取method实例的key值
   * @param methodInstance method实例
   * @returns 此method实例的key值
   */
  const getMethodInternalKey = (methodInstance) => methodInstance.key;
  /**
   * 是否为特殊数据
   * @param data 提交数据
   * @returns 判断结果
   */
  const isSpecialRequestBody = (data) => {
      const dataTypeString = globalToString(data);
      return (/^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer));
  };
  const objAssign = (target, ...sources) => ObjectCls$1.assign(target, ...sources);
  /**
   * 获取缓存的配置参数，固定返回{ e: function, c: any, f: any, m: number, s: boolean, t: string }格式的对象
   * e为expire缩写，它返回缓存失效时间点（时间戳），单位为毫秒
   * c为controlled，表示是否为受控缓存
   * f为cacheFor原始值，用于在c为true时调用获取缓存数据
   * m为mode缩写，存储模式
   * s为storage缩写，是否存储到本地
   * t为tag缩写，持久化存储标签
   * @param methodInstance method实例
   * @returns 统一的缓存参数对象
   */
  const getLocalCacheConfigParam = (methodInstance) => {
      const { cacheFor } = getConfig(methodInstance);
      const getCacheExpireTs = (cacheExpire) => isNumber(cacheExpire) ? getTime() + cacheExpire : getTime(cacheExpire || undefinedValue$1);
      let cacheMode = MEMORY$1;
      let expire = () => 0;
      let store = falseValue$1;
      let tag = undefinedValue$1;
      const controlled = isFn(cacheFor);
      if (!controlled) {
          let expireColumn = cacheFor;
          if (isPlainObject(cacheFor)) {
              const { mode = MEMORY$1, expire, tag: configTag } = cacheFor || {};
              cacheMode = mode;
              store = mode === STORAGE_RESTORE$1;
              tag = configTag ? configTag.toString() : undefinedValue$1;
              expireColumn = expire;
          }
          expire = (mode) => getCacheExpireTs(isFn(expireColumn) ? expireColumn({ method: methodInstance, mode }) : expireColumn);
      }
      return {
          f: cacheFor,
          c: controlled,
          e: expire,
          m: cacheMode,
          s: store,
          t: tag
      };
  };
  /**
   * 创建类实例
   * @param Cls 构造函数
   * @param args 构造函数参数
   * @returns 类实例
   */
  const newInstance$1 = (Cls, ...args) => new Cls(...args);
  const sloughFunction = (arg, defaultFn) => isFn(arg) ? arg : ![falseValue$1, nullValue].includes(arg) ? defaultFn : noop;
  const cacheKeyPrefix = '$a.';
  /**
   * build common cache key.
   */
  const buildNamespacedCacheKey = (namespace, key) => cacheKeyPrefix + namespace + key;

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  const undefStr$2 = 'undefined';
  // 以下为减少编译代码量而添加的统一处理函数或变量
  const PromiseCls = Promise;
  const promiseReject = (value) => PromiseCls.reject(value);
  const ObjectCls = Object;
  const RegExpCls = RegExp;
  const undefinedValue = undefined;
  const trueValue = true;
  const falseValue = false;
  const promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);
  const promiseCatch = (promise, onrejected) => promise.catch(onrejected);
  const promiseFinally = (promise, onfinally) => promise.finally(onfinally);
  const JSONStringify = (value, replacer, space) => JSON.stringify(value, replacer, space);
  const JSONParse = (value) => JSON.parse(value);
  const objectKeys = (obj) => ObjectCls.keys(obj);
  const forEach = (ary, fn) => ary.forEach(fn);
  const pushItem$1 = (ary, ...item) => ary.push(...item);
  const mapItem$1 = (ary, callbackfn) => ary.map(callbackfn);
  const filterItem$1 = (ary, predicate) => ary.filter(predicate);
  const len = (data) => data.length;
  const isArray = (arg) => Array.isArray(arg);
  const deleteAttr = (arg, attr) => delete arg[attr];
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  const defaultIsSSR = typeof window === undefStr$2 &&
      (typeof process !== undefStr$2 ? typeof process.cwd === 'function' : typeof Deno !== undefStr$2);
  /** cache mode */
  // only cache in memory, it's default option
  const MEMORY = 'memory';
  // persistent cache, and will be read to memory when page is refreshed, it means that the memory cache always exist until cache is expired.
  const STORAGE_RESTORE = 'restore';

  exports.globalConfigMap = {
      autoHitCache: 'global',
      ssr: defaultIsSSR
  };
  /**
   * Set global configuration
   * @param config
   */
  var globalConfig = (config) => {
      exports.globalConfigMap = {
          ...exports.globalConfigMap,
          ...config
      };
  };

  const titleStyle = 'color: black; font-size: 12px; font-weight: bolder';
  /**
   * 默认cacheLogger函数
   */
  var defaultCacheLogger = (response, methodInstance, cacheMode, tag) => {
      const cole = console;
      // eslint-disable-next-line
      const log = (...args) => console.log(...args);
      const { url } = methodInstance;
      const isRestoreMode = cacheMode === STORAGE_RESTORE;
      const hdStyle = '\x1B[42m%s\x1B[49m';
      const labelStyle = '\x1B[32m%s\x1B[39m';
      const startSep = ` [HitCache]${url} `;
      const endSepFn = () => Array(len(startSep) + 1).join('^');
      if (exports.globalConfigMap.ssr) {
          log(hdStyle, startSep);
          log(labelStyle, ' Cache ', response);
          log(labelStyle, ' Mode  ', cacheMode);
          isRestoreMode && log(labelStyle, ' Tag   ', tag);
          log(labelStyle, endSepFn());
      }
      else {
          cole.groupCollapsed
              ? cole.groupCollapsed('%cHitCache', 'padding: 2px 6px; background: #c4fcd3; color: #53b56d;', url)
              : log(hdStyle, startSep);
          log('%c[Cache]', titleStyle, response);
          log('%c[Mode]', titleStyle, cacheMode);
          isRestoreMode && log('%c[Tag]', titleStyle, tag);
          log('%c[Method]', titleStyle, methodInstance);
          cole.groupEnd ? cole.groupEnd() : log(labelStyle, endSepFn());
      }
  };

  const hitSourceStringCacheKey = (key) => `hss.${key}`;
  const hitSourceRegexpPrefix = 'hsr.';
  const hitSourceRegexpCacheKey = (regexpStr) => hitSourceRegexpPrefix + regexpStr;
  const unifiedHitSourceRegexpCacheKey = '$$hsrs';
  const regexpSourceFlagSeparator = '__$<>$__';
  const addItem = (obj, item) => {
      obj[item] = 0;
  };
  /**
   * set or update cache
   * @param namespace 命名空间
   * @param key 存储的key
   * @param response 存储的响应内容
   * @param expireTimestamp 过期时间点的时间戳表示
   * @param storage 存储对象
   * @param tag 存储标签，用于区分不同的存储标记
   */
  const setWithCacheAdapter = async (namespace, key, data, expireTimestamp, cacheAdapter, hitSource, tag) => {
      // not to cache if expireTimestamp is less than current timestamp
      if (expireTimestamp > getTime() && data) {
          const methodCacheKey = buildNamespacedCacheKey(namespace, key);
          await cacheAdapter.set(methodCacheKey, filterItem$1([data, expireTimestamp === Infinity ? undefinedValue : expireTimestamp, tag], Boolean));
          // save the relationship between this method and its hitSources.
          // cache structure is like this:
          /*
            {
              "$a.[namespace][methodKey]": [cache data],
              ...
              "hss.[sourceMethodKey]": "{
                [targetMethodKey1]: 0,
                [targetMethodKey2]: 0,
                ...
              }",
              "hss.[sourceMethodName]": "{
                [targetMethodKey3]: 0,
                [targetMethodKey4]: 0,
                ...
              }",
              "hsr.[sourceMethodNameRegexpSource]": "{
                [targetMethodKey5]: 0,
                [targetMethodKey6]: 0,
                ...
              }",
              "hsr.regexp1": ["hss.key1", "hss.key2"],
              "hsr.regexp2": ["hss.key1", "hss.key2"]
            }
          */
          if (hitSource) {
              // filter repeat items and categorize the regexp, to prevent unnecessary cost of IO
              const hitSourceKeys = {};
              const hitSourceRegexpSources = [];
              forEach(hitSource, sourceItem => {
                  const isRegexp = instanceOf(sourceItem, RegExpCls);
                  const targetHitSourceKey = isRegexp
                      ? sourceItem.source + (sourceItem.flags ? regexpSourceFlagSeparator + sourceItem.flags : '')
                      : sourceItem;
                  if (targetHitSourceKey) {
                      if (isRegexp && !hitSourceKeys[targetHitSourceKey]) {
                          pushItem$1(hitSourceRegexpSources, targetHitSourceKey);
                      }
                      addItem(hitSourceKeys, isRegexp ? hitSourceRegexpCacheKey(targetHitSourceKey) : hitSourceStringCacheKey(targetHitSourceKey));
                  }
              });
              // save the relationship. Minimize IO as much as possible
              const promises = mapItem$1(objectKeys(hitSourceKeys), async (hitSourceKey) => {
                  // filter the empty strings.
                  const targetMethodKeys = (await cacheAdapter.get(hitSourceKey)) || {};
                  addItem(targetMethodKeys, methodCacheKey);
                  await cacheAdapter.set(hitSourceKey, targetMethodKeys);
              });
              const saveRegexp = async () => {
                  // save the regexp source if regexp exists.
                  if (len(hitSourceRegexpSources)) {
                      const regexpList = (await cacheAdapter.get(unifiedHitSourceRegexpCacheKey)) || [];
                      // TODO: hitSourceRegexpSources 需要去重
                      pushItem$1(regexpList, ...hitSourceRegexpSources);
                      await cacheAdapter.set(unifiedHitSourceRegexpCacheKey, regexpList);
                  }
              };
              // parallel executing all async tasks.
              await PromiseCls.all([...promises, saveRegexp()]);
          }
      }
  };
  /**
   * 删除存储的响应数据
   * @param namespace 命名空间
   * @param key 存储的key
   * @param storage 存储对象
   */
  const removeWithCacheAdapter = async (namespace, key, cacheAdapter) => {
      const methodStoreKey = buildNamespacedCacheKey(namespace, key);
      await cacheAdapter.remove(methodStoreKey);
  };
  /**
   * 获取存储的响应数据
   * @param namespace 命名空间
   * @param key 存储的key
   * @param storage 存储对象
   * @param tag 存储标签，标记改变了数据将会失效
   */
  const getRawWithCacheAdapter = async (namespace, key, cacheAdapter, tag) => {
      const storagedData = await cacheAdapter.get(buildNamespacedCacheKey(namespace, key));
      if (storagedData) {
          // eslint-disable-next-line
          const [_, expireTimestamp, storedTag] = storagedData;
          // 如果没有过期时间则表示数据永不过期，否则需要判断是否过期
          if (storedTag === tag && (!expireTimestamp || expireTimestamp > getTime())) {
              return storagedData;
          }
          // 如果过期，则删除缓存
          await removeWithCacheAdapter(namespace, key, cacheAdapter);
      }
  };
  /**
   * 获取存储的响应数据
   * @param namespace 命名空间
   * @param key 存储的key
   * @param storage 存储对象
   * @param tag 存储标签，标记改变了数据将会失效
   */
  const getWithCacheAdapter = async (namespace, key, cacheAdapter, tag) => {
      const rawData = await getRawWithCacheAdapter(namespace, key, cacheAdapter, tag);
      return rawData ? rawData[0] : undefinedValue;
  };
  /**
   * clear all cached data
   */
  const clearWithCacheAdapter = async (cacheAdapters) => PromiseCls.all(cacheAdapters.map(cacheAdapter => cacheAdapter.clear()));
  /**
   * query and delete target cache with key and name of source method instance.
   * @param sourceKey source method instance key
   * @param sourceName source method instance name
   * @param cacheAdapter cache adapter
   */
  const hitTargetCacheWithCacheAdapter = async (sourceKey, sourceName, cacheAdapter) => {
      const sourceNameStr = `${sourceName}`;
      // map that recording the source key and target method keys.
      const sourceTargetKeyMap = {};
      // get hit key by method key.
      const hitSourceKey = hitSourceStringCacheKey(sourceKey);
      sourceTargetKeyMap[hitSourceKey] = await cacheAdapter.get(hitSourceKey);
      let unifiedHitSourceRegexpChannel;
      if (sourceName) {
          const hitSourceName = hitSourceStringCacheKey(sourceNameStr);
          // get hit key by method name if it is exists.
          sourceTargetKeyMap[hitSourceName] = await cacheAdapter.get(hitSourceName);
          // match regexped key by source method name and get hit key by method name.
          unifiedHitSourceRegexpChannel = await cacheAdapter.get(unifiedHitSourceRegexpCacheKey);
          const matchedRegexpStrings = [];
          if (unifiedHitSourceRegexpChannel && len(unifiedHitSourceRegexpChannel)) {
              forEach(unifiedHitSourceRegexpChannel, regexpStr => {
                  const [source, flag] = regexpStr.split(regexpSourceFlagSeparator);
                  if (newInstance$1(RegExpCls, source, flag).test(sourceNameStr)) {
                      pushItem$1(matchedRegexpStrings, regexpStr);
                  }
              });
              // parallel get hit key by matched regexps.
              await PromiseCls.all(mapItem$1(matchedRegexpStrings, async (regexpString) => {
                  const hitSourceRegexpString = hitSourceRegexpCacheKey(regexpString);
                  sourceTargetKeyMap[hitSourceRegexpString] = await cacheAdapter.get(hitSourceRegexpString);
              }));
          }
      }
      const removeWithTargetKey = async (targetKey) => {
          try {
              await cacheAdapter.remove(targetKey);
              // loop sourceTargetKeyMap and remove this key to prevent unnecessary cost of IO.
              for (const sourceKey in sourceTargetKeyMap) {
                  const targetKeys = sourceTargetKeyMap[sourceKey];
                  if (targetKeys) {
                      deleteAttr(targetKeys, targetKey);
                  }
              }
          }
          catch (error) {
              // the try-catch is used to prevent throwing error, cause throwing error in `Promise.all` below.
          }
      };
      // now let's start to delete target caches.
      // and filter the finished keys.
      const accessedKeys = {};
      await PromiseCls.all(mapItem$1(objectKeys(sourceTargetKeyMap), async (sourceKey) => {
          const targetKeys = sourceTargetKeyMap[sourceKey];
          if (targetKeys) {
              const removingPromises = [];
              for (const key in targetKeys) {
                  if (!accessedKeys[key]) {
                      addItem(accessedKeys, key);
                      pushItem$1(removingPromises, removeWithTargetKey(key));
                  }
              }
              await PromiseCls.all(removingPromises);
          }
      }));
      // update source key if there is still has keys.
      // remove source key if its keys is empty.
      const unifiedHitSourceRegexpChannelLen = len(unifiedHitSourceRegexpChannel || []);
      await PromiseCls.all(mapItem$1(objectKeys(sourceTargetKeyMap), async (sourceKey) => {
          const targetKeys = sourceTargetKeyMap[sourceKey];
          if (targetKeys) {
              if (len(objectKeys(targetKeys))) {
                  await cacheAdapter.set(sourceKey, targetKeys);
              }
              else {
                  await cacheAdapter.remove(sourceKey);
                  // if this is a regexped key, need to remove it from unified regexp channel.
                  if (sourceKey.includes(hitSourceRegexpPrefix) && unifiedHitSourceRegexpChannel) {
                      unifiedHitSourceRegexpChannel = filterItem$1(unifiedHitSourceRegexpChannel, rawRegexpStr => hitSourceRegexpCacheKey(rawRegexpStr) !== sourceKey);
                  }
              }
          }
      }));
      // update unified hit source regexp channel if its length was changed.
      if (unifiedHitSourceRegexpChannelLen !== len(unifiedHitSourceRegexpChannel || [])) {
          await cacheAdapter.set(unifiedHitSourceRegexpCacheKey, unifiedHitSourceRegexpChannel);
      }
  };

  var cloneMethod = (methodInstance) => {
      const { data, config } = methodInstance;
      const newConfig = { ...config };
      const { headers = {}, params = {} } = newConfig;
      const ctx = getContext(methodInstance);
      newConfig.headers = { ...headers };
      newConfig.params = { ...params };
      const newMethod = newInstance$1((Method), methodInstance.type, ctx, methodInstance.url, newConfig, data);
      return objAssign(newMethod, {
          ...methodInstance,
          config: newConfig
      });
  };

  /*
   * 以下三个函数中的matcher为Method实例匹配器，它分为3种情况：
   * 1. 如果matcher为Method实例，则清空该Method实例缓存
   * 2. 如果matcher为字符串或正则，则清空所有符合条件的Method实例缓存
   * 3. 如果未传入matcher，则会清空所有缓存
   */
  /**
   * 查询缓存
   * @param matcher Method实例匹配器
   * @returns 缓存数据，未查到时返回undefined
   */
  const queryCache = async (matcher, { policy = 'all' } = {}) => {
      // if key exists, that means it's a method instance.
      if (matcher && matcher.key) {
          const { id, l1Cache, l2Cache } = getContext(matcher);
          const methodKey = getMethodInternalKey(matcher);
          const { f: cacheFor, c: controlled, s: store, e: expireMilliseconds, t: tag } = getLocalCacheConfigParam(matcher);
          // if it's controlled cache, it will return the result of cacheFor function.
          if (controlled) {
              return cacheFor();
          }
          let cachedData = policy !== 'l2' ? await getWithCacheAdapter(id, methodKey, l1Cache) : undefinedValue;
          if (policy === 'l2') {
              cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);
          }
          else if (policy === 'all' && !cachedData) {
              if (store && expireMilliseconds(STORAGE_RESTORE) > getTime()) {
                  cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);
              }
          }
          return cachedData;
      }
  };
  /**
   * 手动设置缓存响应数据，如果对应的methodInstance设置了持久化存储，则还会去检出持久化存储中的缓存
   * @param matcher Method实例匹配器
   * @param data 缓存数据
   */
  const setCache = async (matcher, dataOrUpdater, { policy = 'all' } = {}) => {
      const methodInstances = isArray(matcher) ? matcher : [matcher];
      const batchPromises = methodInstances.map(async (methodInstance) => {
          const { hitSource } = methodInstance;
          const { id, l1Cache, l2Cache } = getContext(methodInstance);
          const methodKey = getMethodInternalKey(methodInstance);
          const { e: expireMilliseconds, s: toStore, t: tag, c: controlled } = getLocalCacheConfigParam(methodInstance);
          // don't set cache when it's controlled cache.
          if (controlled) {
              return;
          }
          let data = dataOrUpdater;
          if (isFn(dataOrUpdater)) {
              let cachedData = policy !== 'l2' ? await getWithCacheAdapter(id, methodKey, l1Cache) : undefinedValue;
              if (policy === 'l2' ||
                  (policy === 'all' && !cachedData && toStore && expireMilliseconds(STORAGE_RESTORE) > getTime())) {
                  cachedData = await getWithCacheAdapter(id, methodKey, l2Cache, tag);
              }
              data = dataOrUpdater(cachedData);
              if (data === undefinedValue) {
                  return;
              }
          }
          return PromiseCls.all([
              policy !== 'l2' && setWithCacheAdapter(id, methodKey, data, expireMilliseconds(MEMORY), l1Cache, hitSource),
              policy === 'l2' || (policy === 'all' && toStore)
                  ? setWithCacheAdapter(id, methodKey, data, expireMilliseconds(STORAGE_RESTORE), l2Cache, hitSource, tag)
                  : undefinedValue
          ]);
      });
      return PromiseCls.all(batchPromises);
  };
  /**
   * 失效缓存
   * @param matcher Method实例匹配器
   */
  const invalidateCache = async (matcher) => {
      if (!matcher) {
          await PromiseCls.all([clearWithCacheAdapter(usingL1CacheAdapters), clearWithCacheAdapter(usingL2CacheAdapters)]);
          return;
      }
      const methodInstances = isArray(matcher) ? matcher : [matcher];
      const batchPromises = methodInstances.map(methodInstance => {
          const { id, l1Cache, l2Cache } = getContext(methodInstance);
          const { c: controlled } = getLocalCacheConfigParam(methodInstance);
          // don't invalidate cache when it's controlled cache.
          if (controlled) {
              return;
          }
          const methodKey = getMethodInternalKey(methodInstance);
          return PromiseCls.all([
              removeWithCacheAdapter(id, methodKey, l1Cache),
              removeWithCacheAdapter(id, methodKey, l2Cache)
          ]);
      });
      await PromiseCls.all(batchPromises);
  };
  /**
   * hit(invalidate) target caches by source method
   * this is the implementation of auto invalidate cache
   * @param sourceMethod source method instance
   */
  const hitCacheBySource = async (sourceMethod) => {
      // 查找hit target cache，让它的缓存失效
      // 通过全局配置`autoHitCache`来控制自动缓存失效范围
      const { autoHitCache } = exports.globalConfigMap;
      const { l1Cache, l2Cache } = getContext(sourceMethod);
      const sourceKey = getMethodInternalKey(sourceMethod);
      const { name: sourceName } = getConfig(sourceMethod);
      const cacheAdaptersInvolved = {
          global: [...usingL1CacheAdapters, ...usingL2CacheAdapters],
          self: [l1Cache, l2Cache],
          close: []
      }[autoHitCache];
      if (cacheAdaptersInvolved && len(cacheAdaptersInvolved)) {
          await PromiseCls.all(mapItem$1(cacheAdaptersInvolved, involvedCacheAdapter => hitTargetCacheWithCacheAdapter(sourceKey, sourceName, involvedCacheAdapter)));
      }
  };

  const adapterReturnMap = {};
  /**
   * 构建完整的url
   * @param base baseURL
   * @param url 路径
   * @param params url参数
   * @returns 完整的url
   */
  const buildCompletedURL = (baseURL, url, params) => {
      // baseURL如果以/结尾，则去掉/
      baseURL = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;
      // 如果不是/或http协议开头的，则需要添加/
      // Compatible with some RESTful usage
      // fix: https://github.com/alovajs/alova/issues/382
      if (url !== '') {
          url = url.match(/^(\/|https?:\/\/)/) ? url : `/${url}`;
      }
      const completeURL = baseURL + url;
      // 将params对象转换为get字符串
      // 过滤掉值为undefined的
      const paramsStr = mapItem$1(filterItem$1(objectKeys(params), key => params[key] !== undefinedValue), key => `${key}=${params[key]}`).join('&');
      // 将get参数拼接到url后面，注意url可能已存在参数
      return paramsStr
          ? +completeURL.includes('?')
              ? `${completeURL}&${paramsStr}`
              : `${completeURL}?${paramsStr}`
          : completeURL;
  };
  /**
   * 实际的请求函数
   * @param method 请求方法对象
   * @param forceRequest 忽略缓存
   * @returns 响应数据
   */
  function sendRequest(methodInstance, forceRequest) {
      let fromCache = trueValue;
      let requestAdapterCtrlsPromiseResolveFn;
      const requestAdapterCtrlsPromise = newInstance$1(PromiseCls, resolve => {
          requestAdapterCtrlsPromiseResolveFn = resolve;
      });
      const response = async () => {
          const { beforeRequest = noop, responded, requestAdapter, cacheLogger } = getOptions(methodInstance);
          const methodKey = getMethodInternalKey(methodInstance);
          const { s: toStorage, t: tag, m: cacheMode, e: expireMilliseconds } = getLocalCacheConfigParam(methodInstance);
          const { id, l1Cache, l2Cache, snapshots } = getContext(methodInstance);
          // 获取受控缓存或非受控缓存
          const { cacheFor } = getConfig(methodInstance);
          const { hitSource: methodHitSource } = methodInstance;
          // 如果当前method设置了受控缓存，则看是否有自定义的数据
          let cachedResponse = await (isFn(cacheFor)
              ? cacheFor()
              : // 如果是强制请求的，则跳过从缓存中获取的步骤
                  // 否则判断是否使用缓存数据
                  forceRequest
                      ? undefinedValue
                      : getWithCacheAdapter(id, methodKey, l1Cache));
          // 如果是STORAGE_RESTORE模式，且缓存没有数据时，则需要将持久化数据恢复到缓存中，过期时间要使用缓存的
          if (cacheMode === STORAGE_RESTORE && !cachedResponse) {
              const rawL2CacheData = await getRawWithCacheAdapter(id, methodKey, l2Cache, tag);
              if (rawL2CacheData) {
                  const [l2Response, l2ExpireMilliseconds] = rawL2CacheData;
                  await setWithCacheAdapter(id, methodKey, l2Response, l2ExpireMilliseconds, l1Cache, methodHitSource);
                  cachedResponse = l2Response;
              }
          }
          // 克隆method作为参数传给beforeRequest，防止多次使用原method实例请求时产生副作用
          // 放在` let cachedResponse = await ...`之后，解决在method.send中先赋值promise给method实例的问题，否则在clonedMethod中promise为undefined
          const clonedMethod = cloneMethod(methodInstance);
          // 发送请求前调用钩子函数
          // beforeRequest支持同步函数和异步函数
          await beforeRequest(clonedMethod);
          const { baseURL, url: newUrl, type, data } = clonedMethod;
          const { params = {}, headers = {}, transform = $self, shareRequest } = getConfig(clonedMethod);
          const namespacedAdapterReturnMap = (adapterReturnMap[id] = adapterReturnMap[id] || {});
          let requestAdapterCtrls = namespacedAdapterReturnMap[methodKey];
          let responseSuccessHandler = $self;
          let responseErrorHandler = undefinedValue;
          let responseCompleteHandler = noop;
          // uniform handler of onSuccess, onError, onComplete
          if (isFn(responded)) {
              responseSuccessHandler = responded;
          }
          else if (isPlainObject(responded)) {
              const { onSuccess: successHandler, onError: errorHandler, onComplete: completeHandler } = responded;
              responseSuccessHandler = isFn(successHandler) ? successHandler : responseSuccessHandler;
              responseErrorHandler = isFn(errorHandler) ? errorHandler : responseErrorHandler;
              responseCompleteHandler = isFn(completeHandler) ? completeHandler : responseCompleteHandler;
          }
          // 如果没有缓存则发起请求
          if (cachedResponse !== undefinedValue) {
              requestAdapterCtrlsPromiseResolveFn(); // 遇到缓存将不传入ctrls
              // 打印缓存日志
              sloughFunction(cacheLogger, defaultCacheLogger)(cachedResponse, clonedMethod, cacheMode, tag);
              responseCompleteHandler(clonedMethod);
              return cachedResponse;
          }
          fromCache = falseValue;
          if (!shareRequest || !requestAdapterCtrls) {
              // 请求数据
              const ctrls = requestAdapter({
                  url: buildCompletedURL(baseURL, newUrl, params),
                  type,
                  data,
                  headers
              }, clonedMethod);
              requestAdapterCtrls = namespacedAdapterReturnMap[methodKey] = ctrls;
          }
          // 将requestAdapterCtrls传到promise中供onDownload、onUpload及abort中使用
          requestAdapterCtrlsPromiseResolveFn(requestAdapterCtrls);
          /**
           * 处理响应任务，失败时不缓存数据
           * @param responsePromise 响应promise实例
           * @param responseHeaders 请求头
           * @param callInSuccess 是否在成功回调中调用
           * @returns 处理后的response
           */
          const handleResponseTask = async (handlerReturns, responseHeaders, callInSuccess = trueValue) => {
              const responseData = await handlerReturns;
              const transformedData = await transform(responseData, responseHeaders || {});
              snapshots.save(methodInstance);
              // 即使缓存操作失败，也正常返回响应结构，避免因缓存操作问题导致请求错误
              // 缓存操作结果，可通过`cacheAdapter.emitter.on('success' | 'fail', event => {})`监听获取
              try {
                  // 自动失效缓存
                  await hitCacheBySource(clonedMethod);
              }
              catch (error) { }
              // 当requestBody为特殊数据时不保存缓存
              // 原因1：特殊数据一般是提交特殊数据，需要和服务端交互
              // 原因2：特殊数据不便于生成缓存key
              const requestBody = clonedMethod.data;
              const toCache = !requestBody || !isSpecialRequestBody(requestBody);
              // 使用响应后最新的过期时间来缓存数据，避免因响应时间过长导致过期时间流失的问题
              if (toCache && callInSuccess) {
                  try {
                      await PromiseCls.all([
                          setWithCacheAdapter(id, methodKey, transformedData, expireMilliseconds(MEMORY), l1Cache, methodHitSource),
                          toStorage &&
                              setWithCacheAdapter(id, methodKey, transformedData, expireMilliseconds(STORAGE_RESTORE), l2Cache, methodHitSource, tag)
                      ]);
                  }
                  catch (error) { }
              }
              return transformedData;
          };
          return promiseFinally(promiseThen(PromiseCls.all([requestAdapterCtrls.response(), requestAdapterCtrls.headers()]), ([rawResponse, rawHeaders]) => {
              // 无论请求成功、失败，都需要首先移除共享的请求
              deleteAttr(namespacedAdapterReturnMap, methodKey);
              return handleResponseTask(responseSuccessHandler(rawResponse, clonedMethod), rawHeaders);
          }, (error) => {
              // 无论请求成功、失败，都需要首先移除共享的请求
              deleteAttr(namespacedAdapterReturnMap, methodKey);
              return isFn(responseErrorHandler)
                  ? // 响应错误时，如果未抛出错误也将会处理响应成功的流程，但不缓存数据
                      handleResponseTask(responseErrorHandler(error, clonedMethod), undefinedValue, falseValue)
                  : promiseReject(error);
          }), () => {
              responseCompleteHandler(clonedMethod);
          });
      };
      return {
          // 请求中断函数
          abort: () => {
              promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.abort());
          },
          onDownload: (handler) => {
              promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.onDownload && requestAdapterCtrls.onDownload(handler));
          },
          onUpload: (handler) => {
              promiseThen(requestAdapterCtrlsPromise, requestAdapterCtrls => requestAdapterCtrls && requestAdapterCtrls.onUpload && requestAdapterCtrls.onUpload(handler));
          },
          response,
          fromCache: () => fromCache
      };
  }

  const offEventCallback = (offHandler, handlers) => () => {
      const index = handlers.indexOf(offHandler);
      index >= 0 && handlers.splice(index, 1);
  };
  class Method {
      constructor(type, context, url, config, data) {
          this.dhs = [];
          this.uhs = [];
          this.fromCache = undefinedValue;
          const abortRequest = () => {
              abortRequest.a();
          };
          abortRequest.a = noop;
          const instance = this;
          const contextOptions = getContextOptions(context);
          instance.abort = abortRequest;
          instance.baseURL = contextOptions.baseURL || '';
          instance.url = url;
          instance.type = type;
          instance.context = context;
          // 将请求相关的全局配置合并到Method对象中
          const contextConcatConfig = {};
          const mergedLocalCacheKey = 'cacheFor';
          const globalLocalCache = isPlainObject(contextOptions[mergedLocalCacheKey])
              ? contextOptions[mergedLocalCacheKey][type]
              : undefinedValue;
          const hitSource = config && config.hitSource;
          // 合并参数
          forEach(['timeout', 'shareRequest'], mergedKey => {
              if (contextOptions[mergedKey] !== undefinedValue) {
                  contextConcatConfig[mergedKey] = contextOptions[mergedKey];
              }
          });
          // 合并localCache
          if (globalLocalCache !== undefinedValue) {
              contextConcatConfig[mergedLocalCacheKey] = globalLocalCache;
          }
          // 将hitSource统一处理成数组，且当有method实例时将它们转换为methodKey
          if (hitSource) {
              instance.hitSource = mapItem$1(isArray(hitSource) ? hitSource : [hitSource], sourceItem => instanceOf(sourceItem, Method) ? getMethodInternalKey(sourceItem) : sourceItem);
              deleteAttr(config, 'hitSource');
          }
          instance.config = {
              ...contextConcatConfig,
              headers: {},
              params: {},
              ...(config || {})
          };
          instance.data = data;
          instance.meta = config ? config.meta : instance.meta;
          // 在外部需要使用原始的key，而不是实时生成key
          // 原因是，method的参数可能传入引用类型值，但引用类型值在外部改变时，实时生成的key也随之改变，因此使用最开始的key更准确
          instance.key = instance.generateKey();
      }
      /**
       * 绑定下载进度回调函数
       * @param progressHandler 下载进度回调函数
       * @version 2.17.0
       * @return 解绑函数
       */
      onDownload(downloadHandler) {
          pushItem$1(this.dhs, downloadHandler);
          return offEventCallback(downloadHandler, this.dhs);
      }
      /**
       * 绑定上传进度回调函数
       * @param progressHandler 上传进度回调函数
       * @version 2.17.0
       * @return 解绑函数
       */
      onUpload(uploadHandler) {
          pushItem$1(this.uhs, uploadHandler);
          return offEventCallback(uploadHandler, this.uhs);
      }
      /**
       * 通过method实例发送请求，返回promise对象
       */
      send(forceRequest = falseValue) {
          const instance = this;
          const { response, onDownload, onUpload, abort, fromCache } = sendRequest(instance, forceRequest);
          len(instance.dhs) > 0 &&
              onDownload((loaded, total) => forEach(instance.dhs, handler => handler({ loaded, total })));
          len(instance.uhs) > 0 && onUpload((loaded, total) => forEach(instance.uhs, handler => handler({ loaded, total })));
          // 每次请求时将中断函数绑定给method实例，使用者也可通过methodInstance.abort()来中断当前请求
          instance.abort.a = abort;
          instance.fromCache = undefinedValue;
          instance.promise = promiseThen(response(), r => {
              instance.fromCache = fromCache();
              return r;
          });
          return instance.promise;
      }
      /**
       * 设置方法名称，如果已有名称将被覆盖
       * @param name 方法名称
       */
      setName(name) {
          getConfig(this).name = name;
      }
      generateKey() {
          return key(this);
      }
      /**
       * 绑定resolve和/或reject Promise的callback
       * @param onfulfilled resolve Promise时要执行的回调
       * @param onrejected 当Promise被reject时要执行的回调
       * @returns 返回一个Promise，用于执行任何回调
       */
      then(onfulfilled, onrejected) {
          return promiseThen(this.send(), onfulfilled, onrejected);
      }
      /**
       * 绑定一个仅用于reject Promise的回调
       * @param onrejected 当Promise被reject时要执行的回调
       * @returns 返回一个完成回调的Promise
       */
      catch(onrejected) {
          return promiseCatch(this.send(), onrejected);
      }
      /**
       * 绑定一个回调，该回调在Promise结算（resolve或reject）时调用
       * @param onfinally Promise结算（resolve或reject）时执行的回调。
       * @return 返回一个完成回调的Promise。
       */
      finally(onfinally) {
          return promiseFinally(this.send(), onfinally);
      }
  }

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  const undefStr$1 = 'undefined';
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr$1 &&
      (typeof process !== undefStr$1 ? typeof process.cwd === 'function' : typeof Deno !== undefStr$1);

  /**
   * 创建类实例
   * @param Cls 构造函数
   * @param args 构造函数参数
   * @returns 类实例
   */
  const newInstance = (Cls, ...args) => new Cls(...args);

  /**
   * alova错误类
   */
  class AlovaError extends Error {
      constructor(prefix, message, errorCode) {
          super(message + (errorCode ? `\n\nFor detailed: https://alova.js.org/error#${errorCode}` : ''));
          this.name = `[alova${prefix ? `/${prefix}` : ''}]`;
      }
  }
  /**
   * 自定义断言函数，表达式为false时抛出错误
   * 当传入了errorCode时，将提供链接到错误文档，引导用户改正
   * @param expression 判断表达式，true或false
   * @param message 断言消息
   */
  const createAssert = (prefix = '') => (expression, message, errorCode) => {
      if (!expression) {
          throw newInstance(AlovaError, prefix, message, errorCode);
      }
  };

  // import { get } from '@alova/shared';
  /**
   * 自定义断言函数，表达式为false时抛出错误
   * @param expression 判断表达式，true或false
   * @param msg 断言消息
   */
  const myAssert = createAssert();

  /**
    * @alova/shared 1.0.5 (undefined)
    * Document undefined
    * Copyright 2024 Scott Hu. All Rights Reserved
    * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
  */

  const undefStr = 'undefined';
  const pushItem = (ary, ...item) => ary.push(...item);
  const mapItem = (ary, callbackfn) => ary.map(callbackfn);
  const filterItem = (ary, predicate) => ary.filter(predicate);
  // 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
  // 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
  // 因此使用服务端独有的 process.cwd 函数作为判断依据
  typeof window === undefStr &&
      (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);

  const createEventManager = () => {
      const eventMap = {};
      return {
          eventMap,
          on(type, handler) {
              const eventTypeItem = (eventMap[type] = eventMap[type] || []);
              pushItem(eventTypeItem, handler);
              // return the off function
              return () => {
                  eventMap[type] = filterItem(eventTypeItem, item => item !== handler);
              };
          },
          off(type, handler) {
              const handlers = eventMap[type];
              if (!handlers) {
                  return;
              }
              if (handler) {
                  const index = handlers.indexOf(handler);
                  index > -1 && handlers.splice(index, 1);
              }
              else {
                  delete eventMap[type];
              }
          },
          emit(type, event) {
              const handlers = eventMap[type] || [];
              return mapItem(handlers, handler => handler(event));
          }
      };
  };

  // local storage will not fail the operation.
  const EVENT_SUCCESS_KEY = 'success';
  const memoryAdapter = () => {
      let l1Cache = {};
      const l1CacheEmitter = createEventManager();
      const adapter = {
          set(key, value) {
              l1Cache[key] = value;
              l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'set', key, value, container: l1Cache });
          },
          get: key => {
              const value = l1Cache[key];
              l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'get', key, value, container: l1Cache });
              return value;
          },
          remove(key) {
              deleteAttr(l1Cache, key);
              l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'remove', key, container: l1Cache });
          },
          clear: () => {
              l1Cache = {};
              l1CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'clear', key: '', container: l1Cache });
          },
          emitter: l1CacheEmitter
      };
      return adapter;
  };
  const // delay get localStorage by function, and avoid erroring at initialization
  storage = () => {
      myAssert(typeof localStorage !== 'undefined', 'l2Cache is not defined.');
      return localStorage;
  };
  const localStorageAdapter = () => {
      const l2CacheEmitter = createEventManager();
      const adapter = {
          set: (key, value) => {
              storage().setItem(key, JSONStringify(value));
              l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'set', key, value, container: storage() });
          },
          get: key => {
              const data = storage().getItem(key);
              const value = data ? JSONParse(data) : data;
              l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'get', key, value, container: storage() });
              return value;
          },
          remove: key => {
              storage().removeItem(key);
              l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'remove', key, container: storage() });
          },
          clear: () => {
              storage().clear();
              l2CacheEmitter.emit(EVENT_SUCCESS_KEY, { type: 'clear', key: '', container: storage() });
          },
          emitter: l2CacheEmitter
      };
      return adapter;
  };

  const SetCls = Set;
  class MethodSnapshotContainer {
      constructor(capacity) {
          /**
           * method实例快照集合，发送过请求的method实例将会被保存
           */
          this.records = {};
          this.occupy = 0;
          myAssert(capacity >= 0, 'expected snapshots limit to be >= 0');
          this.capacity = capacity;
      }
      /**
       * 保存method实例快照
       * @param methodInstance method实例
       */
      save(methodInstance) {
          const { name } = getConfig(methodInstance);
          const { records, occupy, capacity } = this;
          if (name && occupy < capacity) {
              // 以method的name为key，将method实例保存到快照中
              const targetSnapshots = (records[name] = records[name] || newInstance$1(SetCls));
              targetSnapshots.add(methodInstance);
              // 统计数量
              this.occupy += 1;
          }
      }
      /**
       * 获取Method实例快照，它将根据matcher来筛选出对应的Method实例
       * @param matcher 匹配的快照名称，可以是字符串或正则表达式、或带过滤函数的对象
       * @returns 匹配到的Method实例快照数组
       */
      match(matcher, matchAll = true) {
          // 将filter参数统一解构为nameMatcher和matchHandler
          let nameString;
          let nameReg;
          let matchHandler;
          let nameMatcher = matcher;
          if (isPlainObject(matcher)) {
              nameMatcher = matcher.name;
              matchHandler = matcher.filter;
          }
          if (instanceOf(nameMatcher, RegExpCls)) {
              nameReg = nameMatcher;
          }
          else if (isString(nameMatcher)) {
              nameString = nameMatcher;
          }
          const { records } = this;
          // 通过解构的nameMatcher和filterHandler，获取对应的Method实例快照
          let matches = newInstance$1((SetCls));
          // 如果有提供namespace参数则只在这个namespace中查找，否则在所有缓存数据中查找
          if (nameString) {
              matches = records[nameString] || matches;
          }
          else if (nameReg) {
              forEach(filterItem$1(objectKeys(records), methodName => nameReg.test(methodName)), methodName => {
                  records[methodName].forEach(method => matches.add(method));
              });
          }
          const fromMatchesArray = isFn(matchHandler) ? filterItem$1([...matches], matchHandler) : [...matches];
          return (matchAll ? fromMatchesArray : fromMatchesArray[0]);
      }
  }

  const typeGet = 'GET';
  const typeHead = 'HEAD';
  const typePost = 'POST';
  const typePut = 'PUT';
  const typePatch = 'PATCH';
  const typeDelete = 'DELETE';
  const typeOptions = 'OPTIONS';
  const defaultAlovaOptions = {
      /**
       * GET请求默认缓存5分钟（300000毫秒），其他请求默认不缓存
       */
      cacheFor: {
          [typeGet]: 300000
      },
      /**
       * 共享请求默认为true
       */
      shareRequest: trueValue,
      /**
       * method快照数量，默认为1000
       */
      snapshots: 1000
  };
  let idCount = 0;
  class Alova {
      constructor(options) {
          var _a, _b;
          const instance = this;
          instance.id = (options.id || (idCount += 1)).toString();
          // 如果storage未指定，则默认使用localStorage
          instance.l1Cache = options.l1Cache || memoryAdapter();
          instance.l2Cache = options.l2Cache || localStorageAdapter();
          // 合并默认options
          instance.options = {
              ...defaultAlovaOptions,
              ...options
          };
          instance.snapshots = newInstance$1((MethodSnapshotContainer), (_b = (_a = options.snapshots) !== null && _a !== void 0 ? _a : defaultAlovaOptions.snapshots) !== null && _b !== void 0 ? _b : 0);
      }
      Get(url, config) {
          return newInstance$1((Method), typeGet, this, url, config);
      }
      Post(url, data, config) {
          return newInstance$1((Method), typePost, this, url, config, data);
      }
      Delete(url, data, config) {
          return newInstance$1((Method), typeDelete, this, url, config, data);
      }
      Put(url, data, config) {
          return newInstance$1((Method), typePut, this, url, config, data);
      }
      Head(url, config) {
          return newInstance$1((Method), typeHead, this, url, config);
      }
      Patch(url, data, config) {
          return newInstance$1((Method), typePatch, this, url, config, data);
      }
      Options(url, config) {
          return newInstance$1((Method), typeOptions, this, url, config);
      }
  }
  let boundStatesHook = undefinedValue;
  const usingL1CacheAdapters = [];
  const usingL2CacheAdapters = [];
  /**
   * create an alova instance.
   * @param options alova configuration.
   * @returns alova instance.
   */
  const createAlova = (options) => {
      const alovaInstance = newInstance$1((Alova), options);
      const newStatesHook = alovaInstance.options.statesHook;
      if (boundStatesHook) {
          myAssert(boundStatesHook === newStatesHook, 'expected to use the same `statesHook`');
      }
      boundStatesHook = newStatesHook;
      const { l1Cache, l2Cache } = alovaInstance;
      !usingL1CacheAdapters.includes(l1Cache) && pushItem$1(usingL1CacheAdapters, l1Cache);
      !usingL2CacheAdapters.includes(l2Cache) && pushItem$1(usingL2CacheAdapters, l2Cache);
      return alovaInstance;
  };

  const promiseStatesHook = () => {
      myAssert(!!boundStatesHook, `\`statesHook\` is not set in alova instance`);
      return boundStatesHook;
  };

  exports.Method = Method;
  exports.createAlova = createAlova;
  exports.globalConfig = globalConfig;
  exports.hitCacheBySource = hitCacheBySource;
  exports.invalidateCache = invalidateCache;
  exports.promiseStatesHook = promiseStatesHook;
  exports.queryCache = queryCache;
  exports.setCache = setCache;

}));
