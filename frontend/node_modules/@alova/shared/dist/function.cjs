/**
  * @alova/shared 1.0.5 (undefined)
  * Document undefined
  * Copyright 2024 Scott Hu. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
*/

'use strict';

class FrameworkReadableState {
    constructor(state, key, dehydrate, exportState) {
        this.s = state;
        this.k = key;
        this.$dhy = dehydrate;
        this.$exp = exportState;
    }
    get v() {
        return this.$dhy(this.s);
    }
    get e() {
        return this.$exp(this.s);
    }
}
class FrameworkState extends FrameworkReadableState {
    constructor(state, key, dehydrate, exportState, update) {
        super(state, key, dehydrate, exportState);
        this.$upd = update;
    }
    set v(newValue) {
        this.$upd(this.s, newValue);
    }
    get v() {
        return super.v;
    }
}

const undefStr = 'undefined';
// 以下为减少编译代码量而添加的统一处理函数或变量
const PromiseCls = Promise;
const ObjectCls = Object;
const undefinedValue = undefined;
const nullValue = null;
const trueValue = true;
const falseValue = false;
const promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);
const JSONStringify = (value, replacer, space) => JSON.stringify(value, replacer, space);
const setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);
const objectKeys = (obj) => ObjectCls.keys(obj);
const forEach = (ary, fn) => ary.forEach(fn);
const pushItem = (ary, ...item) => ary.push(...item);
const mapItem = (ary, callbackfn) => ary.map(callbackfn);
const shift = (ary) => ary.shift();
const len = (data) => data.length;
const typeOf = (arg) => typeof arg;
const includes = (ary, target) => ary.includes(target);
// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
// 因此使用服务端独有的 process.cwd 函数作为判断依据
typeof window === undefStr &&
    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);
/** cache mode */
// only cache in memory, it's default option
const MEMORY = 'memory';
// persistent cache, and will be read to memory when page is refreshed, it means that the memory cache always exist until cache is expired.
const STORAGE_RESTORE = 'restore';

/**
 * 空函数，做兼容处理
 */
const noop = () => { };
/**
 * 返回参数自身的函数，做兼容处理用
 * 由于部分系统将self作为了保留字，故使用$self来区分
 * @param arg 任意参数
 * @returns 返回参数本身
 */
const $self = (arg) => arg;
/**
 * 判断参数是否为函数
 * @param fn 任意参数
 * @returns 该参数是否为函数
 */
const isFn = (arg) => typeOf(arg) === 'function';
/**
 * 判断参数是否为数字
 * @param arg 任意参数
 * @returns 该参数是否为数字
 */
const isNumber = (arg) => typeOf(arg) === 'number' && !Number.isNaN(arg);
/**
 * 判断参数是否为字符串
 * @param arg 任意参数
 * @returns 该参数是否为字符串
 */
const isString = (arg) => typeOf(arg) === 'string';
/**
 * 判断参数是否为对象
 * @param arg 任意参数
 * @returns 该参数是否为对象
 */
const isObject = (arg) => arg !== nullValue && typeOf(arg) === 'object';
/**
 * 全局的toString
 * @param arg 任意参数
 * @returns 字符串化的参数
 */
const globalToString = (arg) => ObjectCls.prototype.toString.call(arg);
/**
 * 判断是否为普通对象
 * @param arg 任意参数
 * @returns 判断结果
 */
const isPlainObject = (arg) => globalToString(arg) === '[object Object]';
/**
 * 判断是否为某个类的实例
 * @param arg 任意参数
 * @returns 判断结果
 */
const instanceOf = (arg, cls) => arg instanceof cls;
/**
 * 统一的时间戳获取函数
 * @returns 时间戳
 */
const getTime = (date) => (date ? date.getTime() : Date.now());
/**
 * 通过method实例获取alova实例
 * @returns alova实例
 */
const getContext = (methodInstance) => methodInstance.context;
/**
 * 获取method实例配置数据
 * @returns 配置对象
 */
const getConfig = (methodInstance) => methodInstance.config;
/**
 * 获取alova配置数据
 * @returns alova配置对象
 */
const getContextOptions = (alovaInstance) => alovaInstance.options;
/**
 * 通过method实例获取alova配置数据
 * @returns alova配置对象
 */
const getOptions = (methodInstance) => getContextOptions(getContext(methodInstance));
/**
 * 获取请求方式的key值
 * @returns 此请求方式的key值
 */
const key = (methodInstance) => {
    const { params, headers } = getConfig(methodInstance);
    return JSONStringify([methodInstance.type, methodInstance.url, params, methodInstance.data, headers]);
};
/**
 * 创建uuid简易版
 * @returns uuid
 */
const uuid = () => {
    const timestamp = new Date().getTime();
    return Math.floor(Math.random() * timestamp).toString(36);
};
/**
 * 获取method实例的key值
 * @param methodInstance method实例
 * @returns 此method实例的key值
 */
const getMethodInternalKey = (methodInstance) => methodInstance.key;
/**
 * 获取请求方法对象
 * @param methodHandler 请求方法句柄
 * @param args 方法调用参数
 * @returns 请求方法对象
 */
const getHandlerMethod = (methodHandler, assert, args = []) => {
    const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;
    assert(!!methodInstance.key, 'hook handler must be a method instance or a function that returns method instance');
    return methodInstance;
};
/**
 * 是否为特殊数据
 * @param data 提交数据
 * @returns 判断结果
 */
const isSpecialRequestBody = (data) => {
    const dataTypeString = globalToString(data);
    return (/^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer));
};
const objAssign = (target, ...sources) => ObjectCls.assign(target, ...sources);
/**
 * 排除一个数据集合中指定的属性，并返回新的数据集合
 * @param obj 数据集合
 * @param keys 排除的key
 * @returns 新的数据集合
 */
const omit = (obj, ...keys) => {
    const result = {};
    for (const key in obj) {
        if (!keys.includes(key)) {
            result[key] = obj[key];
        }
    }
    return result;
};
/**
 * the same as `Promise.withResolvers`
 * @returns promise with resolvers.
 */
function usePromise() {
    let retResolve;
    let retReject;
    const promise = new Promise((resolve, reject) => {
        retResolve = resolve;
        retReject = reject;
    });
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return { promise, resolve: retResolve, reject: retReject };
}
/**
 * 获取缓存的配置参数，固定返回{ e: function, c: any, f: any, m: number, s: boolean, t: string }格式的对象
 * e为expire缩写，它返回缓存失效时间点（时间戳），单位为毫秒
 * c为controlled，表示是否为受控缓存
 * f为cacheFor原始值，用于在c为true时调用获取缓存数据
 * m为mode缩写，存储模式
 * s为storage缩写，是否存储到本地
 * t为tag缩写，持久化存储标签
 * @param methodInstance method实例
 * @returns 统一的缓存参数对象
 */
const getLocalCacheConfigParam = (methodInstance) => {
    const { cacheFor } = getConfig(methodInstance);
    const getCacheExpireTs = (cacheExpire) => isNumber(cacheExpire) ? getTime() + cacheExpire : getTime(cacheExpire || undefinedValue);
    let cacheMode = MEMORY;
    let expire = () => 0;
    let store = falseValue;
    let tag = undefinedValue;
    const controlled = isFn(cacheFor);
    if (!controlled) {
        let expireColumn = cacheFor;
        if (isPlainObject(cacheFor)) {
            const { mode = MEMORY, expire, tag: configTag } = cacheFor || {};
            cacheMode = mode;
            store = mode === STORAGE_RESTORE;
            tag = configTag ? configTag.toString() : undefinedValue;
            expireColumn = expire;
        }
        expire = (mode) => getCacheExpireTs(isFn(expireColumn) ? expireColumn({ method: methodInstance, mode }) : expireColumn);
    }
    return {
        f: cacheFor,
        c: controlled,
        e: expire,
        m: cacheMode,
        s: store,
        t: tag
    };
};
/**
 * 创建类实例
 * @param Cls 构造函数
 * @param args 构造函数参数
 * @returns 类实例
 */
const newInstance = (Cls, ...args) => new Cls(...args);
/**
 * 统一配置
 * @param 数据
 * @returns 统一的配置
 */
const sloughConfig = (config, args = []) => isFn(config) ? config(...args) : config;
const sloughFunction = (arg, defaultFn) => isFn(arg) ? arg : ![falseValue, nullValue].includes(arg) ? defaultFn : noop;
/**
 * 创建同步多次调用只在异步执行一次的执行器
 */
const createSyncOnceRunner = (delay = 0) => {
    let timer = undefinedValue;
    // 执行多次调用此函数将异步执行一次
    return (fn) => {
        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeoutFn(fn, delay);
    };
};
/**
 * 创建异步函数队列，异步函数将串行执行
 * @returns 队列添加函数
 */
const createAsyncQueue = (catchError = falseValue) => {
    const queue = [];
    let completedHandler = undefinedValue;
    let executing = false;
    const executeQueue = async () => {
        executing = true;
        while (len(queue) > 0) {
            const asyncFunc = shift(queue);
            if (asyncFunc) {
                await asyncFunc();
            }
        }
        completedHandler && completedHandler();
        executing = false;
    };
    const addQueue = (asyncFunc) => newInstance((PromiseCls), (resolve, reject) => {
        const wrappedFunc = () => promiseThen(asyncFunc(), resolve, err => {
            catchError ? resolve(undefinedValue) : reject(err);
        });
        pushItem(queue, wrappedFunc);
        if (!executing) {
            executeQueue();
        }
    });
    const onComplete = (fn) => {
        completedHandler = fn;
    };
    return {
        addQueue,
        onComplete
    };
};
/**
 * 深层遍历目标对象
 * @param target 目标对象
 * @param callback 遍历回调
 * @param preorder 是否前序遍历，默认为true
 * @param key 当前遍历的key
 * @param parent 当前遍历的父节点
 */
const walkObject = (target, callback, preorder = trueValue, key, parent) => {
    const callCallback = () => {
        if (parent && key) {
            target = callback(target, key, parent);
            if (target !== parent[key]) {
                parent[key] = target;
            }
        }
    };
    // 前序遍历
    preorder && callCallback();
    if (isObject(target)) {
        for (const i in target) {
            if (!instanceOf(target, String)) {
                walkObject(target[i], callback, preorder, i, target);
            }
        }
    }
    // 后序遍历
    !preorder && callCallback();
    return target;
};
/**
 * create simple and unified, framework-independent states creators and handlers.
 * @param statesHook states hook from `promiseStatesHook` function of alova
 * @param referingObject refering object exported from `promiseStatesHook` function
 * @returns simple and unified states creators and handlers
 */
function statesHookHelper(statesHook, referingObject = { trackedKeys: {}, bindError: falseValue }) {
    const ref = (initialValue) => (statesHook.ref ? statesHook.ref(initialValue) : { current: initialValue });
    referingObject = ref(referingObject).current;
    const exportState = (state) => (statesHook.export || $self)(state, referingObject);
    const memorize = (fn) => {
        if (!isFn(statesHook.memorize)) {
            return fn;
        }
        const memorizedFn = statesHook.memorize(fn);
        memorizedFn.memorized = true;
        return memorizedFn;
    };
    const { dehydrate } = statesHook;
    // For performance reasons, only value is different, and the key is tracked can be updated.
    const update = (newValue, state, key) => newValue !== dehydrate(state, key, referingObject) &&
        referingObject.trackedKeys[key] &&
        statesHook.update(newValue, state, key, referingObject);
    const mapDeps = (deps) => mapItem(deps, item => (instanceOf(item, FrameworkReadableState) ? item.e : item));
    const createdStateList = [];
    // key of deps on computed
    const depKeys = {};
    return {
        create: (initialValue, key) => {
            pushItem(createdStateList, key); // record the keys of created states.
            return newInstance((FrameworkState), statesHook.create(initialValue, key, referingObject), key, state => dehydrate(state, key, referingObject), exportState, (state, newValue) => update(newValue, state, key));
        },
        computed: (getter, depList, key) => {
            // Collect all dependencies in computed
            forEach(depList, dep => {
                if (dep.k) {
                    depKeys[dep.k] = true;
                }
            });
            return newInstance((FrameworkReadableState), statesHook.computed(getter, mapDeps(depList), key, referingObject), key, state => dehydrate(state, key, referingObject), exportState);
        },
        effectRequest: (effectRequestParams) => statesHook.effectRequest(effectRequestParams, referingObject),
        ref,
        watch: (source, callback) => statesHook.watch(mapDeps(source), callback, referingObject),
        onMounted: (callback) => statesHook.onMounted(callback, referingObject),
        onUnmounted: (callback) => statesHook.onUnmounted(callback, referingObject),
        /**
         * refering object that sharing some value with this object.
         */
        __referingObj: referingObject,
        /**
         * expose provider for specified use hook.
         * @param object object that contains state proxy, framework state, operating function and event binder.
         * @returns provider component.
         */
        exposeProvider: (object) => {
            const provider = {};
            const originalStatesMap = {};
            for (const key in object) {
                const value = object[key];
                const isValueFunction = isFn(value);
                // if it's a memorized function, don't memorize it any more, add it to provider directly.
                // if it's start with `on`, it indicates it is an event binder, we should define a new function which return provider object.
                // if it's a common function, add it to provider with memorize mode.
                if (isValueFunction) {
                    provider[key] = key.startsWith('on')
                        ? (...args) => {
                            value(...args);
                            // eslint-disable-next-line
                            return completedProvider;
                        }
                        : value.memorized
                            ? value
                            : memorize(value);
                }
                else {
                    const isFrameworkState = instanceOf(value, FrameworkReadableState);
                    if (isFrameworkState) {
                        originalStatesMap[key] = value.s;
                    }
                    // otherwise, it's a state proxy or framework state, add it to provider with getter mode.
                    ObjectCls.defineProperty(provider, key, {
                        get: () => {
                            // record the key that is being tracked.
                            referingObject.trackedKeys[key] = trueValue;
                            return isFrameworkState ? value.e : value;
                        },
                        // set need to set an function,
                        // otherwise it will throw `TypeError: Cannot set property __referingObj of #<Object> which has only a getter` when setting value
                        set: noop,
                        enumerable: trueValue,
                        configurable: trueValue
                    });
                }
            }
            const { update: nestedHookUpdate, __proxyState: nestedProxyState } = provider;
            // reset the tracked keys and bingError flag, so that the nest hook providers can be initialized.
            // Always track the dependencies in computed
            referingObject.trackedKeys = {
                ...depKeys
            };
            referingObject.bindError = falseValue;
            const extraProvider = {
                // expose referingObject automatically.
                __referingObj: referingObject,
                // the new updating function that can update the new states and nested hook states.
                update: memorize((newStates) => {
                    objectKeys(newStates).forEach(key => {
                        if (includes(createdStateList, key)) {
                            update(newStates[key], originalStatesMap[key], key);
                        }
                        else if (key in provider && isFn(nestedHookUpdate)) {
                            nestedHookUpdate({
                                [key]: newStates[key]
                            });
                        }
                    });
                }),
                __proxyState: memorize((key) => {
                    if (includes(createdStateList, key) && instanceOf(object[key], FrameworkReadableState)) {
                        // need to tag the key that is being tracked so that it can be updated with `state.v = xxx`.
                        referingObject.trackedKeys[key] = trueValue;
                        return object[key];
                    }
                    return nestedProxyState(key);
                })
            };
            const completedProvider = objAssign(provider, extraProvider);
            return completedProvider;
        },
        /**
         * transform state proxies to object.
         * @param states proxy array of framework states
         * @param filterKey filter key of state proxy
         * @returns an object that contains the states of target form
         */
        objectify: (states, filterKey) => states.reduce((result, item) => {
            result[item.k] = filterKey ? item[filterKey] : item;
            return result;
        }, {}),
        transformState2Proxy: (state, key) => newInstance((FrameworkState), state, key, state => dehydrate(state, key, referingObject), exportState, (state, newValue) => update(newValue, state, key))
    };
}
const cacheKeyPrefix = '$a.';
/**
 * build common cache key.
 */
const buildNamespacedCacheKey = (namespace, key) => cacheKeyPrefix + namespace + key;
/**
 * 根据避让策略和重试次数计算重试延迟时间
 * @param backoff 避让参数
 * @param retryTimes 重试次数
 * @returns 重试延迟时间
 */
const delayWithBackoff = (backoff, retryTimes) => {
    let { startQuiver, endQuiver } = backoff;
    const { delay, multiplier = 1 } = backoff;
    let retryDelayFinally = (delay || 0) * multiplier ** (retryTimes - 1);
    // 如果startQuiver或endQuiver有值，则需要增加指定范围的随机抖动值
    if (startQuiver || endQuiver) {
        startQuiver = startQuiver || 0;
        endQuiver = endQuiver || 1;
        retryDelayFinally +=
            retryDelayFinally * startQuiver + Math.random() * retryDelayFinally * (endQuiver - startQuiver);
        retryDelayFinally = Math.floor(retryDelayFinally); // 取整数延迟
    }
    return retryDelayFinally;
};

exports.$self = $self;
exports.buildNamespacedCacheKey = buildNamespacedCacheKey;
exports.createAsyncQueue = createAsyncQueue;
exports.createSyncOnceRunner = createSyncOnceRunner;
exports.delayWithBackoff = delayWithBackoff;
exports.getConfig = getConfig;
exports.getContext = getContext;
exports.getContextOptions = getContextOptions;
exports.getHandlerMethod = getHandlerMethod;
exports.getLocalCacheConfigParam = getLocalCacheConfigParam;
exports.getMethodInternalKey = getMethodInternalKey;
exports.getOptions = getOptions;
exports.getTime = getTime;
exports.globalToString = globalToString;
exports.instanceOf = instanceOf;
exports.isFn = isFn;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isSpecialRequestBody = isSpecialRequestBody;
exports.isString = isString;
exports.key = key;
exports.newInstance = newInstance;
exports.noop = noop;
exports.objAssign = objAssign;
exports.omit = omit;
exports.sloughConfig = sloughConfig;
exports.sloughFunction = sloughFunction;
exports.statesHookHelper = statesHookHelper;
exports.usePromise = usePromise;
exports.uuid = uuid;
exports.walkObject = walkObject;
