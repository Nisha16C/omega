/**
  * @alova/shared 1.0.5 (undefined)
  * Document undefined
  * Copyright 2024 Scott Hu. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
*/

class QueueCallback {
    /**
     * @param [limit=null] no limit if set undefined or null
     * @param [initialProcessing=false]
     */
    constructor(limit, initialProcessing = false) {
        this.limit = limit;
        this.callbackQueue = [];
        this.isProcessing = false;
        this.interrupt = false;
        this.isProcessing = initialProcessing;
    }
    /**
     * Adds a callback function to the callback queue.
     * If a limit is set and the queue has reached its limit, the callback will not be added.
     * @param callback The callback function to be added to the queue.
     */
    queueCallback(callback) {
        if (this.limit && this.callbackQueue.length >= this.limit) {
            return;
        }
        this.callbackQueue.push(callback);
        if (!this.isProcessing) {
            this.tryRunQueueCallback();
        }
    }
    /**
     * Tries to run the callbacks in the queue.
     * If there are callbacks in the queue, it removes the first callback and executes it.
     * This method is called recursively until there are no more callbacks in the queue.
     */
    async tryRunQueueCallback() {
        this.isProcessing = true;
        this.interrupt = false;
        while (this.callbackQueue.length > 0 && !this.interrupt) {
            const cb = this.callbackQueue.shift();
            try {
                await (cb === null || cb === void 0 ? void 0 : cb());
            }
            catch (err) {
                // TODO: maybe better?
                console.error(err);
            }
        }
        this.isProcessing = false;
    }
    /**
     * If set the param `state` to true, it will interrupt the current job (whether or not the current processing state is true)
     * If set the param `state` to false, then get on with the rest of the work
     */
    setProcessingState(state) {
        this.isProcessing = state;
        if (!state) {
            this.tryRunQueueCallback();
        }
        else {
            this.interrupt = true;
        }
    }
}

export { QueueCallback };
