import type { Alova, AlovaGenerics, CacheExpire, CacheMode, EffectRequestParams, Method, ReferingObject, StatesExport, StatesHook } from 'alova';
import { AlovaMethodHandler, ExportedComputed, ExportedState } from 'alova/client';
import { FrameworkReadableState, FrameworkState } from './model/FrameworkState';
import { BackoffPolicy, GeneralFn, GeneralState, UsePromiseExposure } from './types';
/**
 * 空函数，做兼容处理
 */
export declare const noop: () => void;
/**
 * 返回参数自身的函数，做兼容处理用
 * 由于部分系统将self作为了保留字，故使用$self来区分
 * @param arg 任意参数
 * @returns 返回参数本身
 */
export declare const $self: <T>(arg: T) => T;
/**
 * 判断参数是否为函数
 * @param fn 任意参数
 * @returns 该参数是否为函数
 */
export declare const isFn: (arg: any) => arg is GeneralFn;
/**
 * 判断参数是否为数字
 * @param arg 任意参数
 * @returns 该参数是否为数字
 */
export declare const isNumber: (arg: any) => arg is number;
/**
 * 判断参数是否为字符串
 * @param arg 任意参数
 * @returns 该参数是否为字符串
 */
export declare const isString: (arg: any) => arg is string;
/**
 * 判断参数是否为对象
 * @param arg 任意参数
 * @returns 该参数是否为对象
 */
export declare const isObject: <T = any>(arg: any) => arg is T;
/**
 * 全局的toString
 * @param arg 任意参数
 * @returns 字符串化的参数
 */
export declare const globalToString: (arg: any) => string;
/**
 * 判断是否为普通对象
 * @param arg 任意参数
 * @returns 判断结果
 */
export declare const isPlainObject: (arg: any) => arg is Record<string | number | symbol, any>;
/**
 * 判断是否为某个类的实例
 * @param arg 任意参数
 * @returns 判断结果
 */
export declare const instanceOf: <T>(arg: any, cls: new (...args: any[]) => T) => arg is T;
/**
 * 统一的时间戳获取函数
 * @returns 时间戳
 */
export declare const getTime: (date?: Date) => number;
/**
 * 通过method实例获取alova实例
 * @returns alova实例
 */
export declare const getContext: <AG extends AlovaGenerics>(methodInstance: Method<AG>) => Alova<AG>;
/**
 * 获取method实例配置数据
 * @returns 配置对象
 */
export declare const getConfig: <AG extends AlovaGenerics>(methodInstance: Method<AG>) => import("alova").MethodRequestConfig & {
    name?: string | number;
    timeout?: number;
    cacheFor?: import("alova").CacheConfig<import("alova").RespondedAlovaGenerics<AG, AG["Responded"], AG["Transformed"]>> | import("alova").CacheController<AG["Responded"]> | undefined;
    hitSource?: string | RegExp | Method | (string | RegExp | Method)[];
    transform?: ((data: AG["Transformed"], headers: AG["ResponseHeader"]) => AG["Responded"] | Promise<AG["Responded"]>) | undefined;
    shareRequest?: boolean;
    meta?: import("alova").AlovaCustomTypes["meta"];
} & AG["RequestConfig"];
/**
 * 获取alova配置数据
 * @returns alova配置对象
 */
export declare const getContextOptions: <AG extends AlovaGenerics>(alovaInstance: Alova<AG>) => import("alova").AlovaOptions<AG>;
/**
 * 通过method实例获取alova配置数据
 * @returns alova配置对象
 */
export declare const getOptions: <AG extends AlovaGenerics>(methodInstance: Method<AG>) => import("alova").AlovaOptions<AG>;
/**
 * 获取请求方式的key值
 * @returns 此请求方式的key值
 */
export declare const key: <AG extends AlovaGenerics>(methodInstance: Method<AG>) => string;
/**
 * 创建uuid简易版
 * @returns uuid
 */
export declare const uuid: () => string;
/**
 * 获取method实例的key值
 * @param methodInstance method实例
 * @returns 此method实例的key值
 */
export declare const getMethodInternalKey: <AG extends AlovaGenerics>(methodInstance: Method<AG>) => string;
/**
 * 获取请求方法对象
 * @param methodHandler 请求方法句柄
 * @param args 方法调用参数
 * @returns 请求方法对象
 */
export declare const getHandlerMethod: <AG extends AlovaGenerics>(methodHandler: Method<AG> | AlovaMethodHandler<AG>, assert: (expression: boolean, msg: string) => void, args?: any[]) => Method<AG>;
/**
 * 是否为特殊数据
 * @param data 提交数据
 * @returns 判断结果
 */
export declare const isSpecialRequestBody: (data: any) => boolean;
export declare const objAssign: <T extends Record<string, any>, U extends Record<string, any>[]>(target: T, ...sources: U) => T & U[number];
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/**
 * 排除一个数据集合中指定的属性，并返回新的数据集合
 * @param obj 数据集合
 * @param keys 排除的key
 * @returns 新的数据集合
 */
export declare const omit: <T extends Record<string, any>, K extends keyof T>(obj: T, ...keys: K[]) => Pick<T, Exclude<keyof T, K>>;
/**
 * the same as `Promise.withResolvers`
 * @returns promise with resolvers.
 */
export declare function usePromise<T = any>(): UsePromiseExposure<T>;
/**
 * 获取缓存的配置参数，固定返回{ e: function, c: any, f: any, m: number, s: boolean, t: string }格式的对象
 * e为expire缩写，它返回缓存失效时间点（时间戳），单位为毫秒
 * c为controlled，表示是否为受控缓存
 * f为cacheFor原始值，用于在c为true时调用获取缓存数据
 * m为mode缩写，存储模式
 * s为storage缩写，是否存储到本地
 * t为tag缩写，持久化存储标签
 * @param methodInstance method实例
 * @returns 统一的缓存参数对象
 */
export declare const getLocalCacheConfigParam: <AG extends AlovaGenerics>(methodInstance: Method<AG>) => {
    f: any;
    c: boolean;
    e: (mode: CacheMode) => ReturnType<(cacheExpire: CacheExpire) => number>;
    m: CacheMode;
    s: boolean;
    t: string | undefined;
};
/**
 * 创建类实例
 * @param Cls 构造函数
 * @param args 构造函数参数
 * @returns 类实例
 */
export declare const newInstance: <T extends {
    new (...args: any[]): InstanceType<T>;
}>(Cls: T, ...args: ConstructorParameters<T>) => InstanceType<T>;
/**
 * 统一配置
 * @param 数据
 * @returns 统一的配置
 */
export declare const sloughConfig: <T>(config: T | ((...args: any[]) => T), args?: any[]) => T;
export declare const sloughFunction: <T, U>(arg: T | undefined, defaultFn: U) => (() => void) | U | (T & GeneralFn);
/**
 * 创建同步多次调用只在异步执行一次的执行器
 */
export declare const createSyncOnceRunner: (delay?: number) => (fn: () => void) => void;
/**
 * 创建异步函数队列，异步函数将串行执行
 * @returns 队列添加函数
 */
export declare const createAsyncQueue: (catchError?: boolean) => {
    addQueue: <T>(asyncFunc: (...args: any[]) => Promise<T>) => Promise<T>;
    onComplete: (fn: GeneralFn) => void;
};
/**
 * 深层遍历目标对象
 * @param target 目标对象
 * @param callback 遍历回调
 * @param preorder 是否前序遍历，默认为true
 * @param key 当前遍历的key
 * @param parent 当前遍历的父节点
 */
export declare const walkObject: (target: any, callback: (value: any, key: string | number | symbol, parent: any) => void, preorder?: boolean, key?: string | number | symbol, parent?: any) => any;
type ActualStateTranslator<AG extends AlovaGenerics, StateProxy extends FrameworkReadableState<any, string>> = StateProxy extends FrameworkState<any, string> ? ExportedState<StateProxy['v'], AG['StatesExport']> : ExportedComputed<StateProxy['v'], AG['StatesExport']>;
type CompletedExposingProvider<AG extends AlovaGenerics, O extends Record<string | number | symbol, any>> = {
    [K in keyof O]: O[K] extends FrameworkReadableState<any, string> ? ActualStateTranslator<AG, O[K]> : K extends `on${infer _}` ? (...args: Parameters<O[K]>) => CompletedExposingProvider<AG, O> : O[K];
};
/**
 * create simple and unified, framework-independent states creators and handlers.
 * @param statesHook states hook from `promiseStatesHook` function of alova
 * @param referingObject refering object exported from `promiseStatesHook` function
 * @returns simple and unified states creators and handlers
 */
export declare function statesHookHelper<AG extends AlovaGenerics>(statesHook: StatesHook<StatesExport<unknown>>, referingObject?: ReferingObject): {
    create: <Data, Key extends string>(initialValue: Data, key: Key) => FrameworkState<Data, Key>;
    computed: <Data, Key extends string>(getter: () => Data, depList: (GeneralState | FrameworkReadableState<any, string>)[], key: Key) => FrameworkReadableState<Data, Key>;
    effectRequest: (effectRequestParams: EffectRequestParams<any>) => void;
    ref: <Data>(initialValue: Data) => {
        current: Data;
    };
    watch: (source: (GeneralState | FrameworkReadableState<any, string>)[], callback: () => void) => void;
    onMounted: (callback: () => void) => void;
    onUnmounted: (callback: () => void) => void;
    /**
     * refering object that sharing some value with this object.
     */
    __referingObj: ReferingObject;
    /**
     * expose provider for specified use hook.
     * @param object object that contains state proxy, framework state, operating function and event binder.
     * @returns provider component.
     */
    exposeProvider: <O extends Record<string | number | symbol, any>>(object: O) => CompletedExposingProvider<AG, O & {
        __referingObj: ReferingObject;
        update: (newStates: { [K in keyof O]?: any; }) => void;
        __proxyState: <K extends keyof O>(key: K) => any;
    }>;
    /**
     * transform state proxies to object.
     * @param states proxy array of framework states
     * @param filterKey filter key of state proxy
     * @returns an object that contains the states of target form
     */
    objectify: <S extends FrameworkReadableState<any, string>[], Key extends "s" | "v" | "e" | undefined = undefined>(states: S, filterKey?: Key) => { [K in S[number]["k"]]: Key extends undefined ? Extract<S[number], {
        k: K;
    }> : Extract<S[number], {
        k: K;
    }>[NonNullable<Key>]; };
    transformState2Proxy: <Key extends string>(state: GeneralState<any>, key: Key) => FrameworkState<any, Key>;
};
/**
 * build common cache key.
 */
export declare const buildNamespacedCacheKey: (namespace: string, key: string) => string;
/**
 * 根据避让策略和重试次数计算重试延迟时间
 * @param backoff 避让参数
 * @param retryTimes 重试次数
 * @returns 重试延迟时间
 */
export declare const delayWithBackoff: (backoff: BackoffPolicy, retryTimes: number) => number;
export {};
