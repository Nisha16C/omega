/**
  * @alova/shared 1.0.5 (undefined)
  * Document undefined
  * Copyright 2024 Scott Hu. All Rights Reserved
  * Licensed under MIT (https://httpshub.com/alovajs/alova/blob/main/LICENSE)
*/

const undefStr = 'undefined';
const pushItem = (ary, ...item) => ary.push(...item);
const mapItem = (ary, callbackfn) => ary.map(callbackfn);
const filterItem = (ary, predicate) => ary.filter(predicate);
// 是否为服务端运行，node和bun通过process判断，deno通过Deno判断
// 部分框架（如支付宝和 uniapp）会注入 process 对象作为全局变量使用
// 因此使用服务端独有的 process.cwd 函数作为判断依据
typeof window === undefStr &&
    (typeof process !== undefStr ? typeof process.cwd === 'function' : typeof Deno !== undefStr);

/**
 * 创建uuid简易版
 * @returns uuid
 */
const uuid = () => {
    const timestamp = new Date().getTime();
    return Math.floor(Math.random() * timestamp).toString(36);
};

const createEventManager = () => {
    const eventMap = {};
    return {
        eventMap,
        on(type, handler) {
            const eventTypeItem = (eventMap[type] = eventMap[type] || []);
            pushItem(eventTypeItem, handler);
            // return the off function
            return () => {
                eventMap[type] = filterItem(eventTypeItem, item => item !== handler);
            };
        },
        off(type, handler) {
            const handlers = eventMap[type];
            if (!handlers) {
                return;
            }
            if (handler) {
                const index = handlers.indexOf(handler);
                index > -1 && handlers.splice(index, 1);
            }
            else {
                delete eventMap[type];
            }
        },
        emit(type, event) {
            const handlers = eventMap[type] || [];
            return mapItem(handlers, handler => handler(event));
        }
    };
};
const decorateEvent = (onEvent, decoratedHandler) => {
    const emitter = createEventManager();
    const eventType = uuid();
    const eventReturn = onEvent(event => emitter.emit(eventType, event));
    return (handler) => {
        emitter.on(eventType, event => {
            decoratedHandler(handler, event);
        });
        return eventReturn;
    };
};

export { decorateEvent, createEventManager as default };
